<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <style>
    body { background: #0a0a12; color: white; font-family: -apple-system, sans-serif; padding: 20px; font-size: 14px; line-height: 1.8; }
    .panel { background: rgba(10,10,18,0.97); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 20px; max-width: 480px; }
    .katex-display { margin: 1.25em 0; padding: 0.75em 1em; background: rgba(255,255,255,0.02); border-left: 2px solid rgba(100,150,255,0.3); border-radius: 8px; }
    .katex-mathml { position: absolute; clip: rect(1px,1px,1px,1px); width: 1px; height: 1px; overflow: hidden; }
  </style>
</head>
<body>
  <div class="panel">
    <h3>What is Neutrino Oscillation?</h3>
    <div id="content"></div>
  </div>

  <script>
    // Simulate RichText component parsing
    const content = `Neutrino oscillation is the quantum phenomenon where neutrinos change flavor as they travel.

A neutrino created as an electron neutrino can later be detected as a muon or tau neutrino!

**The key insight:** Flavor states are quantum superpositions of mass states:
$$|\\nu_\\alpha\\rangle = \\sum_{i=1}^{3} U_{\\alpha i} \\, |\\nu_i\\rangle$$

**How it works:**
• Flavor states (e, μ, τ) are mixtures of mass states (1, 2, 3)
• Mass states travel at slightly different speeds
• This creates quantum interference → flavor oscillates
• Depends on: energy, distance, and mixing parameters`;

    function parseMath(text) {
      const parts = [];
      let i = 0;
      
      while (i < text.length) {
        if (text[i] === "$" && text[i + 1] === "$") {
          const start = i + 2;
          const end = text.indexOf("$$", start);
          if (end !== -1) {
            parts.push({ type: "display-math", content: text.slice(start, end) });
            i = end + 2;
            continue;
          }
        }
        
        if (text[i] === "$") {
          const start = i + 1;
          let end = start;
          while (end < text.length) {
            if (text[end] === "$" && text[end + 1] !== "$") break;
            end++;
          }
          if (end < text.length && end > start) {
            parts.push({ type: "math", content: text.slice(start, end) });
            i = end + 1;
            continue;
          }
        }
        
        const start = i;
        while (i < text.length && text[i] !== "$") i++;
        if (i > start) {
          parts.push({ type: "text", content: text.slice(start, i) });
        }
      }
      return parts;
    }

    const parts = parseMath(content);
    const container = document.getElementById('content');
    
    parts.forEach(part => {
      if (part.type === 'display-math') {
        const div = document.createElement('div');
        katex.render(part.content, div, { displayMode: true, throwOnError: false });
        container.appendChild(div);
      } else if (part.type === 'math') {
        const span = document.createElement('span');
        katex.render(part.content, span, { displayMode: false, throwOnError: false });
        container.appendChild(span);
      } else {
        // Handle text with bold and newlines
        const lines = part.content.split('\n');
        lines.forEach((line, i) => {
          const boldParts = line.split(/\*\*([^*]+)\*\*/g);
          boldParts.forEach((p, j) => {
            if (j % 2 === 1) {
              const strong = document.createElement('strong');
              strong.textContent = p;
              strong.style.color = 'rgba(255,255,255,0.9)';
              container.appendChild(strong);
            } else {
              container.appendChild(document.createTextNode(p));
            }
          });
          if (i < lines.length - 1) {
            container.appendChild(document.createElement('br'));
          }
        });
      }
    });
  </script>
</body>
</html>
