You are Roo, a senior software engineer. Your task is to complete the migration of remaining files from imagining-neutrino-react to root directory:

1. **Configuration Files Migration**:
   - Merge imagining-neutrino-react/.gitignore with root .gitignore (preserve both)
   - Move imagining-neutrino-react/eslint.config.js to root
   - Move imagining-neutrino-react/tailwind.config.cjs to root
   - Merge tsconfig files (prioritize root versions)
   - Update vite.config.ts paths to reference root directory

2. **Core Files Migration**:
   - Compare and merge package.json files (keep root dependencies, add any unique from neutrino-react)
   - Update index.html paths to reference root src/ directory
   - Preserve README.md content in root documentation

3. **Verification**:
   - Ensure all build scripts work from root
   - Check all import paths are updated
   - Verify development server runs correctly

4. **Cleanup**:
   - Document changes in memory-bank/migration-log.md
   - Remove imagining-neutrino-react directory after verification

VERY IMPORTANT:
- Maintain all existing functionality
- Preserve git history where possible
- Update all relative paths to work from root
- Document any breaking changes

Upon completion, use attempt_completion with results. These instructions supersede general code mode instructions.

===

# AI Coding Agent Prompt: Migrate Neutrino Oscillation Visualization from p5.js to React + anime.js

## Objective

Migrate the interactive neutrino oscillation visualization from its current p5.js-based implementation to a modern React application using anime.js for all animation. The new implementation must faithfully reproduce all features, UI, and interactivity of the original, while leveraging best practices for React and anime.js integration.

---

## Requirements

### 1. UI Controls

- **Initial Flavor Selector:** Dropdown to choose neutrino type (Electron, Muon, Tau).
- **Energy Slider:** Range input (0.1–10 GeV) with live value display.
- **Speed Slider:** Controls animation speed (0.1–3x), with live value display.
- **Matter Effect Toggle:** Checkbox to enable/disable matter effects.
- **Density Slider:** Shown only if matter effect is enabled; controls density (0–10 g/cm³) with live value display.
- **All controls must update the simulation in real time.**
- **Controls are grouped in a floating, styled panel.**

### 2. Animation & Plotting Features

- **3D Starfield Animation:** Simulate a moving starfield background, giving a sense of motion through space.
- **Animated Neutrino Sphere:** Central colored sphere whose color blends according to the current flavor probabilities.
- **Flavor Label:** Text above the sphere shows the dominant flavor in real time.
- **Probability Plot:** Fixed-position canvas or SVG below the main view, plotting the time evolution of flavor probabilities (lines for e, μ, τ, color-coded).
- **Current Probabilities:** Circles at the plot's right edge indicate current probabilities for each flavor.
- **All animations and plots must update smoothly and in real time.**

### 3. Layout & Visual Style

- **Color Scheme:** Dark background (#000), white text, accent colors for flavors (blue for electron, orange for muon, magenta for tau).
- **Panels:** Controls and plot are in semi-transparent, rounded, shadowed boxes.
- **Fonts:** Monospaced (Fira Mono, Consolas).
- **Responsive:** Canvas/SVG resizes to window; controls and plot are absolutely positioned.
- **Visual fidelity and style must closely match the original design.**

### 4. Dynamic Behaviors

- **Animation speed and simulation parameters update instantly with UI changes.**
- **Starfield and neutrino sphere animate continuously.**
- **Probability plot updates in real time, showing a trailing history.**

### 5. Technical/Architectural Constraints

- **Use React functional components throughout.**
- **Use anime.js for all animation.**
- **Encapsulate all imperative anime.js logic using React refs and hooks (e.g., useRef, useEffect).**
- **Manage state using React state/hooks; synchronize UI controls and animation state bidirectionally.**
- **Use SVG and/or Canvas for rendering the starfield, sphere, and probability plot as appropriate.**
- **Follow best practices for integrating anime.js with React:**
  - Orchestrate complex animations using anime.js timelines.
  - Target DOM/SVG elements via refs.
  - Ensure React state changes trigger appropriate animation updates.
  - Avoid direct DOM manipulation outside of refs/hooks.
- **Componentize animation logic for reusability and maintainability.**
- **Ensure smooth, performant animation and interactivity.**

### 6. References & Inspiration

- **Original p5.js-based design:** See the provided requirements and design summary. The file is located at `context/neutrino-oscillation.html`.
- **Anime.js + React examples:** Reference the patterns in `context/react-anime-examples/compiled.txt` for:
  - Timeline orchestration
  - SVG path following
  - Bidirectional state synchronization
  - Componentized animation patterns
  - Encapsulation of imperative animation in React

---

## Deliverables

- A complete, idiomatic React implementation of the visualization, using anime.js for all animation.
- All features, UI, and interactivity as described above.
- Responsive, visually faithful, and performant.
- Well-structured, maintainable code using modern React and anime.js best practices.

===

You are Roo, a senior software engineer. Your task is to migrate remaining core files from imagining-neutrino-react to root directory:

1. **Working Directory**: Operate in ROOT directory (c:/Development/imagining-the-neutrino)
2. Migrate these specific files:
   - Move imagining-neutrino-react/src/App.tsx to src/App.tsx (if not already exists)
   - Move imagining-neutrino-react/src/main.tsx to src/main.tsx 
   - Move imagining-neutrino-react/src/index.css to src/index.css
3. Handle config files:
   - Compare imagining-neutrino-react/tsconfig.*.json with root versions
   - Merge any unique configurations
4. Verify:
   - Application builds and runs correctly
   - All imports resolve properly
5. Document changes in memory-bank/migration-log.md

VERY IMPORTANT:
- Preserve all existing functionality
- Do NOT modify context/ folder
- Verify paths in vite.config.ts

Upon completion, use attempt_completion with results. These instructions supersede general code mode instructions.

===

You are Roo, a senior software engineer. Your task is to migrate component files from imagining-neutrino-react to root directory:

1. **Working Directory**: Operate in ROOT directory (c:/Development/imagining-the-neutrino)
2. Migrate remaining component files:
   - Move imagining-neutrino-react/src/components/ files to src/components/
   - Resolve any duplicates (keep root versions)
   - Update all import paths in migrated files
3. Special cases:
   - Handle any test files
   - Preserve storybook files if they exist
4. Verify:
   - All components render correctly
   - No broken imports
5. Document changes in memory-bank/migration-log.md

VERY IMPORTANT:
- Do NOT modify context/ folder
- Maintain all existing functionality
- Verify paths in config files

Upon completion, use attempt_completion with results. These instructions supersede general code mode instructions.

===

You are Roo, a senior software engineer. Your task is to migrate utility files from imagining-neutrino-react to root directory:

1. **Working Directory**: Operate in ROOT directory (c:/Development/imagining-the-neutrino)
2. Migrate remaining utils files:
   - Move imagining-neutrino-react/src/utils/ files to src/utils/
   - Resolve any duplicates (keep root versions)
   - Update all import paths in migrated files
3. Special cases:
   - Handle colorUtils.ts duplication
   - Preserve test files
4. Verify:
   - All utility functions work after migration
   - No broken imports
5. Document changes in memory-bank/migration-log.md

VERY IMPORTANT:
- Do NOT modify context/ folder
- Maintain all existing functionality
- Verify paths in config files

Upon completion, use attempt_completion with results. These instructions supersede general code mode instructions.

===

You are Roo, a senior software engineer. Your task is the final migration phase (PHASE 3):

1. **Working Directory**: Operate in the ROOT directory (c:/Development/imagining-the-neutrino)
2. Verification steps:
   - Run test suite to confirm functionality
   - Check all component imports and renders
   - Verify animation and visualization functionality
3. Cleanup:
   - Confirm imagining-neutrino-react/src/ is empty
   - Safely remove imagining-neutrino-react/ directory
4. Final configuration adjustments:
   - Update any remaining path references
   - Verify build process
5. Document completion in memory-bank/migration-log.md

VERY IMPORTANT:
- Maintain all functionality throughout
- Preserve git history if possible
- Do NOT modify context/ folder
- Verify everything works before removing old files

Upon completion, use attempt_completion with results. These instructions supersede general code mode instructions.

===

You are Roo, a senior software engineer. Your task is to migrate source files (PHASE 2):

1. **Working Directory**: Operate in the ROOT directory (c:/Development/imagining-the-neutrino)
2. Move files from imagining-neutrino-react/src/ to src/:
   - Components: Move all .tsx files maintaining folder structure
   - Context: Move SimulationContext.tsx to src/context/
   - Utils: Move all utility files to src/utils/
   - Types: Move type definitions to src/types/
   - App files: Move App.tsx, main.tsx, etc. to src/
3. Update all relative imports in moved files to reflect new paths
4. Handle special cases:
   - Preserve vite.svg in public/
   - Keep all test files with their components
5. Verify no files reference imagining-neutrino-react/ paths
6. Document changes in memory-bank/migration-log.md

VERY IMPORTANT:
- Do NOT modify context/ folder
- Maintain all existing functionality
- Verify paths in vite.config.ts and tsconfig.json

Upon completion, use attempt_completion with results. These instructions supersede general code mode instructions.

===

You are Roo, a senior software engineer. Your task is to prepare the root directory for migration (PHASE 1):

1. **Working Directory**: Operate in the ROOT directory (c:/Development/imagining-the-neutrino)
2. Create folder structure:
   - src/
   - public/
   - types/
3. Merge configuration files (ROOT priority):
   - Merge imagining-neutrino-react/package.json → root/package.json
   - Merge imagining-neutrino-react/tsconfig.json → root/tsconfig.json
   - Merge imagining-neutrino-react/vite.config.ts → root/vite.config.ts
4. Preserve all scripts, dependencies, and configurations
5. Document changes in memory-bank/migration-log.md

VERY IMPORTANT: 
- Do NOT modify anything in context/ folder
- Keep all existing functionality intact
- Verify paths in config files point to new locations

Upon completion, use attempt_completion with results. These instructions supersede general code mode instructions.

===

You are Roo, a highly skilled software engineer. Your task is to consolidate duplicate utility functions in the codebase:

1. Remove duplicate colorUtils.ts files (keep only one in src/utils/)
2. Merge neutrino physics helpers from utils/neutrinoPhysics.ts into physics/NuFastPort.ts
3. Create a central utilities index file (src/utils/index.ts) for all helper functions
4. Update all imports to use the new centralized utilities

Your scope is strictly limited to utility function consolidation. Document changes in memory-bank/refactor-log.md.

These instructions supersede general code mode instructions.

===

You are Roo, an experienced technical leader who is inquisitive and an excellent planner. Your task is to analyze the imagining-neutrino-react/src directory to:

1. Map out the current component and file structure
2. Identify duplicate/redundant code
3. Find opportunities for better code organization
4. Spot inconsistent implementations
5. Note any anti-patterns

Analyze these key areas:
- Component hierarchy and relationships
- State management approach
- Utility functions and helpers
- Animation implementations
- Physics calculations
- Type definitions

Use tools like list_files and read_file as needed. Document your findings in memory-bank/analysis.md.

Your scope is strictly limited to analysis - do not make any changes. Provide a comprehensive report of findings and recommendations.

Upon completion, use attempt_completion with your analysis. These instructions supersede general architect mode instructions.

===

You are Roo, a highly skilled software engineer with extensive knowledge in TypeScript and type definitions. Your task is to resolve the TypeScript error related to the anime.js import in the NeutrinoSphere component.

Based on the previous work:
1. The anime.js import currently has a @ts-ignore comment due to missing type definitions
2. We need to properly type the anime.js import to maintain type safety

Specific instructions:
1. Check if @types/animejs is available in the project (package.json)
2. If not available, add the proper type definitions
3. Remove the @ts-ignore comment from the anime.js import
4. Ensure all anime.js usage in NeutrinoSphere.tsx is properly typed

Your scope is strictly limited to:
- Adding proper type definitions for anime.js
- Typing the anime.js import and usage
- Maintaining all existing functionality

Upon completion, use the `attempt_completion` tool to summarize the changes made. These specific instructions supersede any general code mode instructions.

===

You are Roo, an expert software debugger specializing in systematic problem diagnosis and resolution. Your task is to fix the identified issues in the NeutrinoSphere component.

Based on the analysis:
1. Fix the property name mismatches (change `Pm`/`Pt` to `Pmu`/`Ptau` to match SimulationContext)
2. Improve type safety by adding proper TypeScript interfaces
3. Enhance animation cleanup
4. Ensure all changes maintain existing functionality

Specific instructions:
- Modify `imagining-neutrino-react/src/components/NeutrinoSphere.tsx`
- Keep all existing features (color blending, animations)
- Maintain compatibility with SimulationContext
- Add proper type definitions
- Improve animation cleanup

Your scope is strictly limited to fixing these specific issues in the NeutrinoSphere component.

Upon completion, use the `attempt_completion` tool to summarize the changes made. These specific instructions supersede any general debug mode instructions.

===

You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. Your task is to implement the Probability Plot visualization component.

Based on the architectural plan and the current code structure:
1. Implement the `imagining-neutrino-react/src/components/ProbabilityPlot.tsx` component.
2. Use either SVG or Canvas to render a 2D line plot showing the historical evolution of electron, muon, and tau flavor probabilities over distance. Referencing the original p5.js code (`context/neutrino-oscillation.html`) might be helpful for understanding the plot's structure and data mapping.
3. Use the `useSimulation` hook to access the `probabilityHistory` array from the `SimulationContext`. This array contains the data points for the plot.
4. Draw three distinct lines on the plot, one for each flavor (Electron, Muon, Tau), using the specified accent colors (blue, orange, magenta).
5. At the right edge of the plot, draw small circles (or other markers) for each flavor, indicating their *current* probabilities (the values from the last entry in `probabilityHistory`).
6. Ensure the plot is positioned below the VisualizationArea and is responsive to window resizing.
7. Consider using anime.js for animating the drawing of the lines or the movement of the current probability markers if using SVG. If using Canvas, you will likely draw the plot imperatively within an animation loop, potentially using anime.js for value interpolation if needed. Reference `context/react-anime-examples/compiled.txt` for anime.js integration patterns.
8. Do not modify any other components in this task. Focus solely on the Probability Plot.

Your scope is strictly limited to implementing the Probability Plot component, rendering the probability history as lines, displaying the current probabilities as markers, and connecting it to the `SimulationContext`.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of the Probability Plot implementation, including the technology used for rendering and how it displays the historical and current probabilities. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as a coder.

===

You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. Your task is to implement the Flavor Label component.

Based on the architectural plan and the current code structure:
1. Implement the `imagining-neutrino-react/src/components/FlavorLabel.tsx` component.
2. Use the `useSimulation` hook to access the current flavor probabilities (latest entry in `probabilityHistory`) from the `SimulationContext`.
3. Determine the dominant flavor (Electron, Muon, or Tau) based on which probability (Pe, Pm, Pt) is currently the highest.
4. Render text that displays the name of the dominant flavor above the Neutrino Sphere.
5. Apply basic styling to the label to ensure it's visible and positioned correctly relative to the sphere.

Your scope is strictly limited to implementing the Flavor Label component and displaying the dominant flavor based on simulation probabilities.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of the Flavor Label implementation, including how it determines and displays the dominant flavor. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as a coder.

===

You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. Your task is to implement the Neutrino Sphere visualization component.

Based on the architectural plan and the current code structure:
1. Implement the `imagining-neutrino-react/src/components/NeutrinoSphere.tsx` component.
2. Render a sphere visualization. You can choose an appropriate technology (e.g., SVG, Canvas, or a simple div with border-radius). Consider how to handle color blending based on probability.
3. Use the `useSimulation` hook to access the current flavor probabilities (`probabilityHistory`, specifically the latest entry) from the `SimulationContext`.
4. Dynamically update the color of the sphere based on these probabilities, blending the flavor colors (blue for electron, orange for muon, magenta for tau) according to their current probability values.
5. Use anime.js to animate color transitions and potentially other properties of the sphere (e.g., a subtle pulsing effect). Use React refs and `useEffect` to integrate anime.js. Reference the patterns in `context/react-anime-examples/compiled.txt` for guidance on integrating anime.js with React.
6. Position the sphere centrally within the visualization area.
7. Do not implement the Flavor Label or Probability Plot in this task. Focus solely on the Neutrino Sphere.

Your scope is strictly limited to implementing the Neutrino Sphere component, dynamically updating its color based on simulation probabilities, and adding an anime.js animation.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of the Neutrino Sphere implementation, including how its color is updated and the type of anime.js animation added. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as a coder.

===

You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. Your task is to implement the Starfield background visualization component for the neutrino oscillation project.

Based on the architectural plan, project context gained from the documentation and memory bank files, and the current code structure:
1. Implement the `imagining-neutrino-react/src/components/Starfield.tsx` component.
2. Use either a Canvas or WebGL context within this component to render a moving starfield effect that gives a sense of motion through space. Consider performance for real-time animation.
3. The animation speed of the starfield should be influenced by the `speed` parameter from the `SimulationContext`. Use the `useSimulation` hook to access this state.
4. Consider using anime.js for animating star properties (like position or opacity) if you choose a DOM/SVG approach, or implement the animation loop directly if using Canvas/WebGL.
5. Ensure the starfield is positioned as a background element that fills the visualization area and is responsive to window resizing.
6. Do not implement the Neutrino Sphere or Probability Plot in this task. Focus solely on the Starfield.

Your scope is strictly limited to implementing the Starfield component and connecting its animation speed to the `SimulationContext`.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of the Starfield implementation, including the technology used for rendering and how it's connected to the simulation speed. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as a coder.

===

You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. Your task is to port the neutrino oscillation physics calculation logic from the original p5.js code (`context/neutrino-oscillation.html`) into the React application.

Based on the architectural plan and the current code structure:
1.  Analyze the p5.js code in `context/neutrino-oscillation.html` to identify the functions and logic responsible for calculating neutrino flavor probabilities based on initial flavor, energy, speed, matter effect, and density. Look for mathematical formulas and simulation loops related to oscillation.
2.  Port this calculation logic to TypeScript, integrating it into `imagining-neutrino-react/src/context/SimulationContext.tsx` or a new utility file (e.g., `imagining-neutrino-react/src/utils/neutrinoPhysics.ts`). Placing it in a utility file might be cleaner for separating concerns.
3.  Modify `SimulationContext.tsx` to:
    -   Import and use the ported physics logic.
    -   Implement a mechanism (e.g., using `useEffect` or a dedicated function triggered by state changes) to recalculate probabilities whenever relevant simulation parameters (`initialFlavor`, `energy`, `speed`, `matter`, `density`) change.
    -   Update the `probabilityHistory` state over time based on these calculations. This will likely involve a simulation loop or step function. Consider how the animation speed will affect this update loop.

Your scope is strictly limited to porting the physics calculation logic and integrating it with the `SimulationContext` to update the probability history. Do not implement any visualization or animation logic related to rendering the probabilities.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of the ported physics logic and how it updates the `probabilityHistory` in the `SimulationContext`. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as a coder.

===

You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. Your task is to implement the UI controls within the `ControlsPanel` component and integrate them with the `SimulationContext`.

Based on the architectural plan and the previously created files:
1.  Modify the `imagining-neutrino-react/src/components/ControlsPanel.tsx` file.
2.  Add the following UI controls as described in the main task requirements:
    -   A dropdown (select) for the Initial Flavor (Electron, Muon, Tau).
    -   A range input (slider) for Energy (0.1–10 GeV). Include a display for the current value.
    -   A range input (slider) for Speed (0.1–3x). Include a display for the current value.
    -   A checkbox for the Matter Effect toggle.
    -   A range input (slider) for Density (0–10 g/cm³), which should only be visible when the Matter Effect checkbox is enabled. Include a display for the current value.
3.  Use the `useSimulation` hook (or similar hook you defined in `SimulationContext.tsx`) to access the relevant state variables (`initialFlavor`, `energy`, `speed`, `matter`, `density`) and their corresponding setter functions from the `SimulationContext`.
4.  Ensure that changing the value of any UI control updates the corresponding state in the `SimulationContext`.
5.  Apply basic inline styles or use a CSS class to position the controls panel as a floating element (absolute positioning). You don't need to fully replicate the styling yet, just ensure it's positioned.

Your scope is strictly limited to implementing these UI controls in `ControlsPanel.tsx` and connecting them to the `SimulationContext`. Do not implement any visualization or animation logic in this task.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of the implemented controls and their connection to the `SimulationContext`. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as a coder.

===

You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices. Your task is to begin implementing the React application structure for the neutrino oscillation visualization migration.

Based on the architectural plan provided by the Architect mode:
1.  Create the `SimulationContext` using React Context and hooks in `imagining-neutrino-react/src/context/SimulationContext.tsx`. This context should initially hold state variables for `initialFlavor`, `energy`, `speed`, `matter`, `density`, `time`, and `probabilityHistory`. Include basic setter functions for these states. You do not need to implement the probability calculation logic yet.
2.  Create placeholder functional components based on the proposed hierarchy in the `imagining-neutrino-react/src/components/` directory:
    -   `App.tsx` (main component, wrap with SimulationContext Provider)
    -   `ControlsPanel.tsx` (basic structure)
    -   `VisualizationArea.tsx` (basic structure)
    -   `Starfield.tsx` (basic structure)
    -   `NeutrinoSphere.tsx` (basic structure)
    -   `FlavorLabel.tsx` (basic structure)
    -   `ProbabilityPlot.tsx` (basic structure)

These components should initially render simple text indicating their name (e.g., `Controls Panel`). The goal is to establish the component structure and state management context.

Your scope is strictly limited to creating these files and adding the basic structure and context provider. Do not implement any detailed UI, animation, or complex logic in this task.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of the files created and the basic structure implemented, including the `SimulationContext`. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as a coder.

===

You are Roo, an experienced technical leader who is inquisitive and an excellent planner. Your task is to analyze the provided p5.js code for a neutrino oscillation visualization, understand its structure, features, and how it handles animation and user interaction. Based on this analysis and the requirements outlined in the parent task (Migrate Neutrino Oscillation Visualization from p5.js to React + anime.js), plan the high-level architecture for the React application.

Your plan should include:
1.  A proposed React component hierarchy.
2.  A state management strategy using React Context and hooks for simulation parameters and visualization data.
3.  Identification of key areas where anime.js will be integrated using React refs and hooks.
4.  Any initial thoughts on using SVG or Canvas for different visualization elements (starfield, sphere, plot).

Analyze the file `context/neutrino-oscillation.html`. Focus on understanding the p5.js setup, how UI controls interact with the simulation logic, how animations are implemented in p5.js, and how the probability plot is generated.

Your scope is strictly limited to analyzing the existing code and planning the React architecture. Do not write any React code in this task.

Upon completion, use the `attempt_completion` tool to provide a concise yet thorough summary of your architectural plan, including the proposed component structure and state management approach. This summary will be used to track progress on the overall migration task.

These specific instructions supersede any conflicting general instructions you might have as an architect.

===

# AI Coding Agent Prompt: Migrate Neutrino Oscillation Visualization from p5.js to React + anime.js

## Objective

Migrate the interactive neutrino oscillation visualization from its current p5.js-based implementation to a modern React application using anime.js for all animation. The new implementation must faithfully reproduce all features, UI, and interactivity of the original, while leveraging best practices for React and anime.js integration.

---

## Requirements

### 1. UI Controls

- **Initial Flavor Selector:** Dropdown to choose neutrino type (Electron, Muon, Tau).
- **Energy Slider:** Range input (0.1–10 GeV) with live value display.
- **Speed Slider:** Controls animation speed (0.1–3x), with live value display.
- **Matter Effect Toggle:** Checkbox to enable/disable matter effects.
- **Density Slider:** Shown only if matter effect is enabled; controls density (0–10 g/cm³) with live value display.
- **All controls must update the simulation in real time.**
- **Controls are grouped in a floating, styled panel.**

### 2. Animation & Plotting Features

- **3D Starfield Animation:** Simulate a moving starfield background, giving a sense of motion through space.
- **Animated Neutrino Sphere:** Central colored sphere whose color blends according to the current flavor probabilities.
- **Flavor Label:** Text above the sphere shows the dominant flavor in real time.
- **Probability Plot:** Fixed-position canvas or SVG below the main view, plotting the time evolution of flavor probabilities (lines for e, μ, τ, color-coded).
- **Current Probabilities:** Circles at the plot's right edge indicate current probabilities for each flavor.
- **All animations and plots must update smoothly and in real time.**

### 3. Layout & Visual Style

- **Color Scheme:** Dark background (#000), white text, accent colors for flavors (blue for electron, orange for muon, magenta for tau).
- **Panels:** Controls and plot are in semi-transparent, rounded, shadowed boxes.
- **Fonts:** Monospaced (Fira Mono, Consolas).
- **Responsive:** Canvas/SVG resizes to window; controls and plot are absolutely positioned.
- **Visual fidelity and style must closely match the original design.**

### 4. Dynamic Behaviors

- **Animation speed and simulation parameters update instantly with UI changes.**
- **Starfield and neutrino sphere animate continuously.**
- **Probability plot updates in real time, showing a trailing history.**

### 5. Technical/Architectural Constraints

- **Use React functional components throughout.**
- **Use anime.js for all animation.**
- **Encapsulate all imperative anime.js logic using React refs and hooks (e.g., useRef, useEffect).**
- **Manage state using React state/hooks; synchronize UI controls and animation state bidirectionally.**
- **Use SVG and/or Canvas for rendering the starfield, sphere, and probability plot as appropriate.**
- **Follow best practices for integrating anime.js with React:**
  - Orchestrate complex animations using anime.js timelines.
  - Target DOM/SVG elements via refs.
  - Ensure React state changes trigger appropriate animation updates.
  - Avoid direct DOM manipulation outside of refs/hooks.
- **Componentize animation logic for reusability and maintainability.**
- **Ensure smooth, performant animation and interactivity.**

### 6. References & Inspiration

- **Original p5.js-based design:** See the provided requirements and design summary. The file is located at `context/neutrino-oscillation.html`.
- **Anime.js + React examples:** Reference the patterns in `context/react-anime-examples/compiled.txt` for:
  - Timeline orchestration
  - SVG path following
  - Bidirectional state synchronization
  - Componentized animation patterns
  - Encapsulation of imperative animation in React

---

## Deliverables

- A complete, idiomatic React implementation of the visualization, using anime.js for all animation.
- All features, UI, and interactivity as described above.
- Responsive, visually faithful, and performant.
- Well-structured, maintainable code using modern React and anime.js best practices.

===

The `vite.config.ts` file at `imagining-neutrino-react/vite.config.ts` has a remaining reference to `animejs` in the `optimizeDeps` section that needs to be removed.

Your task is to:
1. Remove the line `include: ['animejs/lib/anime.es.js']` from the `optimizeDeps` section in `imagining-neutrino-react/vite.config.ts`.
2. Ensure the explicit global declaration `declare const anime: any;` is present in `src/types/anime.d.ts`.
3. Execute the following cleanup and reinstall commands in the `imagining-neutrino-react` directory:
```sh
rm -rf node_modules package-lock.json
npm install
```
4. Finally, run `npm run dev` in the `imagining-neutrino-react` directory to verify the build is successful.
5. Report completion using the `attempt_completion` tool, summarizing the changes made and the outcome of the `npm run dev` command.

These instructions supersede any conflicting general instructions your mode might have. You should only perform the work outlined in these instructions and not deviate.

===

Implement the anime.js CDN solution:

1. First, remove the animejs npm package by updating package.json:
```json
{
  "dependencies": {
    "animejs": "remove this line"
  }
}
```

2. Add anime.js CDN to index.html:
```html

  

```

3. Create src/types/anime.d.ts with:
```ts
declare const anime: typeof import('animejs').default;
```

4. Update all component imports to simply use the global `anime` object without imports

5. Update vite.config.ts to remove the animejs alias

This matches the pattern used successfully in all the react-anime-examples.

===

Implement a definitive solution for anime.js imports across all components:

1. First, create a type declaration file `src/types/anime.d.ts` with:
```ts
declare module 'animejs/lib/anime.es.js' {
  const anime: any;
  export default anime;
}
```

2. Update tsconfig.json to include type declarations:
```json
{
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./src/types"]
  }
}
```

3. Update vite.config.ts to alias animejs imports:
```ts
import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      'animejs': path.resolve(__dirname, 'node_modules/animejs/lib/anime.es.js')
    }
  }
});
```

4. Update all component imports to use:
```ts
import anime from 'animejs';
```

This solution provides:
- Proper TypeScript typing
- Correct module resolution for Vite
- Clean import syntax across components
- No need for @ts-ignore comments

===

Integrate all visualization components in the main App for the Neutrino Oscillation Visualization React app, completing the migration:

**Scope:**
- In `imagining-neutrino-react/src/App.tsx`, integrate ControlsPanel, Starfield, NeutrinoSphere, ProbabilityPlot, and FlavorLabel.
- Wire up real simulation state: compute flavor probabilities in real time based on current controls (flavor, energy, speed, matter, density).
- Pass correct props/context to all components for live updates.
- Ensure all UI controls, animation, and plots update instantly and smoothly.
- Polish layout for full responsiveness and visual fidelity, matching the original p5.js design.
- Do not add new features or documentation yet.
- ONLY perform the work outlined above.
- Signal completion with the attempt_completion tool, summarizing the integration and file locations.
- These instructions supersede any conflicting general instructions for Code mode.

===

Implement the FlavorLabel component for the Neutrino Oscillation Visualization React app, following the architecture and requirements:

**Scope:**
- Create a `FlavorLabel` React functional component in `imagining-neutrino-react/src/components/`.
- Display the dominant flavor (Electron, Muon, Tau) above the NeutrinoSphere, updating in real time as probabilities change (accept as prop or via context).
- Style the label with monospaced font, white text, and the accent color of the dominant flavor (blue, orange, magenta).
- Ensure the label is responsive and visually aligned above the sphere.
- Do not implement additional features or logic.
- Place all code in `imagining-neutrino-react/src/components/`.
- ONLY perform the work outlined above.
- Signal completion with the attempt_completion tool, summarizing the implemented features and file locations.
- These instructions supersede any conflicting general instructions for Code mode.

===

Implement the ProbabilityPlot component for the Neutrino Oscillation Visualization React app, following the architecture and requirements:

**Scope:**
- Create a `ProbabilityPlot` React functional component in `imagining-neutrino-react/src/components/`.
- Render a real-time plot of flavor probabilities (electron, muon, tau) as animated lines using SVG or Canvas (choose for best performance and fidelity).
- Animate plot lines and current-value circles at the right edge using anime.js, encapsulated with React refs and hooks.
- Accept probability history and current probabilities as props (or via context), and update the plot in real time as data changes.
- Use color coding: blue (electron), orange (muon), magenta (tau).
- Style the plot in a semi-transparent, rounded, shadowed box with a dark background, matching the app’s visual style.
- Do not implement the flavor label yet.
- Place all code in `imagining-neutrino-react/src/components/`.
- ONLY perform the work outlined above.
- Signal completion with the attempt_completion tool, summarizing the implemented features and file locations.
- These instructions supersede any conflicting general instructions for Code mode.

===

Implement the NeutrinoSphere animation component for the Neutrino Oscillation Visualization React app, following the architecture and requirements:

**Scope:**
- Create a `NeutrinoSphere` React functional component in `imagining-neutrino-react/src/components/`.
- Render the central sphere using Canvas or SVG (choose for best color blending and performance).
- Animate the sphere’s color blending in real time according to the current flavor probabilities (passed as props or via context).
- Use anime.js for all animation (color transitions, scale, rotation if needed), encapsulated with React refs and hooks.
- Ensure the animation updates smoothly and instantly with state changes.
- The component should be reusable and isolated from other animation logic.
- Do not implement the probability plot or flavor label yet.
- Place all code in `imagining-neutrino-react/src/components/`.
- ONLY perform the work outlined above.
- Signal completion with the attempt_completion tool, summarizing the implemented features and file locations.
- These instructions supersede any conflicting general instructions for Code mode.

===

Implement the Starfield animation component for the Neutrino Oscillation Visualization React app, following the architecture and requirements:

**Scope:**
- Create a `Starfield` React functional component in `imagining-neutrino-react/src/components/`.
- Render a moving 3D starfield background using Canvas or SVG (choose whichever best fits performance and fidelity).
- Animate star positions and motion using anime.js timelines, encapsulated via React refs and hooks (useEffect, useRef).
- The animation must update smoothly in real time and respond instantly to changes in the simulation speed (passed as a prop).
- The component should be reusable and isolated from other animation logic.
- Do not implement other animation components (sphere, plot) yet.
- Place all code in `imagining-neutrino-react/src/components/`.
- ONLY perform the work outlined above.
- Signal completion with the attempt_completion tool, summarizing the implemented features and file locations.
- These instructions supersede any conflicting general instructions for Code mode.

===

Implement the initial React application shell for the Neutrino Oscillation Visualization migration, following the architecture and requirements below:

**Scope:**
- Create the `App` component in `imagining-neutrino-react/src/`, managing all simulation state (flavor, energy, speed, matter effect, density, probability history).
- Implement the `ControlsPanel` component and all UI controls:
  - Initial Flavor Selector (dropdown: Electron, Muon, Tau)
  - Energy Slider (0.1–10 GeV, live value)
  - Speed Slider (0.1–3x, live value)
  - Matter Effect Toggle (checkbox)
  - Density Slider (0–10 g/cm³, live value, only visible if matter effect enabled)
- Ensure all controls update the simulation state in real time.
- Style the ControlsPanel as a floating, semi-transparent, rounded, shadowed box with monospaced font and dark theme, per requirements.
- Use React functional components and hooks throughout.
- Do NOT implement animation or plotting yet—focus only on state management, controls, and layout.
- Place all code in `imagining-neutrino-react/src/`.
- ONLY perform the work outlined above; do not implement animation or other components yet.
- Signal completion with the attempt_completion tool, summarizing the implemented features and file locations.
- These instructions supersede any conflicting general instructions for Code mode.

===

You are to design the architecture for migrating the interactive neutrino oscillation visualization from its current p5.js-based implementation (`context/neutrino-oscillation.html`) to a modern React application using anime.js for all animation. 

**Scope:**
- Analyze the original p5.js code and the requirements in ANIME_PROMPT.md.
- Design a React component hierarchy that encapsulates:
  - UI controls (flavor selector, sliders, toggles, density slider)
  - Animated 3D starfield background
  - Animated neutrino sphere with color blending
  - Flavor label and probability plot (SVG/Canvas)
  - Responsive, styled layout with floating panels
- Specify how anime.js should be integrated for each animation (starfield, sphere, plot, etc.), referencing best practices from `context/react-anime-examples/compiled.txt`.
- Define state management and synchronization between controls and animation.
- Map all p5.js features and interactivity to React/anime.js equivalents.
- Identify reusable animation/component patterns.
- Document any architectural decisions, including how to ensure visual fidelity and performance.

**Instructions:**
- ONLY perform the architectural analysis and design as outlined above.
- Signal completion by using the attempt_completion tool, providing a concise yet thorough summary of the architecture, component breakdown, and migration mapping in the result parameter. This summary will be used to guide implementation subtasks.
- These instructions supersede any conflicting general instructions for Architect mode.

===

Okay, I want to migrate from p5.js to anime.js for the react project, since that seems like a better option for the animation and plotting 

There are some reference examples that use Anime.js (and React together) in @/context/react-anime-examples/compiled.txt 

I want to achieve a design inspired by @/context/neutrino-oscillation.html  

@/Image2.png shows you how it looks like in the browser when rendered. This uses p5.js, but I want to see if we can achieve a better design and implementation with the same ideas, style, and aesthetics using anime.js

Investigate what it would take to do this, read and analyze any and all files and context needed to gather enough information, and prepare a detailed prompt with clear, precise instructions for an AI coding agent to do this task

Save the final prompt in a new file ANIME_PROMPT.md

---

Do this in multiple phases, delegate the subtasks, do not do any of them yourself

===

Synthesize the following into a detailed, precise prompt for an AI coding agent to migrate the neutrino oscillation visualization from p5.js to React+anime.js:

- The full requirements and design summary of the current p5.js-based visualization (see previous Architect mode result).
- The React+anime.js integration patterns, best practices, and reusable ideas (see previous Ask mode result).

Your prompt must:
- Clearly specify all UI controls, animation/plotting features, layout, and dynamic behaviors to be implemented.
- Instruct the agent to use React functional components, anime.js for all animation, and SVG/Canvas as appropriate.
- Require encapsulation of imperative anime.js logic using refs and hooks, following best practices for React integration.
- Reference the original design and the provided anime.js+React examples as inspiration, but require a modern, idiomatic React implementation.
- Include any relevant constraints, such as responsive design, color schemes, and real-time interactivity.
- Be written as a single, self-contained prompt suitable for direct use by an AI coding agent.
- Save the final prompt as ANIME_PROMPT.md.

You should only perform the work outlined above and not deviate. When finished, signal completion using the attempt_completion tool, providing a concise yet thorough summary of the outcome in the result parameter. These specific instructions supersede any conflicting general instructions your mode might have.

===

Review the file `context/react-anime-examples/compiled.txt`, which contains multiple reference examples of using anime.js with React (and SVG/Canvas). Your goals:

- Identify and summarize the key patterns and techniques for integrating anime.js with React, including how animation timelines are managed, how DOM/SVG elements are targeted, and how React state or props interact with anime.js.
- Extract reusable ideas for animating SVGs, lines, shapes, or UI elements, especially those relevant to scientific or data visualizations.
- Note any best practices or pitfalls for combining React's declarative model with anime.js's imperative animation API.
- Highlight any UI/UX or architectural approaches that could be leveraged for migrating a p5.js-based visualization to React+anime.js.

You should only perform the work outlined above and not deviate. When finished, signal completion using the attempt_completion tool, providing a concise yet thorough summary of the outcome in the result parameter. These specific instructions supersede any conflicting general instructions your mode might have.

===

Analyze the file `context/neutrino-oscillation.html` and the rendered appearance as shown in Image2.png (described as a p5.js-based interactive visualization for neutrino oscillations). Your goals:

- Extract and summarize all functional requirements, UI controls, user interactions, and animation/plotting features present in the current design.
- Describe the overall structure, layout, and visual style, including color schemes, controls, plots, and any dynamic behaviors.
- Identify any technical or architectural patterns used (e.g., how state is managed, how animation and plotting are coordinated).
- Output a concise but thorough summary of the current design and requirements, suitable for informing a migration to a new animation library.

You should only perform the work outlined above and not deviate. When finished, signal completion using the attempt_completion tool, providing a concise yet thorough summary of the outcome in the result parameter. These specific instructions supersede any conflicting general instructions your mode might have.

===

You are to gather and summarize all relevant context for migrating a React project’s animation/plotting from p5.js to anime.js, inspired by neutrino-oscillation.html and Image2.png. Your scope includes:
- Reviewing neutrino-oscillation.html and Image2.png to understand the current design, features, and aesthetics.
- Identifying all React project files that use p5.js (search for p5.js imports/usages in imagining-neutrino-react/).
- Reviewing any @compiled reference examples that use anime.js with React (see context/react-anime-examples/).
- Summarizing the key features, visual elements, and interactivity present in the current implementation.
- Listing all technical and design references relevant for the migration.

You should only perform the work outlined above and not deviate. When complete, signal with attempt_completion, providing a concise yet thorough summary of the findings and references. These instructions supersede any conflicting general instructions for Ask mode.

===

# AI Coding Agent UI Redesign Prompt: Neutrino Oscillation Visualization

---

## GOAL

**Redesign the UI to exactly match the style, structure, and compactness of Image 2 (the "good" example and `neutrino-oscillation.html`).**  
The deliverable must look, behave, and "feel" like Image 2, with a horizontal, unified top control bar, a centered visualization, and a card/pill-like probability plot overlay at the bottom.  
**Do NOT reproduce the clunky, scattered, or panel-heavy appearance of Image 3.**

---

## CONTEXT & REFERENCES

- **Image 2** (attached): The *target* layout.
    - A single, floating, pill-like control bar at the top with all controls (flavor dropdown, energy slider, speed slider, matter effect checkbox).
    - Centered, large main visualization (neutrino/starfield).
    - Bottom-center, pill/card overlay for the probability plot, matching the top bar's styling.
    - Unified, minimal, modern, dark-themed, with rounded corners, shadows, and pleasing font.
- **Image 3**: The *wrong* layout (do NOT reproduce).
- Reference source: `context/neutrino-oscillation.html` and `context/backup.html` (use for HTML/CSS inspiration and markup structure).

---

## DETAILED REQUIREMENTS

### 1. **Layout & Structure**

- **Top Control Bar**
    - Floating, pill-like container at the top of the viewport.
    - *All* main controls (flavor dropdown, energy slider, speed slider, matter effect checkbox) are placed left-to-right in a single row.
    - Controls are aligned, spaced, and visually balanced.
    - No floating/docked panels elsewhere for controls.

- **Main Visualization**
    - The p5.js canvas (starfield + neutrino) fills the area beneath the control bar and above the plot overlay.
    - No extra borders or containers except for the top/bottom bars.

- **Bottom Probability Plot**
    - Card/pill overlay centered horizontally, near the bottom.
    - Contains the probability plot, with flavor-colored lines, axes, and legend.
    - Same styling as the top bar (background, corner radius, shadow, spacing).

- **No Sidebars/Scroll Panels**
    - Do NOT use (or leave behind) side, floating, or scrolling parameter panels.
    - All controls are in the top bar, and the only overlay is the bottom plot card.

### 2. **Visual Design & Aesthetics**

- **Style**
    - Dark theme (e.g., #181920 or #23243a backgrounds).
    - Rounded corners (at least 16px, preferably 20px).
    - Soft box-shadow on bars/overlays for elevation.
    - Modern, clean sans-serif or monospaced font.
    - Controls: slim, custom-styled (not default browser), with accent colors (e.g., blue for sliders, white for text).
    - Consistent margins, padding, and spacing.

- **Visual Unity**
    - Top control bar and bottom plot overlay must match in style and color.
    - All elements visually connected; nothing feels "out of place."

- **Responsiveness**
    - Layout adapts gracefully for small screens:
        - Controls stack/scroll if needed.
        - Plot card stays readable and centered.
    - No horizontal scrolling or clipped content.

### 3. **Functionality & Usability**

- All controls must be fully functional and two-way bound to state (Alpine.js or equivalent).
- Animation and plot update live as controls are changed.
- Plot: clear axes, flavor-colored lines, readable legend; matches the sample.
- Controls:
    - Flavor dropdown: Electron, Muon, Tau.
    - Energy slider: smooth, labeled, with value display.
    - Speed slider: smooth, labeled, value (e.g., "1.0x").
    - Matter effect: label and checkbox.
- All interactive elements have visual focus/hover states.

### 4. **Implementation Guidance**

- **HTML/CSS**
    - Start with (or adapt) the markup from `context/neutrino-oscillation.html` for the control bar and plot card.
    - Modularize the CSS for these containers and controls.
    - Use CSS variables for colors, shadows, radii, spacing.
    - Use flexbox or grid for layout inside bars.

- **JavaScript/TypeScript**
    - Bind all controls to simulation state (Alpine.js stores or equivalent).
    - Ensure all state changes are reflected in the visualization and plot.
    - Update the plot rendering so it is always inside the bottom card, with no floating axes or legends.

- **Testing & Documentation**
    - Manual test at all viewport sizes.
    - Update README and screenshots to reflect the new look.

---

## DO NOT

- Do NOT scatter controls in multiple panels.
- Do NOT leave any floating, misaligned, or overlapping controls.
- Do NOT use default browser styling for controls.
- Do NOT degrade or remove existing functionality.

---

## DELIVERABLE

A beautiful, modern interface that matches the reference in Image 2 and `neutrino-oscillation.html`:
- Top bar: all controls, floating, pill-like, modern.
- Centered visualization: neutrino/starfield, uncluttered.
- Bottom card: probability plot, styled and labeled.
- Responsive, accessible, and visually unified.

---

**Study the reference markup and screenshot closely.  
You must deliver a UI that matches this look and structure—the single top control bar and bottom plot overlay are required.  
Do not remove or hide any UI!**


---

First create a plan of action for this

@/Image2.png @/Image3.png (historical note: this doesn't exist anymore, it was deleted)

===


You are tasked with thoroughly reviewing the new React project in the `imagining-neutrino-react` directory to:
1. Verify its completeness by checking for any missing core functionality from the original implementation
2. Identify and remove any duplicate files or redundant functionality
3. Clean up the codebase by removing unused imports, variables, or dependencies
4. Ensure all components follow consistent coding patterns and best practices
5. Confirm the UI matches the target design from Image 2 exactly

Key areas to examine:
- Compare functionality with the original implementation
- Check for duplicate state management
- Verify all controls work as expected
- Ensure the visualization and plot update correctly
- Confirm responsive behavior across screen sizes

Use appropriate tools (read_file, search_files, etc.) to analyze the codebase thoroughly. Signal completion with attempt_completion when done, summarizing any issues found and cleanup performed.

===

You are tasked with completing the final implementation and integration phase of the new React application located in the `imagining-neutrino-react` directory. All previous steps of the migration plan (scaffolding, static layout, state porting, p5.js integration, NuFast integration, Zod validation, probability plot component) have been reported as completed.

Your primary goal is to make the application fully functional and ensure its UI precisely matches the appearance, structure, and compactness of the reference Image 2.

Your task is to:
1.  Navigate to the `imagining-neutrino-react` directory.
2.  Implement all the required UI controls within the `TopControlBar.tsx` component. This includes:
    -   Flavor dropdown (Electron, Muon, Tau).
    -   Energy slider with value display.
    -   Speed slider with value display.
    -   Matter effect checkbox.
    -   Density input with label (if applicable, based on NuFast needs).
    -   Max distance input with label (if applicable, based on plot needs).
    -   Play, Pause, and Reset buttons.
    -   Ensure labels and any associated tooltips are included as per Image 2.
    -   Style these controls using Tailwind CSS to be slim, modern, and visually consistent with the floating top bar.
3.  Connect these implemented UI controls to the React state management logic in `src/state.tsx`. User interactions with the controls should dispatch actions to update the application state. Utilize the Zod validation already implemented before applying state updates from input controls.
4.  Ensure that changes in the application state correctly trigger updates in the `NeutrinoVisualization.tsx` (p5.js sketch) and `ProbabilityPlot.tsx` components. Pass necessary state variables and dispatch functions as props, and ensure the components' rendering logic reacts to these prop changes (e.g., updating sketch parameters, re-calculating/re-drawing the plot).
5.  Make any necessary final adjustments to the Tailwind CSS styling across all components (`App.tsx`, `TopControlBar.tsx`, `VisualizationArea.tsx`, `BottomPlotContainer.tsx`, `ProbabilityPlot.tsx`, `NeutrinoVisualization.tsx`, etc.) to ensure the entire UI layout, spacing, colors, fonts, rounded corners, and shadows precisely match the reference Image 2. Pay close attention to the alignment and spacing of controls in the top bar.
6.  Confirm that the application is fully responsive and maintains the correct layout and usability on various screen sizes.
7.  Verify that all original functionality, including dynamic visualization and plot updates, is working correctly in the new React application.
8.  Signal completion by using the `attempt_completion` tool, providing a comprehensive summary of the completed UI implementation, control wiring, state integration, and final styling adjustments made to match Image 2. Include the necessary CLI command to launch the application in the browser for the user to verify the result.
9.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with removing the legacy Alpine.js and Chota-based frontend code from the original project directory (`c:/Development/imagining-the-neutrino`), now that the core components and logic are being rewritten in React and Tailwind CSS. This is the eighth step in the phased migration plan.

Your task is to:
1.  Navigate to the original project directory (`c:/Development/imagining-the-neutrino`).
2.  Identify and remove files and directories specifically related to the old frontend implementation using Alpine.js and Chota CSS. This likely includes:
    -   `src/alpine/` directory (containing Alpine.js state logic).
    -   `src/styles/` directory (containing Chota CSS and potentially other vanilla CSS).
    -   Significant portions of `index.html` related to the old UI structure and Alpine.js directives.
    -   Relevant sections in `src/main.ts` that initialized Alpine.js or the old UI components.
3.  Be careful NOT to remove files related to:
    -   The p5.js visualization core logic (unless it was fully migrated and is no longer needed in the original location).
    -   The NuFast physics engine (`src/physics/`).
    -   Build configuration (e.g., `vite.config.ts`).
    -   TypeScript configuration (`tsconfig.json`).
    -   Testing setup (e.g., `test/`).
    -   Documentation (e.g., `.md` files).
    -   Project configuration files (`package.json`, `package-lock.json`, etc.).
4.  Use appropriate tools (like `apply_diff` or `write_to_file` for modifying files, and potentially `execute_command` for removing directories if necessary, though prefer `apply_diff` or `write_to_file` for modifying file contents).
5.  After removing the code, ensure the remaining project structure is clean and the build still works (though the application will likely no longer render a UI from the original entry point).
6.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the legacy code removed.
7.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with implementing the probability plot as a dedicated React component in the new application located in the `imagining-neutrino-react` directory. This is the seventh step in the phased migration plan.

The original project displays a probability plot showing neutrino flavor changes over distance. This plot needs to be rendered within the `#bottom-plot-container` as a floating card, matching the style defined in Image 2. The architectural plan suggests implementing this using either a canvas (adapting the existing p5.js plot code) or SVG.

Your task is to:
1.  Navigate to the `imagining-neutrino-react` directory.
2.  Create a new React component (e.g., `ProbabilityPlot.tsx`) within the `imagining-neutrino-react/src/components/` directory.
3.  Implement the plot rendering logic within `ProbabilityPlot.tsx`. You can either:
    -   Adapt the existing p5.js probability plot code to run within this component (similar to how the main visualization was integrated), rendering onto a canvas element managed by the component.
    -   Implement the plot rendering using SVG elements, mapping the probability data to SVG shapes and lines.
    -   Choose the approach that you believe is most suitable and maintainable within the React/Tailwind context.
4.  Ensure the component renders the probability plot with:
    -   Flavor-colored lines representing the oscillation probabilities.
    -   Clear axes (Probability and Distance (km)).
    -   A readable legend if necessary (though Image 2 doesn't explicitly show a separate legend, ensure the lines are distinguishable by color/label).
5.  Modify the `BottomPlotContainer.tsx` component to render the new `ProbabilityPlot.tsx` component.
6.  Connect the `ProbabilityPlot.tsx` component to the React state (migrated earlier) to receive the calculated probability data and simulation parameters needed for rendering. Ensure the plot updates dynamically as the relevant state changes.
7.  Ensure the component's container (`BottomPlotContainer`) maintains the floating, pill/card styling with dark background, rounded corners, and box shadow as defined in Image 2, using Tailwind CSS classes.
8.  Do NOT fully implement all UI controls or finalize any other parts of the UI beyond the probability plot itself in this step. Focus solely on getting the plot component to render correctly and display the data.
9.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the probability plot component implementation and rendering approach.
10. These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with implementing Zod validation for the simulation control inputs in the new React application located in the `imagining-neutrino-react` directory. This is the sixth step in the phased migration plan.

The architectural plan specifies using Zod for runtime validation of user input, particularly for the control parameters.

Your task is to:
1.  Navigate to the `imagining-neutrino-react` directory.
2.  Install Zod as a dependency in the new React project.
3.  Define Zod schemas for the key simulation parameters that users can control (e.g., initial flavor, energy, speed, matter effect). Refer to the original project's state or physics logic to understand the expected data types and constraints for these parameters.
4.  Integrate the Zod validation into the state management logic or the components that handle input changes. When a control's value changes, use the defined Zod schemas to validate the new value.
5.  If validation fails, handle the error appropriately. For this step, simply logging the error to the console or setting an internal error state is sufficient. Displaying validation errors in the UI can be done later.
6.  Do NOT fully implement the UI controls (beyond basic input handling for validation) or finalize the visualization/probability plot integration in this step. Focus solely on defining the Zod schemas and implementing the validation logic when inputs change.
7.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the Zod validation implementation, including the defined schemas and where the validation logic was added.
8.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with integrating the NuFast physics engine functions into the new React application located in the `imagining-neutrino-react` directory. This is the fifth step in the phased migration plan.

The NuFast physics engine provides the core calculations for neutrino oscillations. The architectural plan indicates that the functions from the original project's physics files (`src/physics/`) can be integrated directly as pure TypeScript functions.

Your task is to:
1.  Navigate to the `imagining-neutrino-react` directory.
2.  Locate the relevant physics calculation files in the original project (`c:/Development/imagining-the-neutrino/src/physics/`).
3.  Copy the necessary physics calculation files or functions into the `imagining-neutrino-react/src/physics/` directory.
4.  Ensure these functions are correctly imported and accessible within the new React project. You may need to adjust import paths.
5.  Modify the React state management logic (in `src/state.tsx` or related files) to call these NuFast functions when simulation parameters change and update the state accordingly (e.g., calculate new probability curves).
6.  Do NOT implement the UI controls or Zod validation in this step. Focus solely on making the NuFast physics functions available and integrated into the state update flow.
7.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the NuFast physics engine integration into the React application.
8.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with integrating the existing p5.js visualization sketch into the new React application located in the `imagining-neutrino-react` directory. This is the fourth step in the phased migration plan.

The existing p5.js sketch code is responsible for rendering the neutrino visualization (starfield, neutrino globe) and potentially the probability plot (although the plot is expected to be in a separate container). The architectural plan suggests wrapping the `createNeutrinoSketch` function in a React component using `useRef` and `useEffect`.

Your task is to:
1.  Navigate to the `imagining-neutrino-react` directory.
2.  Locate the existing p5.js sketch code in the original project (likely in `src/main.ts` or a related visualization file).
3.  Create a new React component (e.g., `NeutrinoVisualization.tsx`) within the `imagining-neutrino-react/src/components/` directory.
4.  Implement the p5.js integration within `NeutrinoVisualization.tsx` using `useRef` to manage the canvas element and `useEffect` to initialize and clean up the p5 sketch. Follow the pattern of creating a new p5 instance that attaches to a specific DOM element managed by React.
5.  Modify the `VisualizationArea.tsx` component to render the new `NeutrinoVisualization.tsx` component. Ensure the `VisualizationArea` provides an appropriate container for the p5 canvas.
6.  Consider how simulation parameters from the React state (migrated in the previous step) will be passed down to the p5 sketch. You may need to update the sketch logic or expose methods on the sketch instance to receive updates via component props. For this step, focus on getting the basic sketch to render; dynamic updates based on state changes can be refined later.
7.  Do NOT implement the UI controls, integrate NuFast physics, or Zod validation in this step. Focus solely on getting the p5.js visualization to render within the React component structure.
8.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the p5.js visualization integration into the React application.
9.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with porting the state management logic from the original project's Alpine.js implementation to the new React application located in the `imagining-neutrino-react` directory. This is the third step in the phased migration plan.

The original project uses Alpine.js stores (e.g., `simParams`, `animation`, `plotParams`, `tooltips`) to manage the application's state and reactive behavior. Your goal is to replicate this state management and the associated logic (e.g., event handlers, computed properties) using React's built-in state management features like `useState`, `useReducer`, or potentially the Context API if global state is necessary.

Your task is to:
1.  Navigate to the `imagining-neutrino-react` directory.
2.  Analyze the Alpine.js implementation in the original project (likely in `src/alpine/`). Identify all state variables, their initial values, and how they are updated based on user interactions or simulation events.
3.  In the new React project, implement the necessary state variables using `useState` or `useReducer` within the appropriate components (likely the main `App.tsx` or a dedicated state provider component).
4.  Replicate the logic that updates this state based on user input from the controls (which are currently placeholders). You may need to anticipate how events from the controls will interact with this state.
5.  If certain state needs to be shared across multiple components, consider using React's Context API to provide this state.
6.  Do NOT implement the UI controls themselves or integrate the visualization/physics engine in this step. Focus solely on setting up the React state structure and the logic to manage it, based on the original Alpine.js implementation.
7.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the state management logic migrated from Alpine.js to React.
8.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with implementing the basic static layout and key components for the new React application in the `imagining-neutrino-react` directory, using Tailwind CSS for styling. This is the second step in the phased migration plan.

The target UI layout is based on the reference Image 2, which features:
- A floating, pill-like control bar at the top.
- A centered main visualization area below the top bar.
- A floating, pill/card overlay for the probability plot at the bottom.

Your task is to:
1.  Navigate to the `imagining-neutrino-react` directory (you will need to include `cd imagining-neutrino-react &&` before your commands if using `execute_command` later, but for file operations, use the relative path).
2.  Install Tailwind CSS in the new React project. Follow the official Tailwind CSS documentation for React/Vite integration.
3.  Create the main App component (or modify the existing one) to establish the basic page structure.
4.  Create placeholder React components for the key UI areas as outlined in the architectural plan:
    -   `TopControlBar.tsx`: For the top floating control bar. Include placeholder divs or text to represent where controls will go.
    -   `VisualizationArea.tsx`: For the main visualization area. Include a placeholder div.
    -   `BottomPlotContainer.tsx`: For the bottom floating probability plot container. Include a placeholder div or text.
5.  Apply Tailwind CSS classes to these components and the main App structure to achieve the layout and styling of Image 2:
    -   Use flexbox or grid for overall layout.
    -   Apply `fixed` positioning, `top`, `bottom`, `left`, `right`, and `transform` classes for the floating and centered `TopControlBar` and `BottomPlotContainer`.
    -   Apply dark background colors, rounded corners, and box shadows using Tailwind utility classes to match the pill-like style of Image 2 for the top and bottom bars.
    -   Ensure the `VisualizationArea` fills the space between the top and bottom bars.
    -   Set up basic dark theme styling for the body/main container.
6.  Ensure the placeholder components are rendered correctly within the App.
7.  Do NOT implement any functionality, state management, or integrate p5.js/NuFast/Zod in this step. Focus solely on the static layout and styling using React components and Tailwind CSS to visually match Image 2.
8.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the implemented static layout, created components, and applied Tailwind CSS styling.
9.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with scaffolding a new React application within the current workspace directory (`c:/Development/imagining-the-neutrino`).

Your task is to:
1.  Execute the necessary CLI command to create a new React project using Vite (as specified in the architectural plan). The project should be created in a new directory (e.g., `imagining-neutrino-react`) to keep it separate from the existing project files during the rewrite. Choose React with TypeScript.
2.  Ensure the command is compatible with a PowerShell 5.1 environment.
3.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the command executed and the result of the scaffolding process.
4.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with planning the architectural rewrite of the "Imagining the Neutrino" project frontend. The current stack is Alpine.js with vanilla CSS (including Chota). The goal is to rewrite the frontend using **React** for the UI framework, **Tailwind CSS** for styling, and **Zod** for data validation. The core visualization (p5.js) and physics engine (NuFast) should be integrated into the new React application.

Your task is to:
1.  Define the high-level architecture for the React application.
2.  Outline the key React component structure required to implement the UI based on the reference Image 2 (Top control bar, main visualization area, bottom probability plot container).
3.  Plan how the existing p5.js visualization sketch will be integrated into a React component.
4.  Plan how the NuFast physics engine (currently in `src/physics/`) will be integrated and accessed within the React application.
5.  Outline the strategy for integrating Tailwind CSS for all styling.
6.  Plan the integration of Zod for input data validation, particularly for the control parameters.
7.  Create a high-level plan for migrating the existing Alpine.js state management logic and event handling to React's state management (e.g., useState, useReducer, Context API, or a state management library if deemed necessary, though start simple).
8.  Outline a phased approach or key steps for implementing this rewrite.
9.  Signal completion by using the `attempt_completion` tool, providing a concise yet thorough summary of the architectural plan, component structure outline, and integration strategies for React, Tailwind, and Zod.
10. These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with a significant overhaul of the UI layout and styling to ensure it precisely matches the reference Image 2, particularly focusing on the floating top control bar and the floating bottom probability plot container. The previous attempts to fix the top bar's visibility were unsuccessful, indicating a potentially deeper issue with the current styling implementation.

Your task is to:
1.  Conduct a thorough analysis of the current HTML structure (`index.html`) and CSS (`src/style.css`, `src/styles/layout.css`, etc.) related to the main layout, the `#top-control-bar`, and the `#bottom-plot-container`.
2.  Implement potentially major changes to the CSS to achieve the floating, pill-like appearance and positioning for both `#top-control-bar` and `#bottom-plot-container` as seen in Image 2. This may involve:
    -   Using `position: fixed` for both elements.
    -   Setting `top` and `bottom` properties appropriately.
    -   Utilizing `left`, `right`, and `transform: translateX(-50%)` (or similar techniques) for horizontal centering.
    -   Ensuring sufficient `z-index` values so they appear above the visualization.
    -   Applying the required dark semi-transparent `background`, generous `border-radius` (around 16-20px), and `box-shadow` for depth.
    -   Adjusting padding and margins within these containers.
3.  Within the `#top-control-bar`, ensure all controls (flavor dropdown, energy slider, speed slider, matter effect checkbox, density input, max distance input, play/pause/reset buttons, and associated labels/tooltips) are arranged horizontally, are correctly aligned, and have appropriate spacing. You may need to adjust the internal layout of this div using flexbox or grid.
4.  Verify that the probability plot rendering code correctly draws the plot within the `#probPlotCanvas` element, and that `#probPlotCanvas` is correctly sized and positioned inside the `#bottom-plot-container`. Ensure axes, labels, and lines are visible and accurate.
5.  Refine the styling of individual controls (inputs, buttons, select) to match the clean, modern look of Image 2, potentially overriding default browser styles and conflicting Chota CSS rules.
6.  Confirm that the responsive layout still works, allowing controls to stack or adjust on smaller screens if necessary, while maintaining the overall floating bar concept.
7.  Preserve all existing functionality and Alpine.js bindings. Do not remove or alter any interactive elements or their associated data binding/event listeners.
8.  Prioritize achieving the visual appearance of Image 2 for the top and bottom bars over strictly adhering to the previous layout implementation details if they conflict.
9.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the major styling and layout changes implemented to match Image 2.
10. These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with making a final adjustment to the UI styling. The application's layout is mostly correct, but the top control bar (`#top-control-bar`) is not visible in the browser.

Your task is to:
1.  Examine the CSS rules applied to `#top-control-bar`.
2.  Identify and correct any CSS properties that might be preventing it from being displayed (e.g., `display: none`, `visibility: hidden`, incorrect positioning, z-index issues, or incorrect dimensions).
3.  Ensure `#top-control-bar` is positioned correctly as a fixed, floating element at the top of the viewport, centered horizontally, with appropriate padding, rounded corners, box-shadow, and a dark semi-transparent background, as specified in the initial requirements and the reference Image 2.
4.  Confirm that the controls inside the bar are still laid out horizontally and correctly styled.
5.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the CSS fix applied to make the top control bar visible and correctly positioned.
6.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with completing the UI redesign by addressing the remaining visual and functional issues. The application now launches, and the p5 sketch initializes, but the top control bar is not visible, and the probability plot in the bottom container is not fully rendered or accurate compared to the reference Image 2.

Your tasks are:
1.  Analyze the CSS and HTML to determine why the `#top-control-bar` is not visible. Ensure it has the correct CSS properties for a fixed, floating element (position, top, left/right/transform for centering, z-index, background, padding, border-radius, box-shadow).
2.  Review and refine the CSS for `#bottom-plot-container` and the `#probPlotCanvas` inside it. Ensure the container has the correct fixed positioning (bottom, left/right/transform for centering), z-index, background, padding, border-radius, and box-shadow to match the top bar's pill-like style. Ensure the canvas itself fits correctly within this container.
3.  Examine the JavaScript/TypeScript code that handles the probability plot rendering (likely in `src/main.ts` or a related plot utility file). Verify that it correctly:
    - Selects the `#probPlotCanvas` element within `#bottom-plot-container`.
    - Draws the probability lines for each flavor with the correct colors.
    - Renders the axes, labels ("Probability", "Time →", and distance scale), and legend within the bounds of the canvas inside the container.
    - Updates the plot dynamically as control parameters change.
4.  Make any necessary adjustments to the CSS to ensure individual controls within the top bar are correctly styled (custom appearance, not default browser), spaced, and aligned horizontally as shown in Image 2.
5.  Confirm that the application is responsive and the layout adapts gracefully on smaller screens, with controls potentially stacking.
6.  Ensure all Alpine.js bindings remain functional.
7.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the styling and plot rendering fixes implemented.
8.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with debugging and updating the JavaScript/TypeScript code responsible for initializing the p5.js sketch and rendering the probability plot. After the recent HTML restructuring, the browser console logs indicate that the p5 sketch cannot find the required DOM elements (`#p5-container` and `#probPlotCanvas`).

Your tasks are:
1.  Locate and analyze the code where the p5.js sketch is initialized and where the probability plot canvas is selected or created (likely in `src/main.ts` or related files).
2.  Identify why the elements `#p5-container` and `#probPlotCanvas` are not being found by the sketch.
3.  Modify the JavaScript/TypeScript code to correctly select and attach the p5 sketch to `#p5-container`.
4.  Modify the JavaScript/TypeScript code to correctly select the `#probPlotCanvas` element, which is now located inside the `#bottom-plot-container` div.
5.  Ensure that the probability plot is rendered correctly onto the `#probPlotCanvas` within its new container.
6.  Verify that the core functionality related to the visualization and plot updates with control changes is preserved.
7.  Signal completion by using the `attempt_completion` tool, providing a concise summary of the JavaScript/TypeScript changes made to address the element selection issue.
8.  These specific instructions supersede any conflicting general instructions you may have.

===

You are tasked with styling the UI elements in index.html to match the reference design from context/neutrino-oscillation.html. The key styling requirements are:

1. For #top-control-bar:
   - Position: fixed at top with some margin
   - Background: dark semi-transparent (rgba(20,20,30,0.85))
   - Padding: 16px 24px
   - Border radius: 12px
   - Box shadow: 0 2px 16px rgba(0,0,0,0.1)
   - Font: Modern sans-serif or monospace
   - Controls should be horizontally laid out with proper spacing

2. For #bottom-plot-container:
   - Position: fixed at bottom center
   - Background: same as top bar
   - Padding: 12px 20px
   - Border radius: 12px
   - Box shadow: same as top bar
   - Width: appropriate for the plot (reference uses 500px)

3. For controls:
   - Custom styled inputs (not browser default)
   - Consistent spacing
   - Accent colors for interactive elements
   - Hover/focus states

4. General:
   - Dark theme throughout
   - Remove any Chota CSS classes that conflict
   - Ensure proper z-index for overlays
   - Make responsive (stack controls on small screens)

5. Preserve all functionality and Alpine.js bindings
6. Use attempt_completion when done
7. These instructions supersede any conflicting general instructions

===

You are tasked with cleaning up the index.html file to complete the UI restructuring. The file currently has:
1. Duplicate control content (lines 154-281) that repeats what's already in the top control bar
2. A mixing parameters panel (lines 288-377) that should be removed
3. Some encoding issues (e.g., "极狐" appears in places it shouldn't)

Your tasks are:
1. Remove the duplicate control content (lines 154-281)
2. Remove the mixing parameters panel completely (lines 288-377)
3. Fix any encoding issues in the file
4. Ensure all Alpine.js bindings are preserved
5. Verify the final structure matches:
   - Single top control bar (#top-control-bar)
   - Visualization canvas (#p5-container) 
   - Bottom plot container (#bottom-plot-container)
6. Use attempt_completion when done, summarizing the changes made
7. These instructions supersede any conflicting general instructions

===

Update Memory Bank files to accurately reflect current project status by:
1. Reviewing all project documentation (README.md, STATUS.md, etc.)
2. Extracting key information from each document
3. Updating the relevant Memory Bank files:
   - productContext.md with overview from README.md
   - progress.md with milestones from STATUS.md  
   - decisionLog.md with design choices from HLD/LLD
   - systemPatterns.md with implementation details
4. Ensuring all updates maintain consistent formatting
5. Using apply_diff for modifications rather than full rewrites
6. Reporting completion via attempt_completion when done

===

# AI Coding Agent Redesign and Aesthetic Overhaul Prompt

## Objective

The current neutrino oscillation visualization interface is *functional* but **aesthetically unappealing, unpolished, and not user-friendly**. The layout, control panels, and visual balance require a complete overhaul. Your task is to design and implement a much more visually appealing, intuitive, and educational interface, using the references provided below for inspiration.

---

## Context & References

- **Do NOT touch the `context/` folder.**
- Use `context/neutrino-oscillation.html` and `context/backup.html` as direct inspiration for design, layout, style, and interactivity.
    - These files contain clean, compact layouts, attractive color schemes, clear controls, and good use of space.
- The codebase is already modular and cleaned up.

---

## Issues With Current UI (See Screenshot)

- Controls are poorly aligned and visually heavy.
- The main visualization and plot are awkwardly spaced and visually disconnected.
- There is too much dead space; elements do not feel "anchored."
- Panels are too large and not visually grouped.
- Input fields and sliders are not visually unified or styled in a modern way.
- The educational/tooltips are not prominent or elegantly integrated.
- Overall, the look is not inviting or professional.

---

## Goals for the Redesign

1. **Layout & Structure**
   - Create a visually balanced, *compact* interface.
   - Use overlay panels, pill-like or card-like containers, and visually pleasing grouping.
   - Ensure controls, plot, and animation are logically grouped and visually connected.
   - Avoid wasted space; make full use of the available viewport while keeping the UI uncluttered.
   - Consider a layout similar to `context/backup.html` (left controls, bottom plot, main canvas centered).

2. **Style & Aesthetics**
   - Adopt a modern, clean dark theme with subtle gradients, drop shadows, and rounded corners.
   - Style controls (sliders, inputs, checkboxes, buttons) to be slim, visually consistent, and attractive.
   - Use color, contrast, and hierarchy to guide attention (e.g., highlight the main neutrino, probability plot, and current values).
   - Use smooth transitions and hover/focus effects.

3. **Educational & Interactive Features**
   - Integrate tooltips or info icons with LaTeX-rendered formulas and explanations, styled to be visually appealing and easy to access.
   - Provide helpful labels, legends, and axis annotations for the plot.
   - Consider adding flavor icons, color-coded legends, or animated transitions for flavor changes.

4. **Responsiveness**
   - Ensure the UI works well on both wide and narrow screens.
   - Panels should rearrange or collapse gracefully on small devices.

5. **Accessibility**
   - Ensure good color contrast and keyboard accessibility for all controls.

6. **Polish & Delight**
   - Add subtle animations (e.g., button hover, plot updates, starfield motion) for a more engaging experience.
   - Use high-quality, readable fonts.

---

## Implementation Requirements

- **Do NOT modify the `context/` folder.**
- Use the cleaned, modular source code as your base.
- You may restructure HTML/CSS and refactor JavaScript/TypeScript modules as needed for aesthetics and maintainability.
- Update and optimize CSS (or switch frameworks if justified).
- All code must be maintainable, modular, and easy to adapt.
- Update docs/screenshots to reflect the new design.

---

## Process Guidance

1. **Analyze** the layouts and visual styles in `context/neutrino-oscillation.html` and `context/backup.html`. Aim to capture their clarity, compactness, and visual appeal.
2. **Sketch** a new layout (wireframe if needed), specifying positions for:
    - Visualization canvas
    - Controls (grouped by function)
    - Probability plot
    - Mixing parameters
    - Tooltips/educational overlays
    - Legends/labels
3. **Redesign HTML/CSS**: Refactor or rewrite the layout using modern CSS. Use flexbox, grid, or absolute positioning as appropriate. Add shadows, borders, and backgrounds for separation.
4. **Restyle Controls**: Make sliders, input fields, and buttons visually consistent and attractive. Use custom styles or CSS variables.
5. **Integrate Tooltips**: Use info icons or similar triggers for educational content. Render LaTeX formulas attractively.
6. **Re-implement Plot & Animation Positioning**: Ensure the plot, animation, and controls are visually and functionally connected.
7. **Test Responsiveness and Accessibility**.
8. **Polish and Iterate**: Solicit feedback, test in different browsers/devices, and refine the design.

---

## Deliverables

- A fully overhauled, visually polished, and user-friendly interface.
- All controls and educational features implemented and styled.
- Updated screenshots/docs reflecting the new look.

---

## References

- `context/neutrino-oscillation.html`
- `context/backup.html`
- Screenshot above (shows current poor result)
- Current modular source codebase

---

**Create an interface that is beautiful, modern, and a pleasure to use—worthy of an educational physics tool.**

===

**Task: Documentation Implementation**

1. Update each documentation file according to DOC_UPDATES.md:
   - README.md: Add current features, setup instructions
   - STATUS.md: Update progress milestones
   - IMPLEMENTATION.md: Add new modules/algorithms
   - ARCHITECTURE.md: Reflect current component structure
   - HLD.md: Update design decisions
   - LLD.md: Add class diagrams for new components
   - TESTS.md: Document current test coverage

2. Ensure:
   - Consistent terminology across files
   - Version numbers updated
   - Diagrams match current implementation
   - Code snippets are accurate

3. Verify:
   - All links work
   - Formatting is consistent
   - No outdated references remain

**Constraints:**
- Follow DOC_UPDATES.md precisely
- Maintain Markdown formatting standards
- Preserve existing document structure where valid
- Use attempt_completion when all updates are complete

===

**Task: Documentation Review and Update Plan**

1. Analyze current documentation files:
   - README.md
   - STATUS.md  
   - IMPLEMENTATION.md
   - ARCHITECTURE.md
   - HLD.md
   - LLD.md
   - TESTS.md

2. For each document:
   - Identify outdated sections
   - Note missing information
   - Flag inconsistencies
   - Determine needed diagrams/snippets

3. Create update roadmap:
   - Priority order for updates
   - Cross-document consistency checks
   - Standardized formatting rules
   - Version control strategy

4. Output:
   - DOC_UPDATE_PLAN.md with:
     * File-by-file change requirements
     * Consistency matrix
     * Review checklist

**Constraints:**
- Do not modify actual documentation files
- Focus on analysis and planning only
- Reference current codebase structure
- Use attempt_completion when plan is complete

===

**Task: Cross-Browser Validation & Accessibility Testing**

1. Test viewport responsiveness:
   - Mobile (<768px) layout validation
   - Tablet (768-1024px) control grouping
   - Desktop (>1024px) canvas/plot proportions

2. Accessibility checks:
   - WCAG AA color contrast ratios
   - Screen reader navigation flow
   - Keyboard-only operation validation

3. Performance analysis:
   - Layout shift metrics during transitions
   - Three.js render loop impact
   - MathJax initialization overhead

4. Browser compatibility:
   - Chrome/Edge latest
   - Firefox ESR
   - Safari 16+

**Constraints:**
- Use browser devtools for audits
- Reference RISK_ANALYSIS.md for known issues
- Document failures in TEST_RESULTS.md
- Use attempt_completion when validation complete

===

**Task: Educational Component Integration**

1. Create `src/styles/education.css` with:
   - Tooltip positioning and transition animations
   - Info icon hover/focus states
   - LaTeX formula styling (font sizes, colors)
   - Responsive content card layouts

2. Update `index.html`:
   - Add info icons next to key parameters
   - Insert hidden content divs with LaTeX formulas
   - Implement Alpine.js toggle bindings for tooltips
   - Include MathJax CDN for LaTeX rendering

3. Modify `src/style.css`:
   - Import education.css
   - Add z-index layers for canvas/tooltip hierarchy

4. Verify:
   - Formulas render correctly on initial load
   - Tooltips don't interfere with Three.js raycasting
   - Screen reader accessibility of hidden content

**Constraints:**
- Use CSS Custom Properties from variables.css
- Maintain Alpine.js component structure
- Keep LaTeX content separate from core logic
- Reference context/backup.html for activation patterns
- Use attempt_completion when educational features are functional

===

**Task: Control Styling Implementation**

1. Create `src/styles/controls.css` with:
   - Custom slider styles with track/thumb gradients
   - Unified input field designs (text/number/select)
   - Modern button variants (primary, secondary, icon)
   - Checkbox/radio custom styles
   - Focus states and transitions

2. Update existing controls in `index.html`:
   - Apply new CSS classes from controls.css
   - Add aria-labels where needed
   - Group related controls with semantic containers

3. Modify `src/style.css`:
   - Import controls.css
   - Remove legacy control styles
   - Add dark/light theme compatibility checks

4. Verify:
   - All Alpine.js bindings function correctly
   - Control states work across browsers
   - Color contrast meets WCAG AA standards

**Constraints:**
- Use CSS Custom Properties from variables.css
- Maintain existing DOM IDs for JavaScript compatibility
- Do NOT alter Three.js/Plotly.js rendering logic
- Reference context/neutrino-oscillation.html for styling patterns
- Use attempt_completion when styling is applied and validated

===

**Task: CSS/HTML Restructuring Implementation**

1. Create `src/styles/` directory with:
   - `variables.css`: Implement CSS variable hierarchy from CSS_ARCHITECTURE.md
   - `layout.css`: Grid system per LAYOUT_DESIGN.md diagrams
   - `core.css`: Base element styles (typography, buttons, inputs)

2. Update `index.html`:
   - Add semantic container divs with CSS Grid classes
   - Reorganize control panels into card groups
   - Position plot/canvas per spatial relationships diagram

3. Modify `src/style.css`:
   - Import new style sheets
   - Remove deprecated styles
   - Add transition animations for UI elements

4. Verify:
   - No Three.js canvas positioning regressions
   - Plotly.js chart container responsiveness
   - Alpine.js component bindings remain functional

**Constraints:**
- Reference LAYOUT_DESIGN.md for structural changes
- Use CSS Custom Properties from CSS_ARCHITECTURE.md
- Maintain existing TypeScript module interfaces
- Do NOT implement control styling yet (next phase)
- Use attempt_completion when core layout is stable

===

**Subtasks: UI Redesign Architectural Plan**

1. Analyze `context/neutrino-oscillation.html` and `context/backup.html` to extract:
   - Layout patterns (grid/flexbox structures)
   - Color schemes and typography scales
   - Control grouping strategies
   - Space utilization techniques

2. Create wireframe proposal addressing:
   - Canvas/plot spatial relationship
   - Control panel organization (parameter groups, card layouts)
   - Tooltip/educational element placement
   - Responsive breakpoints

3. Propose CSS architecture:
   - Variable hierarchy for theming
   - Layout strategy (CSS Grid vs Flexbox)
   - Animation/transition plan
   - Third-party library requirements

4. Identify risk areas:
   - Three.js integration points
   - Existing TypeScript module interfaces
   - Vite build process implications

**Deliverables:**
- Markdown document with layout diagrams
- CSS variable scheme
- HTML structure proposal
- Implementation roadmap

**Constraints:**
- Do NOT modify actual code files
- Focus only on architectural planning
- Use attempt_completion when done

===

# AI Coding Agent Cleanup & Modularization Task: "Imagining the Neutrino"

---

## Project Context

This is a modern TypeScript/Vite/Alpine.js/p5.js project for interactive visualization of neutrino oscillations. Over time, legacy files (early HTML demos, Three.js, Plotly, etc.), redundant code, and monolithic files have accumulated. The goal is a complete cleanup for maintainability, clarity, and improved prompt context usability.

---

## Key Instructions

### 1. **Do NOT modify or remove anything in the `context/` folder.**
- Treat the entire `context/` directory as read-only and out of scope for cleanup or refactoring.

### 2. **Remove Redundant/Obsolete Files**
- Delete legacy and unused files: old HTML/JS demos (e.g., `context/backup.html`), unused static assets, deprecated Three.js/Plotly.js modules, obsolete layouts, duplicate utilities, etc.
- Remove or archive Three.js code (`scene3d/`, `NeutrinoSphere.ts`, `Starfield.ts`, `SceneManager.ts`) and Plotly.js code if p5.js is the only visualization engine now.
- Remove "backup", "copy", "old", or "temp" files outside of `context/`.

### 3. **Consolidate and Modularize Code**
- **Break up large files**: When you see a large file, split it into smaller, logically cohesive modules (e.g., separate physics, plotting, color utils, state management, rendering helpers).
    - Favor more, smaller files over fewer, larger ones.
    - Each file should ideally encapsulate a single concept or utility.
- **Single Source of Truth**: Ensure each utility, algorithm, or visualization approach has only one up-to-date implementation.
- **Remove unused code**: Delete or refactor out all references to obsolete variables/APIs (e.g., `probHistory`).

### 4. **Tests**
- Remove or update tests to only cover the current, live code.
- Consolidate or modularize test files to match the new, smaller structure of the main codebase.

### 5. **Documentation and Configs**
- Update documentation (README, architecture, implementation, etc.) to match the cleaned and modularized structure.
- Remove or update stale screenshots, instructions, or references to deprecated tech.
- Ensure npm scripts and dependencies in `package.json` match the cleaned codebase.

### 6. **Project Structure**
- Group related files by feature or layer (e.g., `utils/`, `physics/`, `visualization/`, `state/`, etc.).
- Remove empty or obsolete folders.
- Make sure all imports and code references are updated after modularization.

### 7. **Performance and Maintainability**
- Profile and optimize where needed (especially the NuFast physics port and visualization loops if noted as bottlenecks).
- Refactor for clarity and maintainability as you modularize.

### 8. **Preservation**
- If any file must be kept for historical reasons, move it to a new `legacy/` or `archive/` folder (outside of `context/`).

---

## Final Deliverable

- A thoroughly cleaned, modularized codebase with only current, relevant, and non-redundant files.
- All source files split into small, manageable pieces suitable for use as context in AI prompts.
- Documentation and configuration updated to match the new structure.
- All tests updated and passing.
- Untouched `context/` folder.

---

## Reference Materials

- [README.md](./README.md)
- [ARCHITECTURE.md](./context/ARCHITECTURE.md)
- [STATUS.md](./STATUS.md)
- [IMPLEMENTATION.md](./context/IMPLEMENTATION.md)
- [package.json](./package.json)
- [Test files](./test/)

---

**Be aggressive, decisive, and favor a modular structure. The `context/` folder is off-limits.**

===

I have this vite project that animates and visualizes neutrino oscillations, go through the codebase to understand it

any context you may need may be found in the context folder, README.md, and STATUS.md

read all that is relevant to understand what is done and what needs to be done

here is your task:

the result looks ugly, could you use these as inspiration and make the design better (the UI as well as the plots and animations)

redesign/be creative/try different ideas and variations of style to create a good end product

analyze the inspirations as well as the current implementation, identify the issues and bottlenecks with performance, why is this happening? what is different between this and the inspirations? how can this be closer to the inspirations in terms of choices?

we will do major refactors/rehauls and even add/remove dependencies if needed, I don't care how we achieve this and with what packages, I want a good end result that achieves the goals I had for this project as an educational visualization tool

look at @/context/neutrino-oscillation.html @/context/backup.html

===

I have this vite project that animates and visualizes neutrino oscillations, go through the codebase to understand it

any context you may need may be found in the context folder, README.md, and STATUS.md

read all that is relevant to understand what is done and what needs to be done

===

I have this vite project that animates and visualizes neutrino oscillations, go through the codebase to understand it

any context you may need may be found in docs, README.md, and STATUS.md

===

I have this vite project that animates and visualizes neutrino oscillations, go through the codebase to understand it

any context you may need may be found in docs and the README

===

I have this vite project that animates and visualizes neutrino oscillations, go through the codebase to understand it

any context you may need may be found in docs , task.ts.txt (which contains a chat history stored as API calls), prompt.md , README.md

===

im running into an issue with p5.js in my vite project, could you configure everything correctly?

```
 npm run dev                                   

> imagining-the-neutrino@0.0.0 dev
> vite


  VITE v6.3.2  ready in 156 ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
  ➜  press h + enter to show help
7:45:46 pm [vite] Pre-transform error: Failed to resolve entry for package "p5". The package may have incorrect main/module/exports specified in its package.json: Missing "." specifier in "p5" package
  Plugin: vite:import-analysis
  File: C:/Development/imagining-the-neutrino/src/main.ts:9:15
  2  |  import Alpine from "alpinejs";
  3  |  import { setupAlpine } from "./alpine/setupAlpine";
  4  |  import p5 from "p5";
     |                  ^
  5  |  setupAlpine();
  6  |  window.Alpine.start();
7:45:47 pm [vite] Internal server error: Failed to resolve entry for package "p5". The package may have incorrect main/module/exports specified in its package.json: Missing "." specifier in "p5" package
  Plugin: vite:import-analysis
  File: C:/Development/imagining-the-neutrino/src/main.ts:9:15
  2  |  import Alpine from "alpinejs";
  3  |  import { setupAlpine } from "./alpine/setupAlpine";
  4  |  import p5 from "p5";
     |                  ^
  5  |  setupAlpine();
  6  |  window.Alpine.start();
      at packageEntryFailure (file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:16195:15)
      at resolvePackageEntry (file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:16190:5)
      at tryNodeResolve (file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:16057:18)
      at ResolveIdContext.resolveId (file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:15828:19)
      at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
      at async EnvironmentPluginContainer.resolveId (file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:42138:22)
      at async TransformPluginContext.resolve (file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:42346:15)
      at async normalizeUrl (file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:40389:26)
      at async file:///C:/Development/imagining-the-neutrino/node_modules/vite/dist/node/chunks/dep-DG3BLbPj.js:40520:37
      at async Promise.all (index 3)
```

there are some references you may look at to understand how to do this - @/context/p5-vite

===

I have this vite project that animates and visualizes neutrino oscillations, go through the codebase to understand it

any context you may need may be found in @/docs , @/task.ts.txt (which contains a chat history stored as API calls), @/prompt.md , @/README.md





