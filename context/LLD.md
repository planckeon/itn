# Low-Level Design: Imagining the Neutrino\\n\\n## 1. Introduction\\nThis document details the low-level design of the \\\"Imagining the Neutrino\\\" application, specifying module interactions, class structures, data formats, and key algorithms based on the final implementation.\\n\\n## 2. Module/Class Design\\n\\n### 2.1. \\`src/physics/\\`\\n*   **\\`constants.ts\\`:**\\n    *   Exports \\`readonly\\` objects/values for physical constants (G_F, N_A, conversion factors like \\`YERHO_E2A\\`, \\`EV_SQ_KM_TO_GEV_OVER4\\`).\\n    *   Exports \\`defaultOscParams\\` containing default oscillation parameters (NuFit 5.2 NO central values for angles, deltaCP, mass differences), default energy, matter settings, and initial flavor.\\n    *   Exports helper constants like \\`PI\\`, \\`flavorNames\\`, \\`flavorSymbols\\`, \\`flavorColorsRGB\\`.\\n*   **\\`types.ts\\`:**\\n    *   Defines core interfaces/types:\\n        *   \\`OscillationParameters\\`: Interface detailing all input parameters required by the physics engine (s12sq, s13sq, s23sq, deltaCP_rad, dm21sq, dm31sq, L, E, rho, Ye, matterEffect, N_Newton, initialFlavorIndex).\\n        *   \\`ProbabilityMatrix\\`: Type alias for the 3x3 probability matrix (\\`Readonly<[Readonly<[number, number, number]>, ...]>\\`).\\n        *   \\`ProbabilityVector\\`: Type alias for the 3-element probability vector (\\`Readonly<[number, number, number]>\\`).\\n        *   \\`PhysicsEngine\\`: Interface defining the contract for the physics calculation module.\\n*   **\\`NuFastPort.ts\\`:**\\n    *   \\`calculateNuFastProbs(params: Readonly<OscillationParameters>): ProbabilityMatrix\\`: Implements the core NuFast algorithm using standard TypeScript \\`Math\\` functions. Handles vacuum/matter, nu/anti-nu (via sign of E), NO/IO (via sign of dm31sq). Includes numerical stability checks and clamping.\\n    *   \\`getProbabilitiesForInitialFlavor(initialFlavorIndex: 0 | 1 | 2, params: Readonly<OscillationParameters>): ProbabilityVector\\`: Convenience function calling \\`calculateNuFastProbs\\` and extracting the relevant row.\\n\\n### 2.2. \\`src/state/\\`\\n*   **\\`uiState.ts\\`:**\\n    *   Uses \\`Alpine.store\\` to define reactive stores:\\n        *   \\`simParams\\`: Holds user-adjustable physics parameters (energy, flavor, matter settings, mixing params). Initialized from \\`defaultOscParams\\`.\\n        *   \\`animState\\`: Holds animation state (isPlaying, currentL, simSpeed).\\n        *   \\`plotParams\\`: Holds plot-specific settings (maxL).\\n        *   \\`tooltipState\\`: Holds visibility state for each tooltip.\\n    *   Exports TypeScript types for each store (e.g., \\`SimParamsStore\\`) for type safety.\\n\\n### 2.3. \\`src/alpine/\\`\\n*   **\\`setupAlpine.ts\\`:**\\n    *   Imports store definitions from \\`uiState.ts\\` to ensure registration.\\n    *   Defines and registers the custom \\`x-katex\\` directive for rendering LaTeX.\\n    *   Calls \\`Alpine.start()\\` to initialize the framework.\\n\\n### 2.4. \\`src/visualization/plot/\\`\\n*   **\\`ProbabilityPlot.ts\\`:**\\n    *   \\`class ProbabilityPlot { constructor(elementId: string, simParamsStore, animStateStore, plotParamsStore) }\\`\\n    *   \\`private initializePlot()\\`: Sets up the initial Plotly chart with dark theme layout, axes, legend, and placeholder traces.\\n    *   \\`public updatePlot()\\`: Reads current parameters from stores, generates L values, prepares the full \\`OscillationParameters\\` object, calls \\`getProbabilitiesForInitialFlavor\\` repeatedly, updates Plotly trace data (x, y, name) and layout (xaxis range), and calls \\`Plotly.react()\\`.\\n    *   \\`public updateMarker(currentL: number)\\`: Updates the vertical line shape on the plot using \\`Plotly.relayout()\\`.\\n    *   Handles initialization state to prevent updates before Plotly is ready.\\n\\n### 2.5. \\`src/visualization/scene3d/\\`\\n*   **\\`SceneManager.ts\\`:**\\n    *   \\`class SceneManager { constructor(canvas, simParamsStore, animStateStore, updateMarkerCb, updateProbsCb) }\\`\\n    *   Manages \\`THREE.Scene\\`, \\`THREE.PerspectiveCamera\\`, \\`THREE.WebGLRenderer\\`, lighting (ambient, point, directional).\\n    *   Initializes \\`NeutrinoSphere\\`, \\`Starfield\\`, \\`OrbitControls\\`.\\n    *   \\`private animate(timestamp: number)\\`: Core animation loop using \\`requestAnimationFrame\\`. Calculates delta time, updates \\`animState.currentL\\`, prepares full \\`OscillationParameters\\`, calls \\`getProbabilitiesForInitialFlavor\\`, calls \\`neutrinoSphere.setColor()\\`, calls \\`starfield.update()\\`, updates \\`OrbitControls\\`, calls UI/plot callbacks (\\`updateProbsCallback\\`, \\`updateMarkerCallback\\`), renders scene.\\n    *   \\`public play()\\`, \\`public pause()\\`, \\`public reset()\\`: Control animation loop and state via \\`requestAnimationFrame\\` and interaction with \\`animState\\`. Reset calculates initial state probabilities.\\n    *   \\`private onWindowResize()\\`: Handles resizing of the renderer and camera aspect ratio.\\n    *   \\`public dispose()\\`: Cleans up Three.js resources (geometry, materials, renderer, controls) and removes event listeners.\\n*   **\\`NeutrinoSphere.ts\\`:**\\n    *   \\`class NeutrinoSphere { public mesh: THREE.Mesh; private material: THREE.MeshPhongMaterial; ... }\\`\\n    *   Creates sphere geometry and Phong material.\\n    *   \\`public setColor(probs: ProbabilityVector)\\`: Takes probabilities, calculates blended color using \\`colorUtils.getColorFromProbs\\`, updates material color/emissive. Includes a \\`pulse\\` method based on probability entropy.\\n    *   \\`public dispose()\\`: Disposes geometry and material.\\n*   **\\`Starfield.ts\\`:**\\n    *   \\`class Starfield { public points: THREE.Points; private geometry: THREE.BufferGeometry; ... }\\`\\n    *   Creates star points using \\`BufferGeometry\\` and \\`PointsMaterial\\`.\\n    *   \\`public update(deltaTime: number, simSpeed: number)\\`: Updates star vertex positions based on simulated camera movement (opposite direction) and delta time. Handles wrapping of stars. Implements motion streak effect by adjusting point sizes based on speed.\\n    *   \\`public dispose()\\`: Disposes geometry and material.\\n*   **\\`types.ts\\`:** (Currently not strictly needed as interfaces are defined elsewhere or are simple callbacks).\\n\\n### 2.6. \\`src/utils/\\`\\n*   **\\`mathUtils.ts\\`:** \\`degToRad\\`, \\`mapRange\\`.\\n*   **\\`colorUtils.ts\\`:** \\`getColorFromProbs(probs: ProbabilityVector): THREE.Color\\`. Defines base flavor colors.\\n*   **\\`debounce.ts\\`:** Standard generic debounce function.\\n\\n### 2.7. \\`src/main.ts\\`\\n*   Imports CSS and \\`setupAlpine\\`.\\n*   Imports physics/utils needed globally by the Alpine component.\\n*   Sets up global references (e.g., \\`window.physicsEngine\\`) if needed.\\n*   Adds \\`DOMContentLoaded\\` listener to call \\`setupAlpine()\\`.\\n\\n### 2.8. \\`index.html\\`\\n*   Contains HTML structure, links CSS/JS.\\n*   Includes the inline \\`<script>\\` defining the \\`neutrinoVisualization\\` Alpine component function.\\n*   Uses \\`x-data=\\\"neutrinoVisualization()\\\"\\` on the main container.\\n*   Binds UI controls to Alpine stores using \\`x-model\\`, \\`@input\\`, \\`@change\\`, \\`@click\\`.\\n*   Displays reactive data using \\`x-text\\`.\\n*   Manages tooltip visibility using \\`x-show\\`, \\`@click\\`, \\`@click.outside\\`.\\n*   Includes tooltip content with \\`x-katex\\` attributes for LaTeX rendering.\\n\\n## 3. Key Algorithms\\n*   **Probability Calculation:** Direct port of NuFast\'s analytical approach using real arithmetic. See \\`NuFastPort.ts\\`.\\n*   **Color Blending:** Weighted average of base flavor RGB colors using probabilities \\[Pe, Pmu, Ptau] as weights. See \\`colorUtils.ts\\`.\\n*   **Animation Loop:** Time-based updates using \\`requestAnimationFrame\\` and delta time calculation. Updates simulation distance \\`currentL\\`, calculates probabilities, updates 3D visuals (color, star positions), updates plot marker, renders scene. See \\`SceneManager.ts\\`.\\n*   **Starfield Motion:** Update vertex positions opposite to the conceptual neutrino direction. Wrap stars when they go out of view. Implement streaking by adjusting point sizes based on speed. See \\`Starfield.ts\\`.\\n*   **KaTeX Rendering:** Custom Alpine directive finds elements with \\`x-katex\\` attribute within visible tooltips and calls \\`katex.render()\\`. See \\`setupAlpine.ts\\`.\\n\\n## 4. Data Structures\\n*   **\\`OscillationParameters\\` Interface:** Central structure holding all physics inputs.\\n*   **Alpine Stores (simParams, animState, plotParams, tooltipState):** Reactive objects holding UI-controlled parameters and application state.\\n*   **\\`ProbabilityMatrix\\` (Readonly<number[][]>):** 3x3 array returned by \\`calculateNuFastProbs\\`.\\n*   **\\`ProbabilityVector\\` (Readonly<[number, number, number]>):** Represents \\[Pe, Pmu, Ptau] for the current state.\\n\\n## 5. Error Handling\\n*   **Physics Engine:** Input validation (E=0, L<0, invalid angles). Checks for near-zero denominators in calculations. Clamps final probabilities to \\[0, 1].\\n*   **3D Rendering:** \\`try...catch\\` around Three.js initialization in \\`SceneManager\\`. Checks for null objects before use in animation loop.\\n*   **KaTeX Rendering:** \\`try...catch\\` within the \\`x-katex\\` directive to handle invalid LaTeX strings gracefully.\\n*   **UI:** Standard HTML5 input validation (min/max on number inputs). Alpine handles reactivity errors.\\n\\n## 6. Performance Considerations\\n*   **Plot Updates:** Debounced for continuous slider inputs using \\`debounce.ts\\`. \\`Plotly.react\\` used for efficient updates.\\n*   **Physics Calculation:** NuFast is inherently optimized. Calculations are done per-frame only when animation is playing.\\n*   **3D Rendering:** Star count (\`NUM_STARS\`) kept reasonable. \\`BufferGeometry\\` used for stars. \\`PointsMaterial\\` is efficient. Animation loop uses \\`requestAnimationFrame\\`.\\n*   **Alpine.js:** Lightweight framework minimizes overhead.
