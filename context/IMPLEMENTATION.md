# Implementation Details: Imagining the Neutrino\n\n## 1. Physics Engine (`NuFastPort.ts`)\n*   **Porting Strategy:** The C++ version of NuFast (specifically `NuFast.cpp` and `Exact_Cubic.cpp` for reference) was used as the primary guide. The logic was translated into TypeScript, aiming to preserve the structure and variable naming for easier comparison and validation against the original paper (arXiv:2405.02400).\n*   **Numerical Precision:** Standard TypeScript `number` (IEEE 754 double-precision) is used. Potential floating-point inaccuracies are mitigated by:\n    *   Following the formula arrangements from NuFast.\n    *   Adding checks for near-zero denominators (e.g., in eigenvalue calculations, `PiDlambdaInv`).\n    *   Checking for square roots of potentially small negative numbers and clamping the argument to zero.\n    *   Clamping final probabilities to the valid range [0, 1].\n    *   Performing row normalization as a final safeguard if the sum deviates significantly from 1.\n*   **Constants:** Physical constants (`YERHO_E2A`, `EV_SQ_KM_TO_GEV_OVER4`) are taken directly from the NuFast paper/codebase.\n*   **Matter Potential:** `Amatter` calculation incorporates the sign of the input energy `E` to correctly handle neutrinos (E>0) and antineutrinos (E<0).\n*   **Eigenvalue Calculation:** The DMP formula (Eq. 17) is used for the initial `lambda3` approximation. Newton-Raphson refinement (Eq. 18) is implemented but defaults to `N_Newton = 0` for performance, as suggested by NuFast for typical LBL scenarios. Edge case `Dmsqee â‰ˆ 0` uses a simplified fallback.\n*   **Probability Calculation:** The implementation uses the Rosetta formulas (Eq. 22) for effective mixing elements (`|V_ai|^2`) and the NHS identity (Eq. 24) for the matter Jarlskog invariant (`J_matter`). Final probabilities are constructed using these matter-effective quantities and unitarity relations, mirroring the structure of Eq. 10/11 and the NuFast C++ code.\n*   **`math.js` Avoidance:** The implementation successfully avoids the `math.js` dependency by performing all calculations using standard TypeScript `Math` functions and real arithmetic, as the final probability formulas derived from complex amplitudes are real-valued.\n\n## 2. 3D Visualization (`src/visualization/scene3d/`)\n*   **Scene Setup:** Standard Three.js setup (`PerspectiveCamera`, `WebGLRenderer`, `Scene`). `OrbitControls` are used for camera rotation around the origin (where the neutrino is placed), with panning disabled.\n*   **Neutrino (`NeutrinoSphere.ts`):** Represented by a `SphereGeometry` with `MeshPhongMaterial` for lighting effects. The `setColor` method uses `colorUtils.getColorFromProbs` to blend the base flavor colors (Blue, Orange, Magenta) based on the input probability vector. A pulsing effect is added, scaling the sphere size based on the entropy/mixing of the probabilities (more pulse when probabilities are mixed, less when one flavor dominates).\n*   **Starfield (`Starfield.ts`):** Uses `THREE.Points` with `BufferGeometry`. Star positions are updated each frame in the `update` method to simulate backward motion relative to the neutrino. A simple spherical wrapping mechanism resets stars that move too far. A motion streak effect is simulated by increasing the `PointsMaterial.size` based on the `simSpeed`.\n*   **Animation Loop (`SceneManager.ts`):** Uses `requestAnimationFrame`. Calculates `deltaTime` for frame-rate independence. Updates `animState.currentL` based on `simSpeed` and loops the distance based on `plotParams.maxL`. Calls the physics engine (`getProbabilitiesForInitialFlavor`) each frame. Updates `NeutrinoSphere` color. Updates `Starfield` positions. Calls UI/plot update callbacks.\n*   **Performance:** Star count is kept moderate (`NUM_STARS`). `BufferGeometry` is efficient. Animation logic is contained within the `requestAnimationFrame` loop.\n\n## 3. Plotting (`src/visualization/plot/ProbabilityPlot.ts`)\n*   **Plotly Integration:** Encapsulated within the `ProbabilityPlot` class.\n*   **Data Generation:** Generates an array of L values up to `plotParams.maxL`. Calls `getProbabilitiesForInitialFlavor` for each L value to get the data points for the three probability traces.\n*   **Updating:** Uses `Plotly.react` for efficient updates when parameters change. Layout options are configured for the dark theme specified.\n*   **Marker:** A vertical line shape is managed via `Plotly.relayout` to indicate the `animState.currentL` position.\n*   **Initialization:** Uses `Plotly.newPlot` and includes an `isInitialized` flag to prevent updates before the plot is ready.\n\n## 4. UI and State Management (`index.html`, `src/alpine/`, `src/state/`)\n*   **Alpine.js Stores (`uiState.ts`):** Centralized reactive state for `simParams`, `animState`, `plotParams`, `tooltipState`. Initialized with default values.\n*   **HTML Binding (`index.html`):** Uses standard Alpine directives (`x-data`, `x-model`, `x-text`, `x-show`, `@input`, `@change`, `@click`, `@click.outside`) to link UI elements directly to the stores.\n*   **Alpine Component (`neutrinoVisualization` function):** Defined globally via an inline `<script>` tag before `main.ts`. Handles initialization (`init`), orchestrates updates (`updateVisualization`, `requestPlotUpdate`), manages animation control (`playPause`, `reset`), handles preset logic (`setDensity`), and manages tooltip visibility (`toggleTooltip`, `hideTooltip`). It instantiates `ProbabilityPlot` and `SceneManager` and passes necessary callbacks.\n*   **KaTeX Integration (`setupAlpine.ts`):** A custom `x-katex` directive renders LaTeX strings found within elements (specifically tooltips) when they become visible.\n*   **Debouncing:** Slider inputs (`@input`) trigger a debounced plot update (`requestPlotUpdate`) via `utils/debounce.ts` to avoid excessive recalculations during dragging.\n\n## 5. Build Process and CI/CD\n*   **Vite:** Used for development server (with HMR) and production builds (`npm run build`). Configured in `vite.config.ts` with base path for GitHub Pages.\n*   **TypeScript:** Configured via `tsconfig.json` for strict type checking and modern ES module output.\n*   **GitHub Actions (`deploy.yml`):** Workflow automates checkout, Node setup, dependency installation (`npm ci`), testing (`npm test`), building (`npm run build`), and deployment to the `gh-pages` branch using standard actions (`actions/checkout`, `actions/setup-node`, `actions/upload-pages-artifact`, `actions/deploy-pages`).\n\n## 6. Challenges & Decisions\n*   **`math.js` Avoidance:** Successfully implemented NuFast using only standard `Math` functions, avoiding the extra dependency.\n*   **State Management:** Chose Alpine.js stores for simplicity and direct binding in HTML, suitable for this application's complexity. Passed store references or callbacks to visualization classes.\n*   **Visualization Integration:** Used callbacks (`updateMarkerCallback`, `updateProbsCallback`) passed to `SceneManager` to update the plot marker and UI overlay from the animation loop, decoupling the 3D scene from direct knowledge of Plotly or the specific overlay elements.\n*   **KaTeX Rendering:** Implemented via a custom Alpine directive triggered on tooltip visibility to ensure rendering happens only when needed.
