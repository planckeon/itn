Directory structure:
└── stillscripts-p5-starter/
    ├── README.md
    ├── index.html
    ├── package.json
    ├── tsconfig.json
    ├── vite.config.js
    ├── src/
    │   ├── main.ts
    │   ├── style.css
    │   ├── vite-env.d.ts
    │   ├── components/
    │   │   ├── Header.ts
    │   │   ├── index.ts
    │   │   ├── SketchContainer.ts
    │   │   └── SketchSelector.ts
    │   ├── sketches/
    │   │   ├── sketchMap.ts
    │   │   ├── types.d.ts
    │   │   ├── BouncyBubbles/
    │   │   │   ├── classes.ts
    │   │   │   └── sketch.ts
    │   │   ├── BubbleSort/
    │   │   │   ├── classes.ts
    │   │   │   └── sketch.ts
    │   │   ├── Clock/
    │   │   │   ├── classes.ts
    │   │   │   └── sketch.ts
    │   │   ├── Mandala/
    │   │   │   ├── configurations.ts
    │   │   │   ├── constants.ts
    │   │   │   ├── draw.ts
    │   │   │   ├── interfaces.ts
    │   │   │   ├── setup.ts
    │   │   │   ├── sketch.ts
    │   │   │   ├── classes/
    │   │   │   │   ├── Config.ts
    │   │   │   │   ├── Mandala.ts
    │   │   │   │   ├── PhysicalShape.ts
    │   │   │   │   └── Shape.ts
    │   │   │   └── Mandala/
    │   │   │       ├── functions.ts
    │   │   │       └── mandalaFunctions.ts
    │   │   ├── ParticleSystem/
    │   │   │   ├── classes.ts
    │   │   │   └── sketch.ts
    │   │   └── Shapes/
    │   │       ├── classes.ts
    │   │       └── sketch.ts
    │   └── utils/
    │       ├── common.ts
    │       └── urlParams.ts
    └── test/
        ├── common.test.ts
        └── urlParams.test.ts

================================================
FILE: README.md
================================================
# P5.js Starter

The easiest way for developers to create complex animations and design images in the browser using the p5.js library. [**View live demo**](https://p5-starter-vite.netlify.app/)

This starter repo comes equipped with [**p5.js**](https://p5js.org/), [**Vite**](https://vitejs.dev/), and [**TypeScript**](https://www.typescriptlang.org/), to enable a great developer experience. Additionally, **4 example sketches** have been included to provide samples of what can be done and help with learning how p5.js works. 

## Getting Started

#### Clone the repo: 

```bash
git clone https://github.com/StillScripts/p5-starter.git
```

#### Install the dependencies:
```bash
npm install
# or 
yarn install
```

#### Run the development server:
```bash
npm run dev
# or
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.


## Example Sketches

In the `src/sketches` folder you will find four example sketches.
- **Shapes**: A simple demo of creating an array of shapes and applying rotation to move them around the canvas. Based on [this](https://p5js.org/examples/form-regular-polygon.html).
- **Clock**: An animation of an analog clock that ticks each second. Based on [this](https://p5js.org/examples/input-clock.html).
- **Bubble Sort**: An illustration of the bubble sort algorithm. Based on [this](https://p5js.org/examples)
- **Particle System**: A simulation of moving particles spawning and fading. Based on [this](https://p5js.org/examples/simulate-particle-system.html).
- **Bouncy Bubbles**: A simulation of a group of bubbles moving around and bouncing into each other until gravity brings them to the ground. Based on [this](https://p5js.org/examples/motion-bouncy-bubbles.html).


You can easily create new sketches by creating a new sketch in the `src/sketches` folder and adding it to the sketchMap object in `src/sketches/sketchMap.ts`. 

It may be helpful to use an `index.ts` file containing the function for the sketch and a `classes.ts` file containing classes used in the sketch, as I have done in the example sketches, but feel free to create sketches in any way that suits you.

The project has also been set up to enable using a simple select input for navigating between all of the sketches in the sketchMap object. A URL parameter of *sketch* is used to let the app know which sketch to render. For example: *?sketch=shapes* will render the Shapes sketch.

## Components
This project uses vanilla TypeScript so that you can use p5.js as it was intended (*without a JavaScript framework complicating DOM interactions*). 

To ensure that the project still uses a component structure similar to JavaScript frameworks, the page has been organised into three components: 
- **Header**: This contains the main heading on the page and the links to documentation. It is located at `src/components/Header/Header.ts`.
- **SketchContainer**: This contains the div element where the p5.js sketch will be placed. It is located at `src/components/SketchContainer/SketchContainer.ts`.
- **SketchSelector**: To enable you to easily navigate between the sketches you are building, or publish a website where all your sketches can be explored, a select input is used. It shows an option for each key in the sketchMap. It is located at `src/components/SketchSelector/SketchSelector.ts`.

## Pull Requests
This project is accepting pull requests. Feel free to add additional example sketches or fix any issues you see. Let's work together to enable frontend developers to turn their code into art by offering the best place to get started with p5.js! :grinning: 

## Live Demo
View a live demo of this project [here](https://p5-starter-vite.netlify.app/) 



================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P5.js Animations</title>
    <meta name="description" content="A perfect starter for building all kids of animations in the browser using p5.js" />
    <meta name="keywords" content="P5.js, Starter, TypeScript, Vite" />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: package.json
================================================
{
  "name": "p5-starter",
  "author": {
    "name": "Daniel Still",
    "url": "https://github.com/StillScripts/p5-starter"
  },
  "private": true,
  "version": "0.0.1",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run"
  },
  "devDependencies": {
    "@types/p5": "^1.4.3",
    "@vitest/ui": "^0.26.2",
    "typescript": "^4.9.4",
    "vite": "^4.0.3",
    "vitest": "^0.26.2"
  },
  "dependencies": {
    "p5": "^1.5.0"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ESNext", "DOM"],
    "moduleResolution": "Node",
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "noEmit": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}



================================================
FILE: vite.config.js
================================================
import { defineConfig } from "vite";

export default defineConfig({
  build: {
    chunkSizeWarningLimit: 1200,
  },
});



================================================
FILE: src/main.ts
================================================
import "./style.css";
import { type SketchKey, sketchMap } from "./sketches/sketchMap";
import { Header, SketchSelector, SketchContainer } from "./components";
import { addListenerToSelect } from "./components/SketchSelector";
import { renderSketch } from "./components/SketchContainer";
import { getSketchFromParams } from "./utils/urlParams";
import { getKeys } from "./utils/common";

/**
 * Initialise the application by getting the sketch from the url parameter,
 * adding the HTML components to the #app div, adding an event listener to the
 * select input, and rendering the p5 sketch within the newly created #sketch div
 */
function init() {
  const CONTAINER_ID = "sketch-container";
  const SELECT_ID = "animation-selector";

  const sketch: SketchKey = getSketchFromParams(getKeys(sketchMap)[0]); // get the sketch to render
  const app = document.querySelector<HTMLDivElement>("#app")!; // get the app container <div> element

  // Update the innerHTML of the app container to contain the header, select input, and the sketch.
  app.innerHTML = `
    ${Header(sketch, true)}
    <main>
      ${SketchSelector(SELECT_ID, getKeys(sketchMap), sketch)}
      ${SketchContainer(CONTAINER_ID)}
    </main>
  `;

  addListenerToSelect(SELECT_ID, sketch);

  renderSketch(CONTAINER_ID, sketch);
}

init();



================================================
FILE: src/style.css
================================================
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}

header {
  margin-top: 2rem;
}

main {
  margin: 1rem auto;
}

select {
  margin: 1rem;
  padding: 0.5rem;
  border-radius: 6px;
}

a {
  color: inherit;
  text-decoration: none;
}

a:hover {
  text-decoration:underline;
}

.link {
  margin: 8px;
  color: rgb(61, 61, 214);
}



================================================
FILE: src/vite-env.d.ts
================================================
/// <reference types="vite/client" />



================================================
FILE: src/components/Header.ts
================================================
import { spaceWords } from "../utils/common";

/**
 * The header for the page which displays the information about the app
 * @param {string} sketch - The name of the sketch
 * @param {boolean} showLinks - Show links for p5.js documentation, and the GitHub repo for this project
 * @returns {string} - The string for the HTML header element
 */
export default function Header(sketch: string, showLinks?: boolean): string {
  return `
	<header>
    <h1>${spaceWords(sketch)} Sketch</h1>
    ${
      showLinks
        ? `<a class="link" href="https://p5js.org/" target="_blank">P5.js Docs</a>
		       <a class="link" href="https://github.com/StillScripts/p5-starter" target="_blank">View on GitHub</a>`
        : ""
    }
  </header>`;
}



================================================
FILE: src/components/index.ts
================================================
export { default as Header } from "./Header";
export { default as SketchSelector } from "./SketchSelector";
export { default as SketchContainer } from "./SketchContainer";



================================================
FILE: src/components/SketchContainer.ts
================================================
import p5 from "p5"; // Import of the p5 object that is used for all sketches
import { type SketchKey, sketchMap } from "../sketches/sketchMap";

/**
 * The container that the sketch will live in.
 * @param {string} id - The id for the sketch container element
 * @returns {string} - The string for the HTML div element
 */
export default function SketchContainer(id: string): string {
  return `<div id="${id}"><p id="loader">initialising app...</p></div>`;
}

/**
 * Add an event listener to the select input to the reload the page
 * with a new url param when the user selects a new sketch
 * @param {string} id - The id for the sketch container element
 * @param currentSketch - The current sketch value of the page
 */
export function renderSketch(id: string, currentSketch: SketchKey) {
  try {
    // Get the sketch container
    const container = document.querySelector<HTMLDivElement>("#" + id);
    // Remove existing animation
    container?.removeChild(container.childNodes[0]);
    // Make a div for the sketch
    const sketchDiv = document.createElement("div");
    // Give the div an id
    sketchDiv.id = "sketch";
    // Add this div to the sketch container
    container?.appendChild(sketchDiv);

    // Initialise the p5.js object which contains the sketch
    new p5(sketchMap[currentSketch], sketchDiv);
  } catch (error) {
    console.error("Error rendering p5.js sketch - " + error);
  }
}



================================================
FILE: src/components/SketchSelector.ts
================================================
import type { SketchKey } from "../sketches/sketchMap";
import { spaceWords } from "../utils/common";
import { convertToParam, redirectUrl } from "../utils/urlParams";

/**
 * A select input that is used to change the existing animation.
 * @param {string} id - The id for the select element
 * @param {string[]} options - The list of animations that are available
 * @param {string} sketch - The intial sketch value on page load
 * @returns {string} - The string for the HTML select element
 */
export default function SketchSelector(
  id: string,
  options: string[],
  sketch: SketchKey
): string {
  return `
	<select id="${id}">
		${options.map(
      (option) =>
        `<option value=${option} ${option === sketch && "selected"}>
          ${spaceWords(option)}
         </option>`
    )}
  </select>`;
}

/**
 * Add an event listener to the select input to the reload the page
 * with a new url param when the user selects a new sketch
 * @param {string} id - The id for the select element
 * @param currentSketch - The current sketch value of the page
 */
export function addListenerToSelect(id: string, currentSketch: SketchKey) {
  try {
    // Add an event listener to the select element
    document.querySelector("#" + id)?.addEventListener("change", (e) => {
      const select = e.target as HTMLSelectElement;
      const value = select.value as SketchKey;
      if (value !== currentSketch) {
        // Change the sketch if a new sketch option has been selected
        redirectUrl(window.location.href.split("?")[0], {
          sketch: convertToParam(value),
        });
      }
    });
  } catch (error) {
    console.error(
      "Error with adding event listener to select input - " + error
    );
  }
}



================================================
FILE: src/sketches/sketchMap.ts
================================================
import bouncyBubbleSketch from './BouncyBubbles/sketch'
import bubbleSortSketch from './BubbleSort/sketch'
import clockSketch from './Clock/sketch'
import particleSystemSketch from './ParticleSystem/sketch'
import shapesSketch from './Shapes/sketch'
import mandalaSketch from './Mandala/sketch'

export const sketchMap = {
  Shapes: shapesSketch,
  Clock: clockSketch,
  BubbleSort: bubbleSortSketch,
  ParticleSystem: particleSystemSketch,
  BouncyBubbles: bouncyBubbleSketch,
  Mandala: mandalaSketch
} as const

export type SketchKey = keyof typeof sketchMap



================================================
FILE: src/sketches/types.d.ts
================================================
export interface Coordinate {
  x: number;
  y: number;
}

export type ShapeType = "circle" | "ellipse" | "polygon";


================================================
FILE: src/sketches/BouncyBubbles/classes.ts
================================================
import type p5 from "p5";
import { Coordinate } from "../types";

/**
 * A bubble that moves around the screen bouncing into other bubbles
 */
export class Bubble {
  location: Coordinate;
  xVelocity: number;
  yVelocity: number;
  diameter: number;
  id: number;
  others: Bubble[];
  constructor(
    xSpawn: number,
    ySpawn: number,
    diameter: number,
    id: number,
    others: Bubble[]
  ) {
    this.location = { x: xSpawn, y: ySpawn };
    this.xVelocity = 0;
    this.yVelocity = 0;
    this.diameter = diameter;
    this.id = id;
    this.others = others;
  }

  /**
   * Apply collision detection to bubbles
   * @param {p5} p - The p5.js object
   * @param {number} numBubbles - The amount of bubbles in the system
   * @param {number} spring - The bounce acceleration when bubbles collide
   */
  collide(p: p5, numBubbles: number, spring: number) {
    for (let i = this.id + 1; i < numBubbles; i++) {
      let dx = this.others[i].location.x - this.location.x;
      let dy = this.others[i].location.y - this.location.y;
      let distance = p.sqrt(dx * dx + dy * dy);
      let minDist = this.others[i].diameter / 2 + this.diameter / 2;
      if (distance < minDist) {
        let angle = p.atan2(dy, dx);
        let targetX = this.location.x + p.cos(angle) * minDist;
        let targetY = this.location.y + p.sin(angle) * minDist;
        let ax = (targetX - this.others[i].location.x) * spring;
        let ay = (targetY - this.others[i].location.y) * spring;
        this.xVelocity -= ax;
        this.yVelocity -= ay;
        this.others[i].xVelocity += ax;
        this.others[i].yVelocity += ay;
      }
    }
  }

  /**
   * Move the bubble around 
   * @param {p5} p - The p5.js object
   * @param {number} gravity - The amount of gravitational force to apply
   * @param {number} friction - The rate at which bubbles slow down
   */
  move(p: p5, gravity: number, friction: number) {
    this.yVelocity += gravity;
    this.location.x += this.xVelocity;
    this.location.y += this.yVelocity;
    if (this.location.x + this.diameter / 2 > p.width) {
      this.location.x = p.width - this.diameter / 2;
      this.xVelocity *= friction;
    } else if (this.location.x - this.diameter / 2 < 0) {
      this.location.x = this.diameter / 2;
      this.xVelocity *= friction;
    }
    if (this.location.y + this.diameter / 2 > p.height) {
      this.location.y = p.height - this.diameter / 2;
      this.yVelocity *= friction;
    } else if (this.location.y - this.diameter / 2 < 0) {
      this.location.y = this.diameter / 2;
      this.yVelocity *= friction;
    }
  }

  /**
   * Render the bubble on the canvas
   * @param {p5} p - The p5.js object
   */
  display(p: p5) {
    p.circle(this.location.x, this.location.y, this.diameter);
  }
}

export class BubbleSystem {
  spring: number;
  gravity: number;
  friction: number;
  bubbles: Bubble[];
  constructor(
    p: p5,
    numBubbles: number,
    spring: number,
    gravity: number,
    friction: number
  ) {
    this.spring = spring;
    this.gravity = gravity;
    this.friction = friction;
    this.bubbles = this.generateBubbles(p, numBubbles);
  }

  /**
   * Move each bubble around the canvas
   * @param {p5} p - The p5.js object
   */
  run(p: p5) {
    this.bubbles.forEach((bubble) => {
      bubble.collide(p, this.bubbles.length, this.spring);
      bubble.move(p, this.gravity, this.friction);
      bubble.display(p);
    });
  }

  /**
   * Create all the bubbles in the system based on a set number of bubbles
   * @param {p5} p - The p5.js object
   * @param {number} numBubbles - The number of bubble to add to the system
   * @returns {Bubble[]}
   */
  generateBubbles(p: p5, numBubbles: number): Bubble[] {
    const newBubbles: Bubble[] = [];
    for (let i = 0; i < numBubbles; i++) {
      newBubbles[i] = new Bubble(
        p.random(p.width),
        p.random(p.height),
        p.random(30, 70),
        i,
        newBubbles
      );
    }
    return newBubbles;
  }
}



================================================
FILE: src/sketches/BouncyBubbles/sketch.ts
================================================
import type p5 from "p5";
import { BubbleSystem } from "./classes";

/**
 * This sketch is an animation of bubbles moving around and colliding with each other.
 * It uses a global BubbleSystem object to store and move particles around.
 * It calls setup once to make a 400 x 400 canvas and initialise the BubbleSystem.
 * It calls the draw method continuously to run the animation.
 * @param {p5} p - The p5.js object
 */
export default function bouncyBubbleSketch(p: p5) {
  let bubbleSystem: BubbleSystem;

  p.setup = () => {
    p.createCanvas(400, 400);
    bubbleSystem = new BubbleSystem(p, 13, 0.05, 0.03, -0.9);
    p.noStroke();
    p.fill(255, 204);
  };

  p.draw = () => {
    p.background(0);
    bubbleSystem.run(p);
  };
}



================================================
FILE: src/sketches/BubbleSort/classes.ts
================================================
import type p5 from "p5";

/**
 * A class which uses the bubble sorting algorithm and displays
 * each iterate using p5.js
 */
export class BubbleSort {
  values: number[];
  i: number;
  j: number;
  constructor(p: p5) {
    this.values = this.generateValues(p);
    this.i = 0;
    this.j = 0;
  }

  /**
   * Randomly create values for an unsorted list
   * @param {p5} p - The p5.js object 
   * @returns {number[]}
   */
  generateValues(p: p5): number[] {
    const startValues: number[] = [];
    for (let i = 0; i < p.width / 8; i++) {
      startValues.push(p.random(p.height));
    }
    return startValues;
  }

  /**
   * Apply an iteration using the bubble sort algorithm
   * @param {p5} p - The p5.js object 
   */
  sort(p: p5) {
    for (let k = 0; k < 8; k++) {
      if (this.i < this.values.length) {
        let temp = this.values[this.j];
        if (this.values[this.j] > this.values[this.j + 1]) {
          this.values[this.j] = this.values[this.j + 1];
          this.values[this.j + 1] = temp;
        }
        this.j++;

        if (this.j >= this.values.length - this.i - 1) {
          this.j = 0;
          this.i++;
        }
      } else {
        p.noLoop();
      }
    }
  }

  /**
   * Show the values as a simple bar chart
   * @param {p5} p - The p5.js object 
   */
  display(p: p5) {
    for (let i = 0; i < this.values.length; i++) {
      p.stroke(100, 143, 143);
      p.fill(180);
      p.rect(i * 8, p.height, 8, -this.values[i], 20);
    }
  }
}



================================================
FILE: src/sketches/BubbleSort/sketch.ts
================================================
import type p5 from "p5";
import { BubbleSort } from "./classes";

/**
 * This sketch displays the bubble sort algorithm.
 * It uses a global BubbleSort object to store and move particles around.
 * It calls setup once to make a 400 x 400 canvas and initialise the BubbleSort.
 * It calls the draw method continuously to run the animation.
 * @param {p5} p - The p5.js object
 */
export default function bubbleSortSketch(p: p5) {
  let bubbleSort: BubbleSort;

  p.setup = () => {
    p.createCanvas(400, 400);
		p.frameRate(12);
    bubbleSort = new BubbleSort(p);
  };

  p.draw = () => {
    p.background(0);
    bubbleSort.sort(p);
    bubbleSort.display(p);
  };
}



================================================
FILE: src/sketches/Clock/classes.ts
================================================
import type p5 from "p5";

/**
 * A class which renders a ticking clock
 */
export class Clock {
  radius: number;
  secondsRadius: number;
  minutesRadius: number;
  hoursRadius: number;
  diameter: number;
  constructor(radius: number) {
    this.radius = radius;
    this.secondsRadius = radius * 0.71;
    this.minutesRadius = radius * 0.6;
    this.hoursRadius = radius * 0.45;
    this.diameter = radius * 1.7;
  }

  /**
   * 
   * @param {p5} p - The p5.js object 
   * @param {number} cx - The x coordinate of the middle point 
   * @param {number} cy - The y coordinate of the middle point
   */
  tick(p: p5, cx: number, cy: number) {
    // Draw the clock background
    p.noStroke();
    p.fill(244, 122, 158);
    p.ellipse(cx, cy, this.diameter + 25, this.diameter + 25);
    p.fill(237, 34, 93);
    p.ellipse(cx, cy, this.diameter, this.diameter);

    // Angles for sin() and cos() start at 3 o'clock;
    // subtract HALF_PI to make them start at the top
    let s = p.map(p.second(), 0, 60, 0, p.TWO_PI) - p.HALF_PI;
    let m =
      p.map(p.minute() + p.norm(p.second(), 0, 60), 0, 60, 0, p.TWO_PI) -
      p.HALF_PI;
    let h =
      p.map(p.hour() + p.norm(p.minute(), 0, 60), 0, 24, 0, p.TWO_PI * 2) -
      p.HALF_PI;

    p.stroke(255);
    // Draw seconds hand
    p.strokeWeight(2);
    p.line(
      cx,
      cy,
      cx + p.cos(s) * this.secondsRadius,
      cy + p.sin(s) * this.secondsRadius
    );
    // Draw minutes hand
    p.strokeWeight(3);
    p.line(
      cx,
      cy,
      cx + p.cos(m) * this.minutesRadius,
      cy + p.sin(m) * this.minutesRadius
    );
    // Draw hours hand
    p.strokeWeight(4);
    p.line(
      cx,
      cy,
      cx + p.cos(h) * this.hoursRadius,
      cy + p.sin(h) * this.hoursRadius
    );

    // Draw the minute ticks
    p.strokeWeight(3);
    p.beginShape(p.POINTS);
    for (let a = 0; a < 360; a += 6) {
      let angle = p.radians(a);
      let x = cx + p.cos(angle) * this.secondsRadius;
      let y = cy + p.sin(angle) * this.secondsRadius;
      p.vertex(x, y);
    }
    p.endShape();
  }
}



================================================
FILE: src/sketches/Clock/sketch.ts
================================================
import type p5 from "p5";
import { Clock } from "./classes";

/**
 * This sketch is creates a clock with an hour, minute and seconds hand.
 * @param {p5} p - The p5.js object
 */
export default function clockSketch(p: p5) {
  let clock: Clock;

  p.setup = () => {
    p.createCanvas(400, 400);
    p.stroke(255);
    clock = new Clock(p.min(p.width, p.height) / 2);
  };

  p.draw = () => {
    p.background(10);
    clock.tick(p, p.width / 2, p.height / 2);
    p.push();
    p.circle(p.width / 2, p.height / 2, 8);
    p.pop();
  };
}



================================================
FILE: src/sketches/Mandala/configurations.ts
================================================
import {
  ColorConfig,
  PatternConfig,
  ShapeDesign,
  _PhysicalFeatures
} from './classes/Config'
import { Mandala } from './classes/Mandala'
import {
  BLACK,
  FOREST_COLORS,
  OCEAN_COLORS,
  SECRET_COLORS,
  SUNSET_COLORS,
  TRANSPARENT
} from './constants'

// Secret Pattern
const secretFeaturesInner: _PhysicalFeatures = {
  colorConfig: new ColorConfig(BLACK, SECRET_COLORS, 'layers', '#000', true),
  shapeDesign: new ShapeDesign(false, true, false, 'normal')
}
const secretFeaturesOuter: _PhysicalFeatures = {
  colorConfig: new ColorConfig(BLACK, SECRET_COLORS, 'layers', '#000', true),
  shapeDesign: new ShapeDesign(false, false, false, 'flipped')
}
export const secretPattern = new PatternConfig(
  secretFeaturesInner,
  secretFeaturesOuter,
  [4000, 4000],
  1400,
  new Mandala(3600, 55, 55, 'triangle')
)

// Daniel Pattern
const danielFeaturesInner: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    OCEAN_COLORS,
    OCEAN_COLORS,
    'spiral',
    '#003A69',
    true,
    false,
    1
  ),
  shapeDesign: new ShapeDesign(true, false, true, 'none')
}
const danielFeaturesOuter: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    OCEAN_COLORS,
    OCEAN_COLORS,
    'layers',
    '#003A69',
    true,
    false,
    1
  ),
  shapeDesign: new ShapeDesign(false, false, true, 'normal')
}
export const danielPattern = new PatternConfig(
  danielFeaturesInner,
  danielFeaturesOuter,
  [4000, 4000],
  1200,
  new Mandala(3200, 48, 48, 'square')
)
export const danielSmallPattern = new PatternConfig(
  danielFeaturesInner,
  danielFeaturesOuter,
  [2000, 2000],
  800,
  new Mandala(1600, 24, 24, 'square'),
  true
)

// Kelli pattern
const kelliShapeInner = new ShapeDesign(false, false, false, 'none')
const kelliColorsInner = new ColorConfig(
  SUNSET_COLORS,
  TRANSPARENT,
  'spiral',
  '#511F30',
  true,
  false,
  0
)
const kelliFeaturesInner: _PhysicalFeatures = {
  colorConfig: kelliColorsInner,
  shapeDesign: kelliShapeInner
}
const kelliShapeOuter = new ShapeDesign(false, false, false, 'normal')
const kelliColorsOuter = new ColorConfig(
  SUNSET_COLORS,
  SUNSET_COLORS,
  'layers',
  '#511F30',
  true,
  false,
  1
)
const kelliFeaturesOuter: _PhysicalFeatures = {
  colorConfig: kelliColorsOuter,
  shapeDesign: kelliShapeOuter
}
export const kelliPattern = new PatternConfig(
  kelliFeaturesInner,
  kelliFeaturesOuter,
  [4000, 4000],
  1500,
  new Mandala(3200, 48, 36, 'triangle-flipped')
)

// Kelli animation pattern
const kelliAnimationShapeInner = new ShapeDesign(false, false, false, 'normal')
const kelliAnimationColorsInner = new ColorConfig(
  SUNSET_COLORS,
  TRANSPARENT,
  'spiral',
  '#511F30',
  true,
  false,
  3
)
const kelliAnimationFeaturesInner: _PhysicalFeatures = {
  colorConfig: kelliAnimationColorsInner,
  shapeDesign: kelliAnimationShapeInner
}
const kelliAnimationShapeOuter = new ShapeDesign(false, false, false, 'flipped')
const kelliAnimationColorsOuter = new ColorConfig(
  TRANSPARENT,
  SUNSET_COLORS,
  'layers',
  '#511F30',
  false,
  false
)
const kelliAnimationFeaturesOuter: _PhysicalFeatures = {
  colorConfig: kelliAnimationColorsOuter,
  shapeDesign: kelliAnimationShapeOuter
}
export const kelliAnimationPattern = new PatternConfig(
  kelliAnimationFeaturesInner,
  kelliAnimationFeaturesOuter,
  [1920, 1920],
  10,
  new Mandala(1000, 10, 12, 'triangle-flipped'),
  false
)

// Ocean Spiral Pattern
const oceanSwirl: _PhysicalFeatures = {
  colorConfig: new ColorConfig(OCEAN_COLORS, OCEAN_COLORS, 'spiral', '#003A69'),
  shapeDesign: new ShapeDesign(true, false, true, 'none')
}
const oceanWave: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    TRANSPARENT,
    OCEAN_COLORS,
    'layers',
    '#003A69',
    true,
    false
  ),
  shapeDesign: new ShapeDesign(false, false, false, 'normal')
}
export const oceanPattern = new PatternConfig(
  oceanSwirl,
  oceanWave,
  [4000, 4000],
  1200,
  new Mandala(3800, 36, 36, 'triangle-flipped')
)

// Ocean Print
const oceanPrintInner: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    OCEAN_COLORS,
    TRANSPARENT,
    'spiral',
    '#003A69',
    true,
    false,
    1
  ),
  shapeDesign: new ShapeDesign(true, false, true, 'none')
}
const oceanPrintOuter: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    OCEAN_COLORS,
    OCEAN_COLORS,
    'layers',
    '#003A69',
    true,
    false,
    1
  ),
  shapeDesign: new ShapeDesign(false, false, true, 'normal')
}
export const oceanPrintPattern = new PatternConfig(
  oceanPrintInner,
  oceanPrintOuter,
  [4000, 4000],
  1200,
  new Mandala(3200, 48, 48, 'square')
)

// Pentagon design (Ocean)
const oceanPentInner: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    TRANSPARENT,
    OCEAN_COLORS,
    'layers',
    '#003A69',
    true,
    false,
    1
  ),
  shapeDesign: new ShapeDesign(false, false, false, 'normal')
}
const oceanPentOuter: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    OCEAN_COLORS,
    BLACK,
    'layers',
    '#003A69',
    true,
    false
  ),
  shapeDesign: new ShapeDesign(false, false, true, 'flipped')
}
export const oceanPentPattern = new PatternConfig(
  oceanPentInner,
  oceanPentOuter,
  [4000, 4000],
  1000,
  new Mandala(4800, 10, 10, 'pent')
)

// Caitie Forest Pattern
const forestPrintInner: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    FOREST_COLORS,
    FOREST_COLORS,
    'spiral',
    '#0A260D',
    true
  ),
  shapeDesign: new ShapeDesign(false, true, false, 'none')
}
const forestPrintOuter: _PhysicalFeatures = {
  colorConfig: new ColorConfig(
    FOREST_COLORS,
    FOREST_COLORS,
    'layers',
    '#0A260D',
    true,
    false,
    1
  ),
  shapeDesign: new ShapeDesign(false, false, false, 'normal')
}
export const forestPrintPattern = new PatternConfig(
  forestPrintInner,
  forestPrintOuter,
  [4000, 4000],
  1200,
  new Mandala(3200, 48, 48, 'triangle')
)



================================================
FILE: src/sketches/Mandala/constants.ts
================================================
export const PHI = 1.618
export const ROOT2 = 1.414
export const ROOT3 = 1.732
export const ROOT6 = 2.449
export const MINIMUM_RADIUS = 10

export const BLACK = ['#000']
export const WHITE = ['#fff']
export const TRANSPARENT = ['rgba(0,0,0,0)']
export const RYB = ['#D33B2A', '#4195C4', '#EECA2B']
export const RYGB = ['#E94235', '#FABB05', '#34A853', '#4285F4']

export const DISNEY = ['#fff', '#B6D0E5', '#8DA7D0']

export const DISNEY_BG = [
  'rgba(255,255,255,0.8)',
  'rgba(255,255,255,0.4)',
  'rgba(255,255,255,0.15)'
]

export const SECRET_COLORS = [
  '#D33B2A',
  '#EB7534',
  '#EECA2B',
  '#E7C6A3',
  '#4195C4'
]

export const SUNSET_COLORS = [
  // Sunset - https://l.facebook.com/l.php?u=https%3A%2F%2Fimages.immediate.co.uk%2Fproduction%2Fvolatile%2Fsites%2F4%2F2013%2F04%2FGettyImages-640318118-c83a508.jpg%3Fquality%3D90%26resize%3D768%252C574%26fbclid%3DIwAR2WVvqEVQn8I63OFuSFYoLn9U4RRvvETbIQrTGs39SYlxuG9MhwjGYrSWM&h=AT0gKQ3MTEnXDCNrFEVcGEMgxqfnPqZgZFDNQ0grZvXBJYYnKZzK_6bBIA8Re4IkpClCmFWCPNpXGU6KjbHoqAIcPc8ip1pLQZlRPELL3dIKbnt7-M7UPnht4GJHPrpVr6ujx6AWvY1e6AtNPxamLQ
  '#FECA7B',
  '#FEA533',
  '#EF7F7D',
  '#FEA533'
] // #511F30

export const OCEAN_COLORS = [
  // Tahiti clean - https://www.surfline.com/cdn-cgi/image/q=85,f=auto,fit=contain/https://d14fqx6aetz9ka.cloudfront.net/wp-content/uploads/2021/08/09111347/MF-1-8.jpg
  '#EFF4FB',
  '#7ABDED',
  '#1A7EBF' // "#064C96",
] // #003A69

export const OCEAN_COLORS_2 = [
  // Tahiti barrel - https://www.tahiti.com/images1/gallery/Teahupoo-Tour7-2000x1200_76216.jpg
  '#E0ECF7',
  '#76B2DC',
  '#007DAA' // "#FAFAF8", "#76C8A0", "#316A66"
] // #2D3738 or #0A4963

export const FOREST_COLORS = [
  '#EEF9FB'
  //"#8DD52F",
  //"#328631",
  //"#1B4F14",
] // #091F01 or #113802 or #0A260D



================================================
FILE: src/sketches/Mandala/draw.ts
================================================
import p5 from 'p5'
import { generateColor } from './Mandala/functions'
import {
  ColorConfig,
  _PatternConfig,
  _PhysicalFeatures
} from './classes/Config'
import { PhysicalShape } from './classes/PhysicalShape'

export type ShiftOption = 'expand' | 'contract'

/**
 * Method to handle how colors are rendered
 * @param {p5} p
 * @param {PhysicalShape} shape
 */
const handleColors = (
  p: p5,
  shape: PhysicalShape,
  colorConfig: ColorConfig
) => {
  const { incrementalLayer, layer } = shape
  const {
    bgColorScheme,
    strokeColorScheme,
    isRandom,
    direction = 'expanding',
    innerColorChange
  } = colorConfig
  const colorLayer = innerColorChange ? incrementalLayer : layer
  p.fill(
    p.color(generateColor(bgColorScheme, !!isRandom, direction, colorLayer))
  )
  p.stroke(
    p.color(generateColor(strokeColorScheme, !!isRandom, direction, colorLayer))
  )
}

/**
 * Method to render a regular shape or a star
 * @param {p5} p - The p5.js object
 * @param {Shape} shape - The shape object
 * @param {_PhysicalFeatures} pattern - The config used across the pattern
 * @returns {void}
 */
export const renderShape = (
  p: p5,
  shape: PhysicalShape,
  pattern: _PhysicalFeatures
): void => {
  const { isRound } = shape.shapeDesign
  let radius = shape.diameter / 2.0 // Radius of shape
  if (isRound && shape.diameter) {
    handleColors(p, shape, pattern.colorConfig)
    p.strokeWeight(1)
    p.circle(0, 0, radius * 2)
  } else {
    // Make the shape
    p.beginShape()
    shape.coordinates.forEach((point) => {
      p.vertex(point.x, point.y)
    })
    p.rotate(shape.rotation)
    handleColors(p, shape, pattern.colorConfig)
    p.strokeWeight(3)
    p.endShape(p.CLOSE)
  }
}

/**
 * Method to draw all shapes on the canvas
 * @param p
 * @param shapes
 */
export const draw = (
  p: p5,
  shapes: PhysicalShape[],
  patternConfig: _PatternConfig
) => {
  // Use this to prevent background issues
  // p.push();
  // p.background(0);
  // p.pop();

  if (patternConfig.animate) {
    patternConfig.innerPattern.colorConfig.shiftColors('contract', true, true)
    patternConfig.outerPattern.colorConfig.shiftColors('expand', true, true)
  }

  let inner = false

  shapes.forEach((shape) => {
    if (shape.isEdgeShape) inner = true // Change to the inner pattern when it crosses the edge shape

    p.push()
    p.translate(p.width * 0.5 + shape.x, p.height * 0.5 + shape.y)
    renderShape(
      p,
      shape,
      inner ? patternConfig.innerPattern : patternConfig.outerPattern
    )
    p.pop()
  })
}



================================================
FILE: src/sketches/Mandala/interfaces.ts
================================================
import { _ColorConfig, _PhysicalFeatures, _ShapeDesign } from "./classes/Config";




================================================
FILE: src/sketches/Mandala/setup.ts
================================================
import p5 from 'p5'
import type { PatternConfig } from './classes/Config'
import { createMandala } from './Mandala/mandalaFunctions'

export const setup = (p: p5, patternConfig: PatternConfig) => {
  p.setup = () => {
    p.frameRate(1)
    p.createCanvas(patternConfig.canvas[0], patternConfig.canvas[1])
    p.background(
      p.color(patternConfig.outerPattern.colorConfig.backgroundColor)
    )
  }

  return createMandala(p, patternConfig)
}



================================================
FILE: src/sketches/Mandala/sketch.ts
================================================
import p5 from 'p5'
import * as patterns from './configurations'
import { draw } from './draw'
import { setup } from './setup'

const pattern = patterns.kelliPattern

/**
 * @param {p5} p - The pj.js object used to store all data about the canvas
 */
const sketch = (p: p5) => {
  const shapes = setup(p, pattern)

  p.draw = () => {
    draw(p, shapes, pattern)
  }

  p.keyPressed = () => {
    // Export sketch's canvas to file
    if (p.keyCode === 80) {
      p.saveCanvas('sketch', 'png')
    }
  }
}

export default sketch



================================================
FILE: src/sketches/Mandala/classes/Config.ts
================================================
import { Mandala } from './Mandala'

export type ColorDirection = 'expanding' | 'contracting'

export interface _ColorConfig {
  bgColorScheme: string[] // Color scheme for background
  strokeColorScheme: string[] // Color scheme for lines
  colorPatternType: 'layers' | 'spiral'
  backgroundColor: string // The background color of the pattern
  innerColorChange?: boolean // Change colors in the inner fractal
  isRandom?: boolean // Whether to apply randomness to color scheme
  spaces?: number // Whether to apply spaces to the color scheme
  direction?: ColorDirection // The direction of the ordered color scheme
}

export type FractalOption = 'none' | 'normal' | 'flipped' // How to handle inner fractals

export interface _ShapeDesign {
  isRound: boolean // If true, shape will be a circle
  isInverted: boolean // If true, the shape's lines start at the core like a flower
  isStar: boolean // If true, the shape will be a star
  innerFractals: FractalOption // If true, the shape will contain inner fractals
}

export interface _PhysicalFeatures {
  colorConfig: ColorConfig // The color configuration of the shape
  shapeDesign: ShapeDesign // The geometric design of the shape
}

// export interface _PatternConfig {
//   backgroundConfig: _PhysicalFeatures; // Settings for the pattern in the background
//   foregroundConfig: _PhysicalFeatures; // Settings for the pattern in the foreground
// }

export interface _PatternConfig {
  innerPattern: _PhysicalFeatures // The color scheme and shape design of the inner pattern
  outerPattern: _PhysicalFeatures // The color scheme and shape design of the outer pattern
  canvas: number[] // The size of the canvas
  edgeDiameter: number // The radius at which the pattern switches from inner to outer
  mandala: Mandala // The configuration for the mandala pattern
  animate?: boolean // Related to animating the pattern, probably needs more
}

/**
 * Class for color pattern
 */
export class ColorConfig implements _ColorConfig {
  bgColorScheme: string[]
  strokeColorScheme: string[]
  colorPatternType: 'layers' | 'spiral'
  backgroundColor: string
  innerColorChange?: boolean
  isRandom?: boolean
  spaces?: number
  direction?: 'expanding' | 'contracting'

  constructor(
    bgColorScheme: string[],
    strokeColorScheme: string[],
    colorPatternType: 'layers' | 'spiral',
    backgroundColor: string,
    innerColorChange?: boolean,
    isRandom?: boolean,
    spaces?: number,
    direction?: 'expanding' | 'contracting'
  ) {
    if (spaces) {
      // Apply spacing to the colors if there is a space needed
      bgColorScheme = this.addSpaceToColors(
        bgColorScheme,
        backgroundColor,
        spaces
      )
      strokeColorScheme = this.addSpaceToColors(
        strokeColorScheme,
        'rgba(0,0,0,0)',
        spaces
      )
    }
    this.bgColorScheme = bgColorScheme
    this.strokeColorScheme = strokeColorScheme
    this.colorPatternType = colorPatternType
    this.backgroundColor = backgroundColor
    this.innerColorChange = innerColorChange
    this.isRandom = isRandom
    this.spaces = spaces
    this.direction = direction
  }

  /**
   * Method to add the background color between each color in the color scheme
   * @param {string[]} colors - The color scheme
   * @param {string} bg - The background color
   * @returns {string[]}
   */
  addSpaceToColors(colors: string[], bg: string, spaces: number): string[] {
    const spacedColors: string[] = []
    colors.forEach((color) => {
      spacedColors.push(color)
      for (let i = 0; i < spaces; i++) {
        spacedColors.push(bg)
      }
    })
    return spacedColors
  }
  /**
   * Method which shifts the order of the color array to
   * create a whirlpool or ripple animation effect
   * @param option - Either expand or contract
   * @param shiftBackground - Whether or not to shift the background of shapes
   * @param shiftStroke - Whether or not to shift the stroke color of shapes
   */
  shiftColors(
    option: 'expand' | 'contract',
    shiftBackground?: boolean,
    shiftStroke?: boolean
  ) {
    if (shiftBackground) {
      this.bgColorScheme =
        option === 'expand'
          ? ([...this.bgColorScheme, this.bgColorScheme.shift()] as string[])
          : ([this.bgColorScheme.pop(), ...this.bgColorScheme] as string[])
    }
    if (shiftStroke) {
      this.strokeColorScheme =
        option === 'expand'
          ? ([
              ...this.strokeColorScheme,
              this.strokeColorScheme.shift()
            ] as string[])
          : ([
              this.strokeColorScheme.pop(),
              ...this.strokeColorScheme
            ] as string[])
    }
  }
}

/**
 * Class used for the config segments of a shape pattern
 */
export class ShapeDesign implements _ShapeDesign {
  isRound: boolean
  isInverted: boolean
  isStar: boolean
  innerFractals: 'none' | 'normal' | 'flipped'
  constructor(
    isRound: boolean,
    isInverted: boolean,
    isStar: boolean,
    innerFractals: 'none' | 'normal' | 'flipped'
  ) {
    this.isRound = isRound
    this.isInverted = isInverted
    this.isStar = isStar
    this.innerFractals = innerFractals
  }
}

/**
 * Settings for a pattern that can be animated
 */
export class PatternConfig implements _PatternConfig {
  innerPattern: _PhysicalFeatures
  outerPattern: _PhysicalFeatures
  canvas: number[]
  edgeDiameter: number
  mandala: Mandala
  animate?: boolean
  constructor(
    innerPattern: _PhysicalFeatures,
    outerPattern: _PhysicalFeatures,
    canvas: number[],
    edgeDiameter: number,
    mandala: Mandala,
    animate?: boolean
  ) {
    this.innerPattern = innerPattern
    this.outerPattern = outerPattern
    this.canvas = canvas
    this.edgeDiameter = edgeDiameter
    this.mandala = mandala
    this.animate = animate
  }
}



================================================
FILE: src/sketches/Mandala/classes/Mandala.ts
================================================
import { MandalaType } from "../Mandala/mandalaFunctions";
import { Coordinate } from "./Shape";

/**
 * Class for the Mandala object which is used to control the unique aspects of a Mandala pattern
 */
export class Mandala {
  diameter: number; // The diameter of the outer shape
  limit: number; // The number of layers of the geometry
  numberOfShapes: number; // The  number of squares in the pattern
  patternType: MandalaType; // Whether it is a triangle or square pattern
  displacement?: Coordinate; // The extra X and Y values to add to the shape
  constructor(
    diameter: number,
    limit: number,
    numberOfShapes: number,
    patternType: MandalaType,
    displacement?: Coordinate
  ) {
    this.diameter = diameter;
    this.limit = limit;
    this.numberOfShapes = numberOfShapes;
    this.patternType = patternType;
    this.displacement = displacement;
  }
}



================================================
FILE: src/sketches/Mandala/classes/PhysicalShape.ts
================================================
import p5 from 'p5'
import { calculateInnerStarRadius } from '../Mandala/functions'
import {
  ShapeDesign,
  _ColorConfig,
  _PhysicalFeatures,
  _ShapeDesign
} from './Config'
import { Coordinate, Shape, _Shape } from './Shape'

export interface _PhysicalShape extends _Shape {
  layer: number // The layer of the base shape within the overall pattern
  incrementalLayer: number // The internal layer of the shape based on inner fractals
  shapeDesign: ShapeDesign // The pattern to apply to the shape
  isEdgeShape?: boolean // Applied if the shape is the edge where it switched from outer to inner
}

/**
 * Class used for shapes in the geometry
 */
export class PhysicalShape extends Shape implements _PhysicalShape {
  layer: number
  incrementalLayer: number
  shapeDesign: ShapeDesign
  isEdgeShape?: boolean
  constructor(
    p: p5,
    x: number,
    y: number,
    sides: number,
    diameter: number,
    layer: number,
    incrementalLayer: number,
    shapeDesign: _ShapeDesign,
    rotation?: number,
    isEdgeShape?: boolean
  ) {
    super(p, x, y, sides, diameter, rotation)
    this.layer = layer
    this.incrementalLayer = incrementalLayer
    this.shapeDesign = shapeDesign
    this.coordinates = this.createCustomCoordinates(
      p,
      sides,
      diameter / 2.0,
      shapeDesign
    )
    this.isEdgeShape = isEdgeShape
  }

  /**
   * Method to generate the x/y coordinates of each point in a custom polygon
   * @param {p5} p - The p5.js object
   * @param {number} sides - The number of sides of the shape pattern
   * @param {number} radius - The radius of the shape
   * @param {_ShapeDesign} shapeDesign - The shape design
   * @returns {Coordinate[]}
   */
  createCustomCoordinates = (
    p: p5,
    sides: number,
    radius: number,
    shapeDesign: _ShapeDesign
  ): Coordinate[] => {
    const { isStar, isInverted } = shapeDesign
    const coordinates: Coordinate[] = []
    let angle = p.TWO_PI / sides // Angle at centre point of shape
    let halfAngle: number = 0 // Angle used for inner points of stars
    let innerRadius: number = 1 // Radius used for inner points of stars
    if (isStar) {
      // If shape is a star, generate the values for halfAngle and innerRadius
      halfAngle = angle / 2.0
      innerRadius = calculateInnerStarRadius(radius, sides)
    }
    for (let a = 0; a < p.TWO_PI + 0; a += angle) {
      let sx = p.cos(a) * radius
      let sy = p.sin(a) * radius
      coordinates.push({ x: sx, y: sy })
      isInverted && coordinates.push({ x: 0, y: 0 })
      if (isStar) {
        // If shape is a star generate the points for the star
        sx = p.cos(a + halfAngle) * innerRadius
        sy = p.sin(a + halfAngle) * innerRadius
        coordinates.push({ x: sx, y: sy })
        isInverted && coordinates.push({ x: 0, y: 0 })
      }
    }
    return coordinates
  }
}



================================================
FILE: src/sketches/Mandala/classes/Shape.ts
================================================
import p5 from "p5";

export interface _Shape {
  x: number; // x coordinate used in p.translate()
  y: number; // y coordinate used in p.translate
  sides: number; // number of sides the shape has
  diameter: number; // diameter of the shape within a circle
  rotation?: number; // optional rotation to p.rotate()
}

export type Coordinate = { x: number; y: number }; // A coordinate with x and y points

/**
 * Basic shape where each side is the same length.
 * It is used as the parent of all shapes in geometric animations
 */
export class Shape implements _Shape {
  x: number;
  y: number;
  readonly sides: number;
  diameter: number;
  rotation: number;
  coordinates: Coordinate[];
  constructor(
    p: p5,
    x: number,
    y: number,
    sides: number,
    diameter: number = 100,
    rotation: number = 0
  ) {
    this.x = x;
    this.y = y;
    this.sides = sides;
    this.diameter = diameter;
    this.rotation = this.calculateRotation(p, sides, rotation);
    this.coordinates = this.createRegularCoordinates(
      p,
      sides,
      diameter / 2.0,
      this.rotation
    );
  }

  /**
   * Method to normalise the rotation of the fundamental shapes
   * @param {p5} p - p5.js object
   * @param {number} sides - number of sides shape has
   * @param {number} baseRotation - optional extra rotation to add to default rotation
   * @returns {number}
   */
  calculateRotation(p: p5, sides: number, baseRotation: number): number {
    switch (sides) {
      case 3: // Triangle
        return -p.PI / 2 + baseRotation;
      case 4: // Square
        return -p.PI / 4 + baseRotation;
      case 5: // Pentagon
        return -p.PI / 2 + baseRotation;
      case 6: // Hexagon
        return 0 + baseRotation;
      default:
        return baseRotation;
    }
  }

  /**
   * Method to generate the x/y coordinates of each point in a regular polygon
   * @param {p5} p - The p5.js object
   * @param {number} sides - The number of sides of the shape pattern
   * @param {number} radius - The radius of the shape
   * @param {number} baseRotation - The initial rotation of the shape
   * @returns {void}
   */
  createRegularCoordinates = (
    p: p5,
    sides: number,
    radius: number,
    baseRotation: number
  ): Coordinate[] => {
    const coordinates: Coordinate[] = [];
    let angle = p.TWO_PI / sides; // Angle at centre point of shape
    for (let a = baseRotation; a < p.TWO_PI + baseRotation; a += angle) {
      let sx = p.cos(a) * radius;
      let sy = p.sin(a) * radius;
      coordinates.push({ x: sx, y: sy });
    }
    return coordinates;
  };
}



================================================
FILE: src/sketches/Mandala/Mandala/functions.ts
================================================
import p5 from 'p5'
import type { ColorDirection } from '../classes/Config'
import { PHI, ROOT2, ROOT3 } from '../constants'

/**
 * Return a random color from a color palette
 * @param {string[]} colors - The array containing the color palette
 * @returns {string}
 */
export const pickRandomColor = (colors: string[]): string => {
  const randomInt = Math.floor(Math.random() * colors.length)
  return colors[randomInt]
}

/**
 * Pick a color from the color palette using the layer number
 * @param {string[]} colors - The array containing the color palette
 * @param {number} layer - The layer number to use for selecting the color
 * @returns {string}
 */
export const pickOrderedColor = (colors: string[], layer: number): string => {
  let color: string = '#000' // Black by default
  try {
    // Need to also consider negative numbers now
    color = colors[reduceNum(layer, colors.length)]
  } catch (error) {
    color = colors[0]
  }
  return color
}

/**
 * Reduce a number to its smallest version within a range
 * @param {number} currentNumber - The current version of a number
 * @param {number} limit - The maximum number in the range
 * @returns {number}
 */
const reduceNum = (currentNumber: number, limit: number): number => {
  if (currentNumber >= limit) {
    return reduceNum(currentNumber - limit, limit)
  } else if (currentNumber < 0) {
    return reduceNum(currentNumber + limit, limit)
  } else {
    return currentNumber
  }
}

/**
 * Calculate the inner radius of the Star shape
 * @param {number} radius - The outer radius of the shape
 * @param {number} sides - The number of sides
 * @returns {number}
 */
export const calculateInnerStarRadius = (
  radius: number,
  sides: number
): number => {
  switch (sides) {
    case 3:
      return radius / 4.0
    case 4:
      return radius / 2.0
    case 5:
      return radius / (PHI + 1)
    case 6:
      return radius / ROOT3
    default:
      return radius / 2.0
  }
}

/**
 * Calculate the fractal radius to apply to a shape
 * @param {number} radius - The original radius of the shape
 * @param {number} sides - The number of sides
 * @returns {number}
 */
export const calculateInnerFractalRadius = (
  radius: number,
  sides: number
): number => {
  switch (sides) {
    case 3:
      return radius / 2.0
    case 4:
      return radius / ROOT2
    case 5:
      return (radius * PHI) / 2.0
    case 6:
      return radius / (2 / ROOT3)
    default:
      return radius / 2.0
  }
}

/**
 * Calculate the fractal rotation to apply to a shape
 * @param {p5} p - The p5.js object
 * @param {number} sides - The number of sides
 * @returns {number}
 */
export const calculateFlippedFractalRotation = (p: p5, sides: number) => {
  switch (sides) {
    case 3:
      return p.PI
    case 4:
      return p.PI / 4
    case 5:
      return p.PI
    case 6:
      return p.PI / 2
    default:
      return p.PI / 2
  }
}

/**
 * Determine the color based on the color parametars
 * @param colorScheme
 * @param isRandom
 * @param layer
 */
export const generateColor = (
  colorScheme: string[],
  isRandom: boolean,
  direction: ColorDirection,
  layer: number
) => {
  if (isRandom) {
    return pickRandomColor(colorScheme)
  } else {
    return pickOrderedColor(
      direction !== 'contracting' ? colorScheme : colorScheme.reverse(),
      layer
    )
  }
}

export type Coordinate = { x: number; y: number }

/**
 * Method to generate x/y coordinates for rendering a geometry
 * @param {p5} p - The p5.js object
 * @param {number} sides - The number of sides of the shape pattern
 * @param {number} radius - The radius of the shape
 * @param {number} overflow - The extra angle to add to the shape
 * @param {Coordinate} displacement - The extra X and Y values to add to the shape
 * @returns {Coordinate[]}
 */
export const createCoordinates = (
  p: p5,
  sides: number,
  radius: number,
  overflow?: number,
  displacement?: Coordinate
): Coordinate[] => {
  let angle = p.TWO_PI / sides // Angle at centre point of shape
  let initial = overflow ? overflow : 0
  let dx = displacement ? displacement.x : 0
  let dy = displacement ? displacement.y : 0
  const coordinates: Coordinate[] = []
  for (let a = initial; a < p.TWO_PI + initial; a += angle) {
    let sx = p.cos(a) * radius + dx
    let sy = p.sin(a) * radius + dy
    coordinates.push({ x: sx, y: sy })
  }
  return coordinates
}

/**
 * Method to add the background color between each color in the color scheme
 * @param {string[]} colors - The color scheme
 * @param {string} bg - The background color
 * @returns {string[]}
 */
export function addSpaceToColors(colors: string[], bg: string): string[] {
  const spacedColors: string[] = []
  colors.forEach((color) => {
    spacedColors.push(color)
    spacedColors.push(bg)
  })
  return spacedColors
}



================================================
FILE: src/sketches/Mandala/Mandala/mandalaFunctions.ts
================================================
import p5 from 'p5'
import {
  calculateFlippedFractalRotation,
  calculateInnerFractalRadius,
  Coordinate,
  createCoordinates
} from './functions'
import { PatternConfig, _PhysicalFeatures } from '../classes/Config'
import { PhysicalShape } from '../classes/PhysicalShape'
import { PHI, ROOT2, ROOT3 } from '../constants'

export type MandalaType = 'square' | 'triangle' | 'triangle-flipped' | 'pent' // Available Mandala Patterns

export type CoreMandalaValues = {
  shapeDiameter: number // Diameter of outermost shapes
  patternDiameter: number // Diameter of pattern
  fractalRatio: number // Ratio applied between each layer of pattern
}

/**
 * Method to calculate the core values needed for the square
 * and triangle-1 pattern
 * @param {p5} p - The p5.js Object
 * @param {number} diameter - The initial diameter of the pattern
 * @param {number} sides - The number of sides in the pattern
 * @param {MandalaType} pattern - The type of pattern being applied to the mandala
 * @returns {CoreMandalaValues}
 */
const calculateCoreValues = (
  p: p5,
  diameter: number,
  sides: number,
  pattern: MandalaType
): CoreMandalaValues => {
  const startRadius = diameter / 2.0 // Radius between centre and start of shape
  const innerAngle = p.TWO_PI / sides // Angle at centre of circle
  const x = 2 * startRadius * p.sin(innerAngle / 2) // Length of side at bottom of triangle
  const reduceAngle = pattern === 'triangle' ? p.TWO_PI / 3 : p.TWO_PI / 4 // 120 if triangles, 90 if squares
  const outerAngle = p.PI - innerAngle - reduceAngle // Angle of outer triangle
  const shapeSide = x / (2 * p.sin(outerAngle / 2)) // Side length of shape
  const reduceLength = pattern === 'triangle' ? ROOT3 : ROOT2 // Ratio between shape side and shape radius
  const shapeRadius = shapeSide / reduceLength // Radius of shape
  const shapeDiameter = 4 * shapeRadius // Diameter of shape
  const patternDiameter = 2 * (startRadius + shapeRadius) // Diameter of pattern
  // If pattern is triangle, the ratio is between shape length and x
  const triFractalPatternRatio = shapeSide / x // Fractal ratio if pattern is triangle
  const bottomDiamondAngle = p.PI - outerAngle // Angle of bottom of diamond in square pattern
  const smallerSideLength = x / (2 * p.sin(bottomDiamondAngle / 2)) // Side length of smaller square
  const sqFractalPatternRatio = shapeSide / smallerSideLength // Fractal ratio if pattern is square
  const fractalRatio =
    pattern === 'triangle' ? triFractalPatternRatio : sqFractalPatternRatio // Fractal ratio
  return { shapeDiameter, patternDiameter, fractalRatio }
}

/**
 * Method to calculate the core values needed for the
 * triangle-2 pattern
 * @param {p5} p - The p5.js Object
 * @param {number} diameter - The initial diameter of the pattern
 * @param {number} sides - The number of sides in the pattern
 * @returns {CoreMandalaValues}
 */
const calculateFlippedCoreValues = (
  p: p5,
  diameter: number,
  sides: number
): CoreMandalaValues => {
  const startRadius = diameter / 2.0 // Radius between centre and start of shape
  const innerAngle = p.TWO_PI / sides // Angle at centre of circle
  const shapeSide = 2 * startRadius * p.sin(innerAngle / 2) // Length of equilateral triangle
  const angleA = p.PI / 3 - p.PI / sides // Double angle in isosceles triangle
  const angleB = p.PI - 2 * angleA // Single angle in isosceles triangle
  const y = 2 * shapeSide * p.sin(angleB / 2) // Larger side in isosceles triangle
  const fractalRatio = y / shapeSide // Ratio between each layer in fractal
  const triRadius = shapeSide / ROOT3 // Radius of equilateral triangle
  const shapeDiameter = triRadius * 4 // Diameter of equilateral triangle
  const smallerTriRadius = triRadius / 2 // Line between bottom of triangle and centre
  const properPatternRadius =
    Math.sqrt(startRadius ** 2 - shapeSide ** 2 / 4) + smallerTriRadius // Radius touching bottom of triangle
  const patternDiameter = properPatternRadius * 2 // Diameter of pattern used for shape
  return { shapeDiameter, patternDiameter, fractalRatio }
}

/**
 * Method which creates all shapes in the mandala, including each layer, and the inner fractal
 * shapes if there are any
 * @param {p5} p - The p5.js object
 * @param coordinates - The starting coordinates of the outermost layer
 * @param rotation - The rotation applied to the pattern
 * @param coreValues - The values that have been created through the trigonemetric equations
 */
const generateEachLayer = (
  p: p5,
  coordinates: Coordinate[],
  rotation: number,
  coreValues: CoreMandalaValues,
  patternConfig: PatternConfig
) => {
  let shapes: PhysicalShape[] = [] // Store all shapes in this array
  const { mandala } = patternConfig
  const { displacement, limit, numberOfShapes, patternType } = mandala
  let { fractalRatio, patternDiameter, shapeDiameter } = coreValues
  let spiralIncrementor = 0
  const { innerPattern, outerPattern } = patternConfig
  let pattern: _PhysicalFeatures = outerPattern
  let switchedToInner = false
  let isEdgeShape: boolean = false
  const sides = patternType === 'square' ? 4 : patternType === 'pent' ? 5 : 3 // Number of sides on the shape
  console.log('shapeDiameter: ' + shapeDiameter)
  console.log('patternDiameter: ' + patternDiameter)

  // Create all the layers of the geometry within the limit range
  for (let layer = 0; layer < limit; layer++) {
    if (!switchedToInner && patternDiameter < patternConfig.edgeDiameter) {
      // Make the switch to inner pattern when edge condition is altered
      pattern = innerPattern
      switchedToInner = true
      isEdgeShape = true
    }
    let runOnce = true // Set to true so that loop when a shape at each coordinate runs at least once

    // For triangle patterns, to make a spiral, every 2 layers we need to SHIFT the pattern by 1.
    if (patternType !== 'square' && layer % 2 == 0 && layer !== 0) {
      spiralIncrementor += 1
    } else if (patternType === 'square' || patternType === 'pent') {
      // For square patterns, to make a spiral, every layer the pattern is shifted by 1
      spiralIncrementor += 1
    }
    // Create a shape for each coordinate in the layer
    coordinates.forEach((coordinate, i2) => {
      runOnce = true // Ensure run once is set to tru
      let currentDiameter = shapeDiameter
      let currentRotation = rotation
      const shapeLayer =
        pattern.colorConfig.colorPatternType === 'layers'
          ? layer // Layered pattern applied to colors
          : i2 - spiralIncrementor // Spiral pattern applied to colors
      let incrementalLayer = shapeLayer // Increment the layer

      // Create a single shape, including its inner fractals

      while (
        runOnce ||
        (pattern.shapeDesign.innerFractals !== 'none' && currentDiameter > 60)
      ) {
        shapes.push(
          new PhysicalShape(
            p,
            coordinate.x,
            coordinate.y,
            sides,
            currentDiameter,
            shapeLayer,
            incrementalLayer,
            pattern.shapeDesign,
            currentRotation,
            isEdgeShape
          )
        )
        currentDiameter = calculateInnerFractalRadius(currentDiameter, sides)
        const rotator =
          pattern.shapeDesign.innerFractals === 'flipped'
            ? calculateFlippedFractalRotation(p, sides)
            : 0
        currentRotation += rotator // Adjust the inner fractal based on the appropriate rotation
        incrementalLayer += 1 // Increment the incremental layer
        runOnce = false // End loop if not generating inner fractal
      }
      // shapes.push( // ADD AN INVERTED SHAPE AT CENTRE
      //   new PhysicalShape(
      //     p,
      //     coordinate.x,
      //     coordinate.y,
      //     sides,
      //     currentDiameter,
      //     shapeLayer,
      //     incrementalLayer,
      //     {...pattern.shapeDesign, isInverted: true},
      //     currentRotation,
      //     isEdgeShape
      //   )
      // );
      rotation += p.TWO_PI / numberOfShapes // Adjust rotation for each triangle
    })

    // Reduce diameters by the appropriate ratio
    shapeDiameter = shapeDiameter / fractalRatio // Reduce diameter of shapes
    console.log('shapeDiameter: ' + shapeDiameter)
    patternDiameter = patternDiameter / fractalRatio // Reduce diameter of overall pattern
    console.log('patternDiameter: ' + patternDiameter)

    // Reset rotation based on the layer and type of pattern
    patternType === 'square'
      ? (rotation = -p.PI / 4) // Square rotation reset
      : patternType === 'pent'
      ? (rotation = p.PI / 2)
      : patternType === 'triangle'
      ? layer % 2 === 0
        ? (rotation = -p.PI / 2 + p.PI / numberOfShapes) // Triangle rotation reset
        : (rotation = -p.PI / 2)
      : layer % 2 === 0
      ? (rotation = p.PI / 2 + p.PI / numberOfShapes) // Triangle roatation flipped reset
      : (rotation = p.PI / 2)

    // Create new coordinates for the next layer
    coordinates = createCoordinates(
      p,
      numberOfShapes,
      patternDiameter,
      layer % 2 === 0 && patternType !== 'square' && patternType !== 'pent'
        ? p.PI / numberOfShapes
        : 0,
      displacement
    )

    if (isEdgeShape) isEdgeShape = false
  }
  return shapes
}

/**
 * Method to create a Any-sided pattern of squares
 * @param {p5} p - The p5.js object
 * @param {PatternConfig} patternConfig - The settings for the pattern
 * @returns {PhysicalShape[]}
 */
const createAnySidedSquares = (
  p: p5,
  patternConfig: PatternConfig
): PhysicalShape[] => {
  const { mandala } = patternConfig
  const { diameter, numberOfShapes, displacement } = mandala
  let sqRotation = -p.PI / 4 // rotation to apply to each square
  const coreValues = calculateCoreValues(p, diameter, numberOfShapes, 'square') // Get the core values
  let coordinates = createCoordinates(
    p,
    numberOfShapes,
    coreValues.patternDiameter,
    0,
    displacement
  ) // coordinates of Any-sided points
  const shapes = generateEachLayer(
    p,
    coordinates,
    sqRotation,
    coreValues,
    patternConfig
  )
  return shapes
}

/**
 * Method to create an any-sided triangles pattern for the shapes
 * @param {p5} p - The p5.js object
 * @param {PatternConfig} patternConfig - The settings for the pattern
 * @returns {PhysicalShape[]}
 */
const createAnySidedTriangles = (
  p: p5,
  patternConfig: PatternConfig
): PhysicalShape[] => {
  const { mandala } = patternConfig
  const { diameter, numberOfShapes, displacement } = mandala
  let triRotation = -p.PI / 2 // rotation to apply to each triangle
  const coreValues = calculateCoreValues(
    p,
    diameter,
    numberOfShapes,
    'triangle'
  ) // Get the core values
  let coordinates = createCoordinates(
    p,
    numberOfShapes,
    coreValues.patternDiameter,
    0,
    displacement
  ) // coordinates of 15-sided points

  const shapes = generateEachLayer(
    p,
    coordinates,
    triRotation,
    coreValues,
    patternConfig
  )
  return shapes
}

/**
 * Method to create an any-sided triangles pattern for the shapes
 * @param {p5} p - The p5.js object
 * @param {PatternConfig} patternConfig - The settings for the pattern
 * @returns {PhysicalShape[]}
 */
const createAnySidedTrianglesFlipped = (
  p: p5,
  patternConfig: PatternConfig
): PhysicalShape[] => {
  const { mandala } = patternConfig
  const { diameter, numberOfShapes, displacement } = mandala
  let triRotation = p.PI / 2 // rotation to apply to each triangle
  const coreValues = calculateFlippedCoreValues(p, diameter, numberOfShapes) // Get the core values
  let coordinates = createCoordinates(
    p,
    numberOfShapes,
    coreValues.patternDiameter,
    0,
    displacement
  ) // coordinates of 15-sided points
  const shapes = generateEachLayer(
    p,
    coordinates,
    triRotation,
    coreValues,
    patternConfig
  )
  return shapes
}

const createDecagonPattern = (p: p5, patternConfig: PatternConfig) => {
  const { mandala } = patternConfig
  const { diameter } = mandala
  const ratio1 = Math.sin(Math.PI / 5)
  const ratio2 = Math.tan((2 * Math.PI) / 5)
  const ratio3 = Math.tan((3 * Math.PI) / 10)
  let patternRadius = diameter / 2.0 // Radius of the decagonal pattern (decagon)
  let coordinates = createCoordinates(p, 10, patternRadius) // Coordinates of decagonal points, similar to createCoordinates()
  let shapeRadius = patternRadius / (ratio1 * (ratio3 + ratio2)) // Radius of the shape (pentagon)
  const coreValues: CoreMandalaValues = {
    shapeDiameter: shapeRadius * 2,
    patternDiameter: diameter / 2,
    fractalRatio: PHI
  }
  const shapes = generateEachLayer(
    p,
    coordinates,
    p.PI / 2,
    coreValues,
    patternConfig
  )
  return shapes
}

/**
 * Method to create a mandala pattern for the shapes
 * @param {p5} p - The p5.js object
 * @param {PatternConfig} patternConfig - The config settings for the overall geometry
 * @returns {PhysicalShape[]}
 */
export const createMandala = (
  p: p5,
  patternConfig: PatternConfig
): PhysicalShape[] => {
  const pattern = patternConfig.mandala.patternType
  if (pattern === 'square') {
    return createAnySidedSquares(p, patternConfig)
  } else if (pattern === 'triangle') {
    return createAnySidedTriangles(p, patternConfig)
  } else if (pattern === 'triangle-flipped') {
    return createAnySidedTrianglesFlipped(p, patternConfig)
  } else {
    return createDecagonPattern(p, patternConfig)
  }
}



================================================
FILE: src/sketches/ParticleSystem/classes.ts
================================================
import { Vector } from "p5";
import type p5 from "p5";

/**
 * A simple Particle class
 */
export class Particle {
  acceleration: Vector;
  velocity: Vector;
  position: Vector;
  lifespan: number;
  constructor(p: p5, position: Vector) {
    this.acceleration = p.createVector(0, 0.05);
    this.velocity = p.createVector(p.random(-1, 1), p.random(-1, 0));
    this.position = position.copy();
    this.lifespan = 255;
  }

  /**
   * Move the particle and render it on the canvas
   * @param {p5} p - The p5.js object
   */
  run(p: p5) {
    this.update();
    this.display(p);
  }

  /**
   * Move the particle based on its velocity and reduce its lifespan
   */
  update() {
    this.velocity.add(this.acceleration);
    this.position.add(this.velocity);
    this.lifespan -= 2;
  }

  /**
   * Render the particle on the canvas
   * @param {p5} p - The p5.js object
   */
  display(p: p5) {
    p.stroke(200, this.lifespan);
    p.strokeWeight(2);
    p.fill(127, this.lifespan);
    p.ellipse(this.position.x, this.position.y, 12, 12);
  }

  /**
   * Return true when the lifespan is over
   */
  isDead() {
    return this.lifespan < 0;
  }
}

/**
 * The class that holds all the particles and causes them to move
 */
export class ParticleSystem {
  origin: Vector;
  particles: Particle[];
  constructor(position: Vector) {
    this.origin = position.copy();
    this.particles = [];
  }

  /**
   * Run the animation by moving each particle in the system
   * @param {p5} p - The p5.js object
   */
  run(p: p5) {
    this.particles.forEach((particle, i) => {
      particle.run(p);
      if (particle.isDead()) {
        this.particles.splice(i, 1);
      }
    });
  }

  /**
   * Spawn a new particle into the system at the origin point
   * @param {p5} p - The p5.js object
   */
  addParticle(p: p5) {
    this.particles.push(new Particle(p, this.origin));
  }
}



================================================
FILE: src/sketches/ParticleSystem/sketch.ts
================================================
import type p5 from "p5";
import { ParticleSystem } from "./classes";

/**
 * This sketch is an animation of moving particles.
 * It uses a global ParticleSystem object to store and move particles. 
 * It calls setup once to make a 400 x 400 canvas and initialise the ParticleSystem. 
 * It calls the draw method continuously to run the animation.
 * @param {p5} p - The p5.js object
 *  
 */
export default function particleSystemSketch(p: p5) {
  let system: ParticleSystem;

  p.setup = () => {
    p.createCanvas(400, 400); 
    system = new ParticleSystem(p.createVector(p.width / 2, 50));
  };

  p.draw = () => {
    p.background(10);
    system.addParticle(p);
    system.run(p);
  };
}



================================================
FILE: src/sketches/Shapes/classes.ts
================================================
import type p5 from "p5";
import { Coordinate, ShapeType } from "../types";

/**
 * A basic form in the p5.js canvas with a color, a location on the canvas.
 * and a radius for its size.
 */
export class Shape {
  color: string;
  location: Coordinate;
  radius: number;
  type: ShapeType;
  // The variables below are only here to enable polymorphic usage of Shape children
  points?: Coordinate[];
  width?: number;
  height?: number;
  constructor(
    color: string,
    location: Coordinate,
    radius: number,
    type: ShapeType
  ) {
    this.color = color;
    this.location = location;
    this.radius = radius;
    this.type = type;
  }
}

/**
 * A circle shape that will be rendered with p5.circle()
 */
export class Circle extends Shape {
  constructor(color: string, location: Coordinate, radius: number = 50) {
    super(color, location, radius, "circle");
  }
}

/**
 * An ellipse shape that will be rendered with p5.ellipse()
 */
export class Ellipse extends Shape {
  constructor(
    color: string,
    location: Coordinate,
    width: number,
    height: number
  ) {
    super(color, location, 50, "ellipse");
    this.width = width;
    this.height = height;
  }
}

/**
 * A shape with a specific number of sides and points representing the position
 * of each of its corners.
 */
export class Polygon extends Shape {
  sides: number;

  constructor(
    p: p5,
    color: string,
    location: Coordinate,
    radius: number = 50,
    sides: number = 4,
    points?: Coordinate[]
  ) {
    super(color, location, radius, "polygon");
    this.location = location;
    this.radius = radius;
    this.sides = sides;
    this.points =
      points || this.createRegularPoints(p, location, sides, radius);
  }

  /**
   * Generate the corners of a regular polygon, making each side an equal length
   * @param {p5} p - The p5.js object
   * @param {Coordinate} location - The central location of the shape on the canvas
   * @param {number} sides - The number of sides the shape has
   * @param {number} radius - The radius of the shape
   * @returns {Coordinate[]} - The array of points that represent the shapes corners
   */
  createRegularPoints(
    p: p5,
    location: Coordinate,
    sides: number,
    radius: number
  ): Coordinate[] {
    const { x, y } = location;
    const points: Coordinate[] = [];
    const angle = p.TWO_PI / sides;
    for (let i = 0; i < p.TWO_PI; i += angle) {
      let sx = x + p.cos(i) * radius;
      let sy = y + p.sin(i) * radius;
      points.push({ x: sx, y: sy });
    }
    return points;
  }
}

/**
 * The object which holds all the shapes and renders each one on the canvas
 * while also applying rotation
 */
export class RotatingShapes {
  shapes: Shape[];
  constructor(shapes: Shape[]) {
    this.shapes = shapes;
  }

  /**
   * Render each shape on the canvas and apply rotation
   * @param {p5} p - The p5.js object
   */
  run(p: p5) {
    this.shapes.forEach((shape) => {
      const { color, location, type, radius, points, width, height } = shape;

      p.push();
      p.translate(p.width / 2, p.height / 2);
      p.fill(p.color(color));
      p.rotate(p.frameCount / 50); // Apply rotation

      // Apply a different rendering method based on the shape type
      switch (type) {
        case "circle":
          p.circle(location.x, location.y, radius * 2);
          break;
        case "ellipse":
          if (width && height) p.ellipse(location.x, location.y, width, height);
          break;
        case "polygon":
          p.beginShape();
          points && points.forEach((point) => p.vertex(point.x, point.y));
          p.endShape(p.CLOSE);
          break;
        default:
          p.circle(location.x, location.y, radius * 2);
          break;
      }
      p.pop();
    });
  }
}



================================================
FILE: src/sketches/Shapes/sketch.ts
================================================
import { Circle, Ellipse, Polygon, RotatingShapes } from "./classes";
import type p5 from "p5";

/**
 * This sketch is an animation of various 2D shapes rotating around the canvas.
 * It uses a global RotatingShapes object to store and render the shapes.
 * @param {p5} p - The p5.js object
 */
export default function shapesSketch(p: p5) {
  let painter: RotatingShapes;

  p.setup = () => {
    p.createCanvas(400, 400);
    painter = new RotatingShapes([
      new Circle("red", { x: -90, y: 50 }, 30),
      new Ellipse("orange", { x: 120, y: -60 }, 40, 60),
      new Polygon(p, "green", { x: 30, y: 90 }, 20, 4),
      new Polygon(p, "blue", { x: -20, y: -20 }, 20, 6),
      new Polygon(p, "purple", { x: -80, y: -110}, 20, 3)
    ]);
  };

  p.draw = () => {
    p.background(10);
    painter.run(p);
  };
}



================================================
FILE: src/utils/common.ts
================================================
/**
 * Put a space between words where there is a capital letter.
 * For example - "ParticleSystem" -> "Particle System"
 * @param {string} key - The original string
 * @returns {string} - A string containing spaces between words
 */
export function spaceWords(key: string): string {
  let newString = "";
  for (let i = 0; i < key.length; i++) {
    if (key[i] === key[i].toUpperCase() && i > 0) {
      newString += " ";
    }
    newString += key[i];
  }
  return newString;
}

/** Typesafe version of Object.keys */
export const getKeys = Object.keys as <T extends object>(
  obj: T
) => Array<keyof T>;



================================================
FILE: src/utils/urlParams.ts
================================================
import { type SketchKey, sketchMap } from "../sketches/sketchMap";
import { getKeys } from "./common";

interface ParamsType {
  [key: string]: string | number;
}

/**
 * Reload the page with new URL parameters to load a new sketch
 * @param {string} url - The url path of the site
 * @param {string} params - The new url parameters to use
 */
export function redirectUrl(url: string, params?: ParamsType) {
  if (typeof window !== "undefined") {
    try {
      const _url = new URL(url);

      if (params) {
        const keyList = Object.keys(params);
        for (let i = 0; i < keyList.length; i += 1) {
          const key = keyList[i];
          _url.searchParams.set(keyList[i], params[key]?.toString());
        }
      }

      window.location.assign(_url.href);
    } catch (e) {
      throw new Error("The URL is not valid");
    }
  }
}

/**
 * Convert a Sketch Key into a simple url param. For example -
 * "FunAnimation" -> "fun-animation"
 * @param {SketchKey} key - The text that is being converted
 * @returns {string} - The url param that has been generated
 */
export function convertToParam(key: SketchKey): string {
  let param = "";
  for (let i = 0; i < key.length; i++) {
    if (key[i] === key[i].toUpperCase() && i > 0) {
      param += "-";
    }
    param += key[i];
  }
  return param.toLowerCase();
}

/**
 * Convert a url param into a key for a sketch. For example -
 * "fun-animation" -> "FunAnimation"
 * @param {string} param - The param from the query string
 * @returns {string} - The key for the sketchMap
 */
export function convertFromParam(param: string): SketchKey {
  const words = param.trim().split("-");
  let key = "";
  words.forEach((word) => {
    console.log(word);
    for (let i = 0; i < word.length; i++) {
      if (i === 0) {
        key += word[i].toUpperCase();
      } else {
        key += word[i];
      }
    }
  });
  return key as SketchKey;
}

/**
 * Get the sketch query param in the current URL
 * @param {SketchKey} defaultSketch - A basic sketch to use as a fallback
 * @returns {SketchKey} - The key of the sketch to use for the p5.js animation
 */
export function getSketchFromParams(defaultSketch: SketchKey): SketchKey {
  try {
    const params = new URLSearchParams(window.location.search);
    const sketchParam = params.get("sketch") as string;
    const key = convertFromParam(sketchParam);
    if (getKeys(sketchMap).includes(key)) {
      return key;
    } else {
      return defaultSketch;
    }
  } catch (error) {
    console.log("Url param error: " + error);
    console.log("Showing the default Shapes animation due to the Url error");
    return defaultSketch;
  }
}



================================================
FILE: test/common.test.ts
================================================
import { expect, test } from "vitest";

import { spaceWords, getKeys } from "../src/utils/common";

test("spaceWords()", () => {
  expect(spaceWords("SuperAwesomeSketch")).toBe("Super Awesome Sketch");
  expect(spaceWords("MySpace")).toBe("My Space");
});

test("getKeys()", () => {
  expect(getKeys({ hi: 1, bye: 2 })).toHaveLength(2);
  expect(getKeys({ hi: 1, bye: 2 })).toContain("hi");
});



================================================
FILE: test/urlParams.test.ts
================================================
import { expect, test } from "vitest";

import {
  convertFromParam,
  convertToParam,
} from "../src/utils/urlParams";

test("convertFromParam()", () => {
  expect(convertFromParam("bubble-sort")).toBe("BubbleSort");
  expect(convertFromParam("particle-system")).toBe("ParticleSystem");
});

test("convertToParam()", () => {
  expect(convertToParam("BubbleSort")).toBe("bubble-sort");
  expect(convertToParam("Shapes")).toBe("shapes");
});

