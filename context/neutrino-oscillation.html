<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Imagining the Neutrino</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.6.4/math.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: 'Fira Mono', 'Consolas', monospace;
      overflow: hidden;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      background: rgba(20,20,30,0.85);
      padding: 16px 24px;
      border-radius: 12px;
      box-shadow: 0 2px 16px #000a;
    }
    #controls label {
      margin-right: 8px;
    }
    #plots {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(20,20,30,0.85);
      padding: 12px 20px;
      border-radius: 12px;
      box-shadow: 0 2px 16px #000a;
    }
    canvas { display: block; }
    #densityControl { display: none; }
  </style>
</head>
<body>
  <div id="controls">
    <label for="initialFlavor">Initial Flavor:</label>
    <select id="initialFlavor">
      <option value="0">Electron</option>
      <option value="1">Muon</option>
      <option value="2">Tau</option>
    </select>
    <label for="energySlider">Energy (GeV):</label>
    <input type="range" id="energySlider" min="0.1" max="10" value="2" step="0.1">
    <span id="energyValue">2.0</span>
    <label for="speedSlider" style="margin-left:20px;">Speed:</label>
    <input type="range" id="speedSlider" min="0.1" max="3" value="1" step="0.01">
    <span id="speedValue">1.00x</span>
    <label for="matterToggle" style="margin-left:20px;">Matter effect:</label>
    <input type="checkbox" id="matterToggle">
    <div id="densityControl">
      <label for="density">Density (g/cm³):</label>
      <input type="range" id="density" min="0" max="10" value="2.6" step="0.1">
      <span id="densityValue">2.6</span>
    </div>
  </div>
  <div id="plots">
    <canvas id="probPlot" width="500" height="120"></canvas>
  </div>
  <script>
    // Neutrino Oscillation Parameters
    let theta12 = 33.44 * Math.PI / 180;
    let theta13 = 8.57 * Math.PI / 180;
    let theta23 = 49.2 * Math.PI / 180;
    let dm21 = 7.42e-5; // eV^2
    let dm31 = 2.517e-3; // eV^2
    const LmaxSim = 3000; // km
    const c = 299792.458; // km/s

    // Flavor colors
    const flavorColors = {
      0: [80, 180, 255], // Electron: Blue
      1: [255, 140, 40], // Muon: Orange
      2: [220, 60, 255] // Tau: Magenta
    };

    // PMNS Matrix
    function getPMNS(theta13_use) {
      const c12 = Math.cos(theta12), s12 = Math.sin(theta12);
      const c13 = Math.cos(theta13_use), s13 = Math.sin(theta13_use);
      const c23 = Math.cos(theta23), s23 = Math.sin(theta23);
      return math.matrix([
        [c12 * c13, s12 * c13, s13],
        [-s12 * c23 - c12 * s23 * s13, c12 * c23 - s12 * s23 * s13, s23 * c13],
        [s12 * s23 - c12 * c23 * s13, -c12 * s23 - s12 * c23 * s13, c23 * c13]
      ]);
    }

    // Oscillation Calculation
    function computeProbabilities(alpha, L, E, matter=false, rho=2.6) {
      let theta13_use = theta13;
      let dm31_use = dm31;
      if (matter) {
        const A = 7.6e-5 * rho * E; // Matter potential in eV^2
        const cos2theta = Math.cos(2 * theta13);
        const sin2theta = Math.sin(2 * theta13);
        const denom = Math.sqrt((cos2theta - A / dm31)**2 + sin2theta**2);
        theta13_use = 0.5 * Math.asin(sin2theta / denom);
        dm31_use = dm31 * denom;
      }
      const U = getPMNS(theta13_use);
      const mSq = [0, dm21, dm31_use];
      const probs = [];
      for (let beta = 0; beta < 3; beta++) {
        let amplitude = math.complex(0, 0);
        for (let j = 0; j < 3; j++) {
          const phase = 1.267 * mSq[j] * L / E;
          const expTerm = math.exp(math.complex(0, -phase));
          const U_beta_j = U.get([beta, j]);
          const U_alpha_j = U.get([alpha, j]);
          const term = math.multiply(U_beta_j, U_alpha_j, expTerm);
          amplitude = math.add(amplitude, term);
        }
        probs[beta] = math.pow(math.abs(amplitude), 2);
      }
      return probs;
    }

    // Starfield
    let stars = [];
    function initStars(num=300) {
      stars = [];
      for (let i = 0; i < num; i++) {
        let r = random(200, 1000);
        let theta = random(0, Math.PI);
        let phi = random(0, 2*Math.PI);
        let x = r * Math.sin(theta) * Math.cos(phi);
        let y = r * Math.sin(theta) * Math.sin(phi);
        let z = r * Math.cos(theta);
        stars.push({x, y, z, px: x, py: y, pz: z});
      }
    }

    // Simulation State
    let t = 0;
    let speed = 1;
    let matter = false;
    let L = 0;
    let E_sim = 2.0;
    let initialFlavor = 0;
    let rho = 2.6;
    let probHistory = [];
    const probHistoryLen = 500;

    // p5.js Sketch
    function setup() {
      createCanvas(windowWidth, windowHeight, WEBGL);
      pixelDensity(1.5);
      initStars();
      const initialFlavorSelect = select('#initialFlavor');
      initialFlavorSelect.changed(() => {
        initialFlavor = parseInt(initialFlavorSelect.value());
        probHistory = [];
      });
      const energySlider = select('#energySlider');
      energySlider.input(() => {
        E_sim = float(energySlider.value());
        select('#energyValue').html(E_sim.toFixed(1));
        probHistory = [];
      });
      const speedSlider = select('#speedSlider');
      speedSlider.input(() => {
        speed = float(speedSlider.value());
        select('#speedValue').html(speed.toFixed(2)+'x');
      });
      const matterToggle = select('#matterToggle');
      matterToggle.changed(() => {
        matter = matterToggle.elt.checked;
        select('#densityControl').style('display', matter ? 'block' : 'none');
        probHistory = [];
        t = 0;
        L = 0;
      });
      const densitySlider = select('#density');
      densitySlider.input(() => {
        rho = float(densitySlider.value());
        select('#densityValue').html(rho.toFixed(1));
      });
      drawProbPlot([1,0,0]);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }

    function draw() {
      background(0);
      t += deltaTime * 0.001 * speed;
      L = (t * c * 1e-3) % LmaxSim;
      const probs = computeProbabilities(initialFlavor, L, E_sim, matter, rho);
      probHistory.push(probs);
      if (probHistory.length > probHistoryLen) probHistory.shift();
      push();
      let dx = 1, dy = 0.5, dz = 1;
      let norm = Math.sqrt(dx*dx + dy*dy + dz*dz);
      dx /= norm; dy /= norm; dz /= norm;
      let v = 8 * speed;
      for (let s of stars) {
        s.px = s.x; s.py = s.y; s.pz = s.z;
        s.x -= dx * v;
        s.y -= dy * v;
        s.z -= dz * v;
        if (s.x*dx + s.y*dy + s.z*dz < 0) {
          let r = random(600, 1000);
          let theta = random(0, Math.PI);
          let phi = random(0, 2*Math.PI);
          s.x = r * Math.sin(theta) * Math.cos(phi);
          s.y = r * Math.sin(theta) * Math.sin(phi);
          s.z = r * Math.cos(theta);
          s.px = s.x; s.py = s.y; s.pz = s.z;
        }
        stroke(255, 255, 255, 60);
        strokeWeight(1.5);
        line(s.px, s.py, s.pz, s.x, s.y, s.z);
        stroke(255, 255, 255, 180);
        strokeWeight(2.5);
        point(s.x, s.y, s.z);
      }
      pop();
      let col = [0,0,0];
      for (let i = 0; i < 3; i++) {
        col[0] += probs[i] * flavorColors[i][0];
        col[1] += probs[i] * flavorColors[i][1];
        col[2] += probs[i] * flavorColors[i][2];
      }
      push();
      noStroke();
      ambientLight(60,60,60);
      pointLight(255,255,255,0,0,200);
      fill(col[0], col[1], col[2]);
      sphere(32, 32, 32);
      pop();
      let maxIdx = probs.indexOf(Math.max(...probs));
      let flavorNames = ['Electron', 'Muon', 'Tau'];
      push();
      resetMatrix();
      textAlign(CENTER, TOP);
      textSize(28);
      fill(col[0], col[1], col[2]);
      text(flavorNames[maxIdx] + " neutrino", width/2, 40);
      pop();
      drawProbPlot(probs);
    }

    // Probability Plot
    function drawProbPlot(currentProbs) {
      let canvas = document.getElementById('probPlot');
      let ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(40, 10); ctx.lineTo(40, 110); ctx.lineTo(490, 110);
      ctx.stroke();
      let n = probHistory.length;
      let colors = [flavorColors[0], flavorColors[1], flavorColors[2]];
      for (let j = 0; j < 3; j++) {
        ctx.beginPath();
        for (let i = 0; i < n; i++) {
          let x = 40 + (i / (probHistoryLen-1)) * 440;
          let y = 110 - probHistory[i][j] * 90;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = `rgb(${colors[j][0]},${colors[j][1]},${colors[j][2]})`;
        ctx.lineWidth = 2.5;
        ctx.stroke();
      }
      for (let j = 0; j < 3; j++) {
        let x = 490;
        let y = 110 - currentProbs[j] * 90;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fillStyle = `rgb(${colors[j][0]},${colors[j][1]},${colors[j][2]})`;
        ctx.fill();
      }
      ctx.font = '16px Fira Mono, Consolas, monospace';
      ctx.fillStyle = '#fff';
      ctx.fillText('Probability', 200, 22);
      ctx.font = '14px Fira Mono, Consolas, monospace';
      ctx.fillStyle = `rgb(${flavorColors[0][0]},${flavorColors[0][1]},${flavorColors[0][2]})`;
      ctx.fillText('e', 60, 30);
      ctx.fillStyle = `rgb(${flavorColors[1][0]},${flavorColors[1][1]},${flavorColors[1][2]})`;
      ctx.fillText('μ', 90, 30);
      ctx.fillStyle = `rgb(${flavorColors[2][0]},${flavorColors[2][1]},${flavorColors[2][2]})`;
      ctx.fillText('τ', 120, 30);
      ctx.fillStyle = '#aaa';
      ctx.fillText('Time →', 400, 105);
    }
  </script>
</body>
</html>