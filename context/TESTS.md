# Testing Strategy: Imagining the Neutrino\n\n## 1. Overview\nThis document outlines the testing strategy for the \"Imagining the Neutrino\" project, utilizing the [Vitest](https://vitest.dev/) framework. The goal is to ensure the correctness of the physics calculations, the reliability of utility functions, and the basic integration of components. UI testing is currently minimal, focusing on the core logic.\n\n## 2. Testing Framework\n*   **Vitest:** Chosen for its speed, compatibility with Vite, and modern feature set (ESM support, TypeScript integration, Jest-compatible API).\n\n## 3. Types of Tests\n*   **Unit Tests:** Focus on testing individual functions or modules in isolation. This is the primary focus for the physics engine (`NuFastPort.ts`) and utility functions (`utils/*.ts`).\n*   **Integration Tests:** (Minimal/Future Scope) Could test the interaction between state changes and visualization updates, but are harder to implement comprehensively without E2E tools.\n*   **End-to-End (E2E) Tests:** (Out of Scope) Would involve tools like Playwright or Cypress to simulate user interactions in a real browser.\n\n## 4. Test Coverage\n*   **Goal:** Aim for high test coverage (>80-90%) for the `src/physics/` and `src/utils/` directories.\n*   **Measurement:** Use Vitest's built-in coverage reporting (`npm run coverage`). Configured in `vitest.config.ts`.\n\n## 5. Test Implementation Details\n\n### 5.1. Physics Engine (`tests/physics/NuFastPort.test.ts`)\n*   **Core Function (`calculateNuFastProbs`):**\n    *   **Reference Values:** (Currently Skipped) Ideally, tests should compare against known results or benchmark values from the NuFast paper or other simulation tools for specific parameter points.\n    *   **Vacuum Limit:** Test that setting `matterEffect = false` or `rho = 0` yields results consistent with vacuum oscillations.\n    *   **Edge Cases:** Test with L=0, E=0 (should return identity matrix). Test with specific mixing angles (e.g., 0, 45, 90 degrees) where simpler results might be expected.\n    *   **Symmetry/Unitarity Checks:** Verify that the probability matrix is unitary (rows and columns sum to 1 within numerical tolerance).\n    *   **Antineutrinos:** Test with negative energy `E` and verify differences compared to positive `E`, especially when `deltaCP` is non-trivial and matter effects are on.\n    *   **Matter Effects:** Test that enabling `matterEffect` with `rho > 0` produces results different from the vacuum case. Test with different `rho` values.\n    *   **Mass Ordering (NO vs IO):** Test with positive vs. negative `dm31sq` values and verify that results differ, particularly in matter.\n*   **Helper Function (`getProbabilitiesForInitialFlavor`):**\n    *   Verify it correctly extracts the specified row from the matrix returned by `calculateNuFastProbs`.\n    *   Verify the returned vector sums to 1.\n\n### 5.2. Utilities (`tests/utils/`)\n*   **`colorUtils.test.ts`:**\n    *   Test `getColorFromProbs` with pure states ([1,0,0], etc.) and mixed states ([0.5, 0.5, 0], etc.) to ensure correct color blending.\n    *   Test helper functions like `rgbToHex` if added.\n*   **`mathUtils.test.ts`:**\n    *   Test `degToRad` with known values (0, 90, 180, 360).\n    *   Test `mapRange` with various inputs.\n*   **`debounce.test.ts`:**\n    *   Test that the debounced function is called only once after the specified delay following rapid calls.\n\n## 6. Running Tests\n*   Use the npm scripts defined in `package.json`:\n    *   `npm test`: Run all tests once.\n    *   `npm run test:watch`: Run tests in interactive watch mode.\n    *   `npm run coverage`: Run tests and generate a coverage report in the `./coverage/` directory.\n\n## 7. Mocking\n*   Unit tests for physics and utils generally do not require mocking external libraries like Three.js or Plotly.js.\n*   If testing UI interaction logic directly (currently out of scope), mocking browser APIs (like `requestAnimationFrame`) or DOM elements might be needed using `vi.mock`.
