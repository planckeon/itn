Directory structure:
└── juliangarnier-anime/
    ├── README.md
    ├── examples/
    │   ├── additive-creature/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── additive-fireflies/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── advanced-grid-staggering/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── animatable-follow-cursor/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── animejs-v4-logo-animation/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── assets/
    │   │   └── css/
    │   │       └── styles.css
    │   ├── canvas-2d/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── clock-playback-controls/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── draggable-infinite-auto-carousel/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── draggable-mouse-scroll-snap-carousel/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── draggable-playground/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── easings-visualizer/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── irregular-playback-typewriter/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── layered-css-transforms/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── onscroll-responsive-scope/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── onscroll-sticky/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── svg-line-drawing/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── timeline-50K-stars/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── timeline-refresh-starlings/
    │   │   ├── index.html
    │   │   └── index.js
    │   ├── timeline-seamless-loop/
    │   │   ├── index.html
    │   │   └── index.js
    │   └── timeline-stress-test/
    │       ├── index.html
    │       └── index.js
    ├── src/
    │   ├── additive.js
    │   ├── animatable.js
    │   ├── animation.js
    │   ├── anime.js
    │   ├── clock.js
    │   ├── colors.js
    │   ├── compositions.js
    │   ├── consts.js
    │   ├── draggable.js
    │   ├── eases.js
    │   ├── engine.js
    │   ├── globals.js
    │   ├── helpers.js
    │   ├── properties.js
    │   ├── render.js
    │   ├── scope.js
    │   ├── scroll.js
    │   ├── spring.js
    │   ├── stagger.js
    │   ├── svg.js
    │   ├── targets.js
    │   ├── timeline.js
    │   ├── timer.js
    │   ├── transforms.js
    │   ├── types.js
    │   ├── units.js
    │   ├── utils.js
    │   ├── values.js
    │   └── waapi.js
    └── types/
        ├── index.d.ts
        └── index.js

================================================
FILE: README.md
================================================
# Anime.js

<p align="center">
  <picture align="center">
    <source media="(prefers-color-scheme: dark)" srcset="./assets/images/animejs-v4-logo-animation-dark.gif">
    <img align="center" alt="Anime.js V4 logo animation" src="./assets/images/animejs-v4-logo-animation.gif" width="560">
  </picture>
</p>

<p align="center">
  <strong>
  <em>Anime.js</em> is a fast, multipurpose and lightweight JavaScript animation library with a simple, yet powerful API.<br>
  It works with CSS properties, SVG, DOM attributes and JavaScript Objects.
  </strong>
</p>

<p align="center">
  <img alt="NPM Downloads" src="https://img.shields.io/npm/dm/animejs?style=flat-square&logo=npm">
  <img alt="jsDelivr hits (npm)" src="https://img.shields.io/jsdelivr/npm/hm/animejs?style=flat-square&logo=jsdeliver">
  <img alt="GitHub Sponsors" src="https://img.shields.io/github/sponsors/juliangarnier?style=flat-square&logo=github">
</p>

## Usage

Anime.js V4 works by importing ES modules like so:

<table>
<tr>
  <td>

```javascript
import {
  animate,
  stagger,
} from 'animejs';

animate('.square', {
  x: 320,
  rotate: { from: -180 },
  duration: 1250,
  delay: stagger(65, { from: 'center' }),
  ease: 'inOutQuint',
  loop: true,
  alternate: true
});
```

  </td>
  <td>
    <img align="center" alt="Anime.js code example" src="./assets/images/usage-example-result.gif">
  </td>
</tr>
</table>

## V4 Documentation

The full documentation is available [here](https://animejs.com/documentation).

## V3 Migration guide

You can find the v3 to v4 migration guide [here](https://github.com/juliangarnier/anime/wiki/Migrating-from-v3-to-v4).

## NPM development scripts

First, run `npm i` to install all the necessary packages.
Then, execute the following scripts with `npm run <script>`.

| script | action |
| ------ | ------ |
| `dev` | Watch any changes in `src/` and compiles the esm version to `lib/anime.esm.js` |
| `dev-types` | Same as `dev`, but also run TypeScript and generate the `types/index.d.ts` file |
| `build` | Generate types definition and compiles ESM / UMD / IIFE versions to `lib/` |
| `test-browser` | Start a local server and start all browser related tests |
| `test-node` | Start all Node related tests |
| `open-examples` | Start a local server to browse the examples locally |

## Our sponsors

Anime.js is 100% free and is only made possible with the help of our sponsors.
Help the project become sustainable by sponsoring us on <a target="_blank" href="https://github.com/sponsors/juliangarnier">GitHub Sponsors</a>.

### Platinum sponsors

<table>
  <tr>
    <td>
      <a target="_blank" href="https://huly.io/?ref=animejs">
        <picture>
          <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/huly-logomark.svg">
          <img align="center" src="./assets/sponsors/huly-logomark-dark.svg" width="128">
        </picture>
      </a>
    </td>
    <td>
      <a target="_blank" href="https://ice.io/?ref=animejs">
        <picture>
          <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/ice-open-network-logomark.svg">
          <img align="center" src="./assets/sponsors/ice-open-network-logomark-dark.svg" width="128">
        </picture>
      </a>
    </td>
    <td>
      <a target="_blank" href="https://github.com/sponsors/juliangarnier">
        <picture>
          <source media="(prefers-color-scheme: dark)" srcset="./assets/sponsors/placeholder.svg">
          <img align="center" src="./assets/sponsors/placeholder-dark.svg" width="128">
        </picture>
      </a>
    </td>
  </tr>
  <tr>
    <td align="center">
      <a target="_blank" href="https://huly.io/?ref=animejs">Huly</a>
    </td>
    <td align="center">
      <a target="_blank" href="https://ice.io/?ref=animejs">Ice Open Network</a>
    </td>
    <td align="center">
      <a target="_blank" href="https://github.com/sponsors/juliangarnier">Your logo here</a>
    </td>
  </tr>
</table>

© [Julian Garnier](http://juliangarnier.com) | [MIT License](LICENSE.md)


================================================
FILE: examples/additive-creature/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Additive creature / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #creature-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #creature {
      font-size: .2vh;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 150em;
      height: 150em;
      flex-wrap: wrap;
    }
    #creature div {
      transform-style: preserve-3d;
      position: relative;
      width: 4em;
      height: 4em;
      margin: 3em;
      border-radius: 2em;
      will-change: transform;
      mix-blend-mode: plus-lighter;
      /*mix-blend-mode: screen;*/
      /*mix-blend-mode: lighten;*/
      background: var(--red);
    }
  </style>
</head>
<body>
  <div id="creature-wrapper">
    <div id="creature"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/additive-creature/index.js
================================================
import { animate, createTimeline, createTimer, stagger, utils } from '../../lib/anime.esm.js';

const creatureEl = document.querySelector('#creature');
const viewport = { w: window.innerWidth * .5, h: window.innerHeight * .5 };
const cursor = { x: 0, y: 0 };
const rows = 13;
const grid = [rows, rows];
const from = 'center';
const scaleStagger = stagger([2, 5], { ease: 'inQuad', grid, from });
const opacityStagger = stagger([1, .1], { grid, from });

for (let i = 0; i < (rows * rows); i++) {
  creatureEl.appendChild(document.createElement('div'));
}

const particuleEls = creatureEl.querySelectorAll('div');

utils.set(creatureEl, {
  width: rows * 10 + 'em',
  height: rows * 10 + 'em'
});

utils.set(particuleEls, {
  x: 0,
  y: 0,
  scale: scaleStagger,
  opacity: opacityStagger,
  background: stagger([80, 20], { grid, from,
    modifier: v => `hsl(4, 70%, ${v}%)`,
  }),
  boxShadow: stagger([8, 1], { grid, from,
    modifier: v => `0px 0px ${utils.round(v, 0)}em 0px var(--red)`,
  }),
  zIndex: stagger([rows * rows, 1], { grid, from, modifier: utils.round(0) }),
});

const pulse = () => {
  animate(particuleEls, {
    keyframes: [
      {
        scale: 5,
        opacity: 1,
        delay: stagger(90, { start: 1650, grid, from }),
        duration: 150,
      }, {
        scale: scaleStagger,
        opacity: opacityStagger,
        ease: 'inOutQuad',
        duration: 600
      }
    ],
  });
}

const mainLoop = createTimer({
  frameRate: 15, // Animate to the new cursor position every 250ms
  onUpdate: () => {
    animate(particuleEls, {
      x: cursor.x,
      y: cursor.y,
      delay: stagger(40, { grid, from }),
      duration: stagger(120, { start: 750, ease: 'inQuad', grid, from }),
      ease: 'inOut',
      composition: 'blend', // This allows the animations to overlap nicely
    });
  }
});

const autoMove = createTimeline()
.add(cursor, {
  x: [-viewport.w * .45, viewport.w * .45],
  modifier: x => x + Math.sin(mainLoop.currentTime * .0007) * viewport.w * .5,
  duration: 3000,
  ease: 'inOutExpo',
  alternate: true,
  loop: true,
  onBegin: pulse,
  onLoop: pulse,
}, 0)
.add(cursor, {
  y: [-viewport.h * .45, viewport.h * .45],
  modifier: y => y + Math.cos(mainLoop.currentTime * .00012) * viewport.h * .5,
  duration: 1000,
  ease: 'inOutQuad',
  alternate: true,
  loop: true,
}, 0);

const manualMovementTimeout = createTimer({
  duration: 1500,
  onComplete: () => autoMove.play(),
});

const followPointer = e => {
  const event = e.type === 'touchmove' ? e.touches[0] : e;
  cursor.x = event.pageX - viewport.w;
  cursor.y = event.pageY - viewport.h;
  autoMove.pause();
  manualMovementTimeout.restart();
}

document.addEventListener('mousemove', followPointer);
document.addEventListener('touchmove', followPointer);




================================================
FILE: examples/additive-fireflies/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Additive fireflies / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
      cursor: grab;
      user-select: none;
    }
    body:active {
      cursor: grabbing;
    }
    #animation-wrapper {
      /*font-size: .065vh;*/
      font-size: .2vh;
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      color: var(--red);
    }
    #circle {
      opacity: .3;
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100em;
      height: 100em;
      margin: -50em 0 0 -50em;
      border-radius: 50%;
      will-change: transform, opacity
    }
    #circle:before,
    #circle:after {
      content: "";
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
    }
    #circle:before {
      z-index: 1;
      opacity: 1;
      box-shadow: inset 0px 0px 25em 0px currentColor,  0px 0px 10em 1px currentColor, 0px 0px 5em 1px currentColor;
    }
    #circle:after {
      z-index: 3;
      opacity: .75;
      box-shadow: inset 0 0 30em 0 currentColor;
      background-image: radial-gradient(circle at 50% 50%, currentColor 0%, transparent 100%);
    }
    .particle {
      opacity: .5;
      position: absolute;
      z-index: 2;
      top: 50%;
      left: 50%;
      width: 5em;
      height: 5em;
      margin: -2.5em 0 0 -2.5em;
      border-radius: 5em;
      will-change: transform;
      mix-blend-mode: plus-lighter;
      background: currentColor;
      box-shadow: 0px 0px 15em 0px currentColor, 0px 0px 5em 0px currentColor;
    }
  </style>
</head>
<body>
  <div id="animation-wrapper">
    <div id="circle"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/additive-fireflies/index.js
================================================
import { animate, createTimer, utils } from '../../lib/anime.esm.js';

const $animationWrapper = document.querySelector('#animation-wrapper');
const $circle = document.querySelector('#circle');
const viewport = {w: window.innerWidth * .5, h: window.innerHeight * .5};
const rows = 15;
const baseRadius = $circle.offsetWidth / 1.85;
const activeRadius = $circle.offsetWidth / .75;
const pointer = {x: 0, y: 0, isDown: false, radius: baseRadius};
const radiusTimeOut = createTimer({
  duration: 150,
  onComplete: () => pointer.radius = baseRadius
});

function animateParticule($el) {
  createTimer({
    frameRate: 4,
    onUpdate: () => {
      const angle = Math.random() * Math.PI * 2;
      const radius = pointer.isDown ? activeRadius : baseRadius;
      animate($el, {
        x: { to: (Math.cos(angle) * radius) + pointer.x, duration: () => utils.random(1000, 2000) },
        y: { to: (Math.sin(angle) * radius) + pointer.y, duration: () => utils.random(1000, 2000) },
        backgroundColor: '#FF0000',
        scale: .5 + utils.random(.1, 1, 2),
        duration: () => utils.random(1000, 1500),
        ease: `inOut(${utils.random(1, 5)})`,
        composition: 'blend'
      });
    }
  })
}

document.addEventListener('mousemove', e => {
  pointer.x = e.pageX - viewport.w;
  pointer.y = e.pageY - viewport.h;
  pointer.radius = (pointer.isDown ? activeRadius : baseRadius * 1.25);
  radiusTimeOut.restart();
  utils.set($circle, { translateX: pointer.x, translateY: pointer.y });
});

document.addEventListener('mousedown', e => {
  pointer.isDown = true;
  animate($circle, { scale: .5, opacity: 1, filter: 'saturate(1.25)' });
});

document.addEventListener('mouseup', e => {
  pointer.isDown = false;
  animate($circle, { scale: 1, opacity: .3, filter: 'saturate(1)' });
});

const colors = ['red', 'orange', 'lightorange'];

for (let i = 0; i < (rows * rows); i++) {
  const $particle = document.createElement('div');
  $particle.classList.add('particle');
  utils.set($particle, { color: `var(--${colors[utils.random(0, colors.length - 1)]})` });
  $animationWrapper.appendChild($particle);
  animateParticule($particle);
}



================================================
FILE: examples/advanced-grid-staggering/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Advanced grid staggering / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      --rows: 41;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .stagger-visualizer {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      width: calc(var(--rows) * 1rem);
      height: calc(var(--rows) * 1rem);
    }

    .stagger-visualizer .dot {
      position: relative;
      width: .25rem;
      height: .25rem;
      margin: .375rem;
      background-color: currentColor;
      border-radius: 50%;
    }

    .stagger-visualizer .cursor {
      position: absolute;
      z-index: 1;
      top: 0;
      left: 0;
      width: 1rem;
      height: 1rem;
      background-color: currentColor;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="stagger-visualizer">
    <div class="cursor red"></div>
  </div>
</body>
<script type="module" src="./index.js"></script>
</html>



================================================
FILE: examples/advanced-grid-staggering/index.js
================================================
import { createTimeline, utils, stagger } from '../../lib/anime.esm.js';

const staggerVisualizerEl = document.querySelector('.stagger-visualizer');
const fragment = document.createDocumentFragment();
const rows = +utils.get(document.body, '--rows');
const grid = [rows, rows];
const numberOfElements = rows * rows;
var animation;

for (let i = 0; i < numberOfElements; i++) {
  const dotEl = document.createElement('div');
  dotEl.classList.add('dot');
  fragment.appendChild(dotEl);
}

staggerVisualizerEl.appendChild(fragment);

let index = utils.random(0, numberOfElements);
let nextIndex = 0;

utils.set('.cursor', {
  x: stagger('-1rem', {grid, from: index, axis: 'x'}),
  y: stagger('-1rem', {grid, from: index, axis: 'y'})
});

function animateGrid() {

  if (animation) animation.pause();

  nextIndex = utils.random(0, numberOfElements);

  animation = createTimeline({
    defaults: {
      ease: 'inOutQuad',
    },
    onComplete: animateGrid
  })
  .add('.cursor', {
    keyframes: [
      { scale: .625 },
      { scale: 1.125 },
      { scale: 1 }
    ],
    duration: 600
  })
  .add('.dot', {
    keyframes: [
      {
        x: stagger('-.175rem', {grid, from: index, axis: 'x'}),
        y: stagger('-.175rem', {grid, from: index, axis: 'y'}),
        duration: 200
      }, {
        x: stagger('.125rem', {grid, from: index, axis: 'x'}),
        y: stagger('.125rem', {grid, from: index, axis: 'y'}),
        scale: 2,
        duration: 500
      }, {
        x: 0,
        y: 0,
        scale: 1,
        duration: 600,
      }
    ],
    delay: stagger(50, {grid, from: index}),
  }, 0)
  .add('.cursor', {
    x: { from: stagger('-1rem', {grid, from: index, axis: 'x'}), to: stagger('-1rem', {grid, from: nextIndex, axis: 'x'}), duration: utils.random(800, 1200) },
    y: { from: stagger('-1rem', {grid, from: index, axis: 'y'}), to: stagger('-1rem', {grid, from: nextIndex, axis: 'y'}), duration: utils.random(800, 1200) },
    ease: 'outCirc'
  }, '-=1500')

  index = nextIndex;

}

animateGrid();



================================================
FILE: examples/animatable-follow-cursor/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Animatable follow cursor / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      top: 0;
      left: 0;
      overflow: hidden;
      width: 100%;
      height: 100vh;
    }

    .particles {
      --size: 21;
      --diameter: 1em;
      --margin: 0em;
      font-size: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      width: calc(var(--size) * 1em);
      height: calc(var(--size) * 1em);
    }

    .particles div {
      position: relative;
      width: calc(var(--diameter) - var(--margin) * 2);
      height: calc(var(--diameter) - var(--margin) * 2);
      margin: var(--margin);
      background: var(--red);
      mix-blend-mode: plus-lighter;
      box-shadow: 0 0 10px 0 var(--red);
      border-radius: .5rem;
      opacity: .75;
    }
  </style>
</head>
<body>
  <div class="particles"></div>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/animatable-follow-cursor/index.js
================================================
import {
  createAnimatable,
  utils,
  stagger,
} from '../../lib/anime.esm.js';

// Setup

const [ $particles ] = utils.$('.particles');
const rows = /** @type {Number} */(utils.get($particles, '--size', false));

let w = window.innerWidth;
let h = window.innerHeight;
let hw = w / 2;
let hh = h / 2;

for (let i = 0; i < (rows * rows); i++) {
  $particles.appendChild(document.createElement('div'));
}

// Animations

const duration = stagger(50, { ease: 'in(1)', from: 'center', grid: [rows, rows] });

const particles = createAnimatable('.particles div', {
  x: { duration }, // Register the prop as animatable
  y: { duration }, // Register the prop as animatable
  rotate: { unit: 'rad', duration: 0 }, // Register the prop to be set without animation
  ease: 'outElastic(.3, 1.4)',
});

/** @param {PointerEvent} e */
window.onpointermove = e => {
  const { clientX, clientY } = e;
  particles.x(utils.mapRange(clientX, 0, w, -hw, hw));
  particles.y(utils.mapRange(clientY, 0, h, -hh, hh));
  particles.rotate(-Math.atan2(hw - clientX, hh - clientY));
}

// Responsive

window.onresize = () => {
  w = window.innerWidth;
  h = window.innerHeight;
  hw = w / 2;
  hh = h / 2;
}



================================================
FILE: examples/animejs-v4-logo-animation/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Logo animation V4 / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
/*      background: black;*/
    }
    #animejs-v4-logo {
      overflow: hidden;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      width: 640px;
      height: 360px;
/*      background: #252423;*/
/*      box-shadow: 0 0 0 1px rgba(255,255,255,.1);*/
    }
    #logo {
      position: relative;
      overflow: visible;
      top: -15%;
      width: 72%;
      height: auto;
    }
    #logo * {
      transform-box: fill-box;
    }
    #animejs-v4-logo svg#effects {
      display: none;
    }
    #sub-text {
      position: absolute;
      z-index: 1;
      bottom: 20%;
      left: 0;
      right: 0;
      font-family: PPSupplyMono-Regular;
      font-size: 18px;
      color: #FFF;
      letter-spacing: 1px;
      text-align: center;
      line-height: 26px;
      white-space: pre;
    }

    #sub-text span {
      opacity: 0;
      display: inline-block;
    }
    #four {
      filter: url('#blur');
    }
  </style>
</head>
<body>
  <div id="animejs-v4-logo">
    <div id="sub-text">AVAILABLE NOW AT ANIMEJS.COM</div>
<svg id="effects" xmlns="http://www.w3.org/2000/svg" version="1.1" class="filters">
  <defs>
    <filter id="blur">
      <feGaussianBlur in="SourceGraphic" stdDeviation="10,0" />
    </filter>
  </defs>
</svg>
<?xml version="1.0" encoding="UTF-8"?>
<svg id="logo" width="640px" height="360px" viewBox="0 0 640 360" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>logo-anime-v4</title>
    <g id="logo-anime-v4" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <polygon id="dot-1" fill="#FF4B4B" fill-rule="nonzero" points="309.202438 224.68 309.293324 207 332.173324 207 332.212438 224.68"></polygon>
        <path d="M166.22864,296.48 C159.555307,296.48 154.222659,296.003333 150.230697,295.05 C146.238735,294.096667 143.222342,292.536667 141.18152,290.37 C139.140697,288.203333 137.855844,285.256667 137.326962,281.53 C137.09327,279.883333 136.989578,278.236667 137.015886,276.59 L137,273.73 C137.004557,268.876667 137.825158,265.193333 139.461803,262.68 C141.098449,260.166667 143.966307,258.39 148.065379,257.35 C152.164451,256.31 158.15732,255.79 166.043987,255.79 L168.643987,255.79 C174.79732,255.79 179.671893,256.245 183.267705,257.155 C186.863517,258.065 189.589018,259.56 191.444208,261.64 L191.834208,261.64 L191.617088,255.53 C191.569029,253.97 191.51425,252.973333 191.452752,252.54 C191.157562,250.46 190.508986,248.943333 189.507024,247.99 C188.505062,247.036667 187.094224,246.408333 185.274508,246.105 C183.454793,245.801667 180.811602,245.65 177.344936,245.65 L174.744936,245.65 C170.671602,245.65 167.600943,245.845 165.532958,246.235 C163.464973,246.625 162.077736,247.231667 161.371249,248.055 C160.664762,248.878333 160.286065,250.026667 160.235157,251.5 L160.160506,251.89 L138.580506,251.89 L138.563765,249.94 C138.556022,245 139.608807,241.273333 141.722119,238.76 C143.835431,236.246667 147.486365,234.491667 152.674919,233.495 C157.863474,232.498333 165.441085,232 175.407752,232 L178.527752,232 C186.761085,232 193.229624,232.541667 197.933369,233.625 C202.637114,234.708333 206.253596,236.68 208.782815,239.54 C211.312035,242.4 212.970231,246.603333 213.757404,252.15 C214.077193,254.403333 214.259693,257.826667 214.304905,262.42 L214.311045,295.44 L191.821045,295.44 L191.994779,288.42 L191.734779,288.42 C190.209969,290.5 188.660845,292.103333 187.087406,293.23 C185.513967,294.356667 183.334146,295.18 180.547944,295.7 C177.761741,296.22 173.89864,296.48 168.95864,296.48 L166.22864,296.48 Z M176.344557,282.57 C181.024557,282.57 184.46355,282.375 186.661535,281.985 C188.85952,281.595 190.327273,280.945 191.064795,280.035 C191.802316,279.125 192.171931,277.76 192.173639,275.94 L192.286044,274.9 C192.311213,274.466667 192.268449,273.86 192.157753,273.08 C191.985559,271.866667 191.463339,270.935 190.591092,270.285 C189.718845,269.635 188.202605,269.18 186.042373,268.92 C183.882141,268.66 180.722025,268.53 176.562025,268.53 L175.132025,268.53 C170.452025,268.53 166.994441,268.746667 164.759272,269.18 C162.524103,269.613333 161.037758,270.285 160.300237,271.195 C159.562716,272.105 159.193101,273.47 159.191392,275.29 L159.208987,276.33 L159.263481,277.63 C159.447975,278.93 160.069162,279.948333 161.127041,280.685 C162.184921,281.421667 163.793977,281.92 165.954209,282.18 C168.114441,282.44 171.144557,282.57 175.044557,282.57 L176.344557,282.57 Z" id="a-1" fill="#FFF" fill-rule="nonzero"></path>
        <path d="M221.545347,233.04 L244.425347,233.04 L244.249049,242.79 L244.509049,242.79 C246.034429,240.103333 247.834756,237.98 249.91003,236.42 C251.985304,234.86 254.55541,233.733333 257.620347,233.04 C260.685283,232.346667 264.514418,232 269.107752,232 L270.277752,232 C277.037752,232 282.546665,232.65 286.804492,233.95 C291.062319,235.25 294.387625,237.46 296.78041,240.58 C299.173195,243.7 300.750875,247.946667 301.513449,253.32 C301.833238,255.573333 302.040907,258.563333 302.136455,262.29 L302.031045,295.44 L279.151045,295.44 L279.107151,263.07 C279.10886,261.25 279.017468,259.69 278.832974,258.39 C278.476286,255.876667 277.732104,253.991667 276.600426,252.735 C275.468749,251.478333 273.875495,250.633333 271.820664,250.2 C269.765832,249.766667 266.96175,249.55 263.408417,249.55 L261.978417,249.55 C257.47175,249.55 253.948881,250.07 251.409809,251.11 C248.870738,252.15 247.080205,253.731667 246.038211,255.855 C244.996218,257.978333 244.467362,260.816667 244.451645,264.37 L244.441045,295.44 L221.561045,295.44 L221.545347,233.04 Z" id="n-1" fill="#FFF" fill-rule="nonzero"></path>
        <polygon id="i-1" fill="#FFF" fill-rule="nonzero" points="309.281045 295.44 309.265347 233.04 332.145347 233.04 332.161045 295.44"></polygon>
        <path d="M339.785347,233.04 L362.665347,233.04 L362.489049,242.79 L362.749049,242.79 C364.609366,239.41 367.310895,236.766667 370.853638,234.86 C374.39638,232.953333 379.157752,232 385.137752,232 L386.697752,232 C393.977752,232 399.610088,233.061667 403.594761,235.185 C407.579434,237.308333 410.473343,240.753333 412.276486,245.52 L412.406486,245.52 C414.193575,241.013333 417.115558,237.633333 421.172435,235.38 C425.229313,233.126667 430.637752,232 437.397752,232 L438.827752,232 C444.981085,232 449.942182,232.606667 453.711043,233.82 C457.479904,235.033333 460.39061,237.07 462.443163,239.93 C464.495716,242.79 465.87868,246.733333 466.592056,251.76 C466.924145,254.1 467.118945,257.61 467.176455,262.29 L467.201045,295.44 L444.321045,295.44 L444.388702,262.94 C444.390411,261.12 444.299018,259.56 444.114525,258.26 C443.782436,255.92 443.115553,254.121667 442.113876,252.865 C441.112199,251.608333 439.797536,250.741667 438.169888,250.265 C436.542241,249.788333 434.428417,249.55 431.828417,249.55 L430.528417,249.55 C426.108417,249.55 422.774398,250.026667 420.52636,250.98 C418.278322,251.933333 416.778823,253.428333 416.027863,255.465 C415.276903,257.501667 414.905864,260.383333 414.914746,264.11 L414.941045,295.44 L392.061045,295.44 L391.998702,262.94 C392.086508,261.726667 392.001265,260.21 391.742974,258.39 C391.398586,255.963333 390.722478,254.1 389.714651,252.8 C388.706824,251.5 387.413828,250.633333 385.835664,250.2 C384.257499,249.766667 382.21175,249.55 379.698417,249.55 L378.398417,249.55 C373.89175,249.55 370.536065,250.026667 368.33136,250.98 C366.126655,251.933333 364.624082,253.406667 363.823639,255.4 C363.023196,257.393333 362.639715,260.34 362.673196,264.24 L362.681045,295.44 L339.801045,295.44 L339.785347,233.04 Z" id="m-1" fill="#FFF" fill-rule="nonzero"></path>
        <path d="M511.73864,296.48 C503.15864,296.48 496.290876,295.873333 491.135349,294.66 C485.979821,293.446667 481.961182,291.236667 479.079431,288.03 C476.19768,284.823333 474.332469,280.23 473.483797,274.25 C473.004114,270.87 472.784145,267.793333 472.823892,265.02 L472.733177,262.55 C472.716729,253.883333 473.874261,247.383333 476.205948,243.05 C478.537636,238.716667 482.217525,235.791667 487.245616,234.275 C492.273706,232.758333 499.467752,232 508.827752,232 L512.857752,232 C520.917752,232 527.476032,232.563333 532.532593,233.69 C537.589155,234.816667 541.539861,236.853333 544.384714,239.8 C547.229566,242.746667 549.02713,246.863333 549.777404,252.15 C550.134092,254.663333 550.292847,257.003333 550.25367,259.17 L550.337373,268.92 L495.217373,268.92 L495.252563,271 C495.177057,272.3 495.200802,273.383333 495.323797,274.25 C495.643587,276.503333 496.42202,278.171667 497.659098,279.255 C498.896176,280.338333 500.557648,281.053333 502.643513,281.4 C504.729378,281.746667 507.72231,281.92 511.62231,281.92 L514.09231,281.92 C518.338977,281.92 521.533487,281.681667 523.675839,281.205 C525.818191,280.728333 527.273645,279.991667 528.0422,278.995 C528.810754,277.998333 529.195886,276.59 529.197595,274.77 L529.160696,274.51 L550.610696,274.51 L550.627437,276.46 C550.610011,281.833333 549.395908,285.95 546.985127,288.81 C544.574347,291.67 540.913904,293.663333 536.003798,294.79 C531.093693,295.916667 524.47864,296.48 516.15864,296.48 L511.73864,296.48 Z M528.76848,257.09 L528.696392,254.75 C528.783628,254.143333 528.747299,253.276667 528.587404,252.15 C528.341413,250.416667 527.720511,249.095 526.724698,248.185 C525.728886,247.275 524.228306,246.625 522.222958,246.235 C520.21761,245.845 517.438269,245.65 513.884936,245.65 L511.284936,245.65 C506.691602,245.65 503.252467,245.996667 500.967531,246.69 C498.682594,247.383333 497.130822,248.51 496.312214,250.07 C495.493607,251.63 495.089029,253.97 495.098319,257.09 L528.76848,257.09 Z" id="e-1" fill="#FFF" fill-rule="nonzero"></path>
        <g id="line" transform="translate(302.000000, 220.000000)" opacity="0.49878293" stroke-width="24">
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.5029597,56.4129153 18.5029597,51.3214156" id="line-0" stroke="#FF4B4B"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 16.7027142,64.322527 12.8291348,55.2014156" id="line-0-1" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 20.0805137,62.5805329 24.3906645,53.2014156" id="line-0-2" stroke="#4BFFFD"></path>
            <path d="M18.5029605,81.0814156 C18.5029605,66.8963175 17.682265,65.8816401 16.0496411,55.2014156" id="line-0-3" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.7131958,61.4525182 19.6580351,55.2014156" id="line-0-4" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.6880928,63.504343 17.8717813,55.7769881" id="line-0-5" stroke="#4BFFFD"></path>
            <path d="M18.5029601,81.0814156 C18.5029601,66.8963175 18.5029601,62.7412408 18.5029601,55.9905556" id="line-0-6" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 27.1232611,61.4408336 35.7435626,57.3214156" id="line-1" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 11.5633347,48.9981227 0,38.822786" id="line-2" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 24.1585737,32.9688645 31.8267924,25.3214156" id="line-3" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 14.5029597,25.3214156 10.5029597,14.0449261" id="line-4" stroke="#4BFFFD"></path>
            <path d="M18.5029597,81.0814156 C18.5029597,66.8963175 18.5029597,9.08661174 18.5029597,0" id="line-5" stroke="#4BFFFD"></path>
        </g>
        <polygon id="dot-2" fill="#FFF" fill-rule="nonzero" opacity="0" points="585.36 224.68 587.96 207 610.84 207 608.37 224.68"></polygon>
        <path d="M94.78,296.44 C88.1066667,296.44 82.8416667,295.963333 78.985,295.01 C75.1283333,294.056667 72.3333333,292.496667 70.6,290.33 C68.8666667,288.163333 68,285.216667 68,281.49 C68,279.843333 68.13,278.196667 68.39,276.55 L68.78,273.69 C69.4733333,268.836667 70.8166667,265.153333 72.81,262.64 C74.8033333,260.126667 77.9233333,258.35 82.17,257.31 C86.4166667,256.27 92.4833333,255.75 100.37,255.75 L102.97,255.75 C109.123333,255.75 113.933333,256.205 117.4,257.115 C120.866667,258.025 123.38,259.52 124.94,261.6 L125.33,261.6 L125.98,255.49 C126.153333,253.93 126.24,252.933333 126.24,252.5 C126.24,250.42 125.806667,248.903333 124.94,247.95 C124.073333,246.996667 122.751667,246.368333 120.975,246.065 C119.198333,245.761667 116.576667,245.61 113.11,245.61 L110.51,245.61 C106.436667,245.61 103.338333,245.805 101.215,246.195 C99.0916667,246.585 97.6183333,247.191667 96.795,248.015 C95.9716667,248.838333 95.43,249.986667 95.17,251.46 L95.04,251.85 L73.46,251.85 L73.72,249.9 C74.4133333,244.96 75.995,241.233333 78.465,238.72 C80.935,236.206667 84.835,234.451667 90.165,233.455 C95.495,232.458333 103.143333,231.96 113.11,231.96 L116.23,231.96 C124.463333,231.96 130.855,232.501667 135.405,233.585 C139.955,234.668333 143.291667,236.64 145.415,239.5 C147.538333,242.36 148.6,246.563333 148.6,252.11 C148.6,254.363333 148.296667,257.786667 147.69,262.38 L143.01,295.4 L120.52,295.4 L121.69,288.38 L121.43,288.38 C119.61,290.46 117.833333,292.063333 116.1,293.19 C114.366667,294.316667 112.07,295.14 109.21,295.66 C106.35,296.18 102.45,296.44 97.51,296.44 L94.78,296.44 Z M106.87,282.53 C111.55,282.53 115.016667,282.335 117.27,281.945 C119.523333,281.555 121.083333,280.905 121.95,279.995 C122.816667,279.085 123.38,277.72 123.64,275.9 L123.9,274.86 C123.986667,274.426667 124.03,273.82 124.03,273.04 C124.03,271.826667 123.64,270.895 122.86,270.245 C122.08,269.595 120.628333,269.14 118.505,268.88 C116.381667,268.62 113.24,268.49 109.08,268.49 L107.65,268.49 C102.97,268.49 99.4816667,268.706667 97.185,269.14 C94.8883333,269.573333 93.3066667,270.245 92.44,271.155 C91.5733333,272.065 91.01,273.43 90.75,275.25 L90.62,276.29 L90.49,277.59 C90.49,278.89 90.9666667,279.908333 91.92,280.645 C92.8733333,281.381667 94.4116667,281.88 96.535,282.14 C98.6583333,282.4 101.67,282.53 105.57,282.53 L106.87,282.53 Z" id="a-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M159.1,233 L181.98,233 L180.42,242.75 L180.68,242.75 C182.586667,240.063333 184.688333,237.94 186.985,236.38 C189.281667,234.82 192.011667,233.693333 195.175,233 C198.338333,232.306667 202.216667,231.96 206.81,231.96 L207.98,231.96 C214.74,231.96 220.156667,232.61 224.23,233.91 C228.303333,235.21 231.315,237.42 233.265,240.54 C235.215,243.66 236.19,247.906667 236.19,253.28 C236.19,255.533333 235.973333,258.523333 235.54,262.25 L230.73,295.4 L207.85,295.4 L212.4,263.03 C212.66,261.21 212.79,259.65 212.79,258.35 C212.79,255.836667 212.313333,253.951667 211.36,252.695 C210.406667,251.438333 208.933333,250.593333 206.94,250.16 C204.946667,249.726667 202.173333,249.51 198.62,249.51 L197.19,249.51 C192.683333,249.51 189.086667,250.03 186.4,251.07 C183.713333,252.11 181.698333,253.691667 180.355,255.815 C179.011667,257.938333 178.08,260.776667 177.56,264.33 L173.14,295.4 L150.26,295.4 L159.1,233 Z" id="n-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <polygon id="i-2" fill="#FFF" fill-rule="nonzero" opacity="0" points="237.98 295.4 246.82 233 269.7 233 260.86 295.4"></polygon>
        <path d="M277.34,233 L300.22,233 L298.66,242.75 L298.92,242.75 C301.26,239.37 304.336667,236.726667 308.15,234.82 C311.963333,232.913333 316.86,231.96 322.84,231.96 L324.4,231.96 C331.68,231.96 337.161667,233.021667 340.845,235.145 C344.528333,237.268333 346.933333,240.713333 348.06,245.48 L348.19,245.48 C350.616667,240.973333 354.018333,237.593333 358.395,235.34 C362.771667,233.086667 368.34,231.96 375.1,231.96 L376.53,231.96 C382.683333,231.96 387.558333,232.566667 391.155,233.78 C394.751667,234.993333 397.373333,237.03 399.02,239.89 C400.666667,242.75 401.49,246.693333 401.49,251.72 C401.49,254.06 401.186667,257.57 400.58,262.25 L395.9,295.4 L373.02,295.4 L377.7,262.9 C377.96,261.08 378.09,259.52 378.09,258.22 C378.09,255.88 377.678333,254.081667 376.855,252.825 C376.031667,251.568333 374.84,250.701667 373.28,250.225 C371.72,249.748333 369.64,249.51 367.04,249.51 L365.74,249.51 C361.32,249.51 357.918333,249.986667 355.535,250.94 C353.151667,251.893333 351.44,253.388333 350.4,255.425 C349.36,257.461667 348.58,260.343333 348.06,264.07 L343.64,295.4 L320.76,295.4 L325.31,262.9 C325.57,261.686667 325.7,260.17 325.7,258.35 C325.7,255.923333 325.288333,254.06 324.465,252.76 C323.641667,251.46 322.471667,250.593333 320.955,250.16 C319.438333,249.726667 317.423333,249.51 314.91,249.51 L313.61,249.51 C309.103333,249.51 305.68,249.986667 303.34,250.94 C301,251.893333 299.288333,253.366667 298.205,255.36 C297.121667,257.353333 296.32,260.3 295.8,264.2 L291.38,295.4 L268.5,295.4 L277.34,233 Z" id="m-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M440.29,296.44 C431.71,296.44 424.928333,295.833333 419.945,294.62 C414.961667,293.406667 411.256667,291.196667 408.83,287.99 C406.403333,284.783333 405.19,280.19 405.19,274.21 C405.19,270.83 405.406667,267.753333 405.84,264.98 L406.1,262.51 C407.313333,253.843333 409.393333,247.343333 412.34,243.01 C415.286667,238.676667 419.381667,235.751667 424.625,234.235 C429.868333,232.718333 437.17,231.96 446.53,231.96 L450.56,231.96 C458.62,231.96 465.098333,232.523333 469.995,233.65 C474.891667,234.776667 478.553333,236.813333 480.98,239.76 C483.406667,242.706667 484.62,246.823333 484.62,252.11 C484.62,254.623333 484.446667,256.963333 484.1,259.13 L482.8,268.88 L427.68,268.88 L427.42,270.96 C427.16,272.26 427.03,273.343333 427.03,274.21 C427.03,276.463333 427.571667,278.131667 428.655,279.215 C429.738333,280.298333 431.298333,281.013333 433.335,281.36 C435.371667,281.706667 438.34,281.88 442.24,281.88 L444.71,281.88 C448.956667,281.88 452.185,281.641667 454.395,281.165 C456.605,280.688333 458.165,279.951667 459.075,278.955 C459.985,277.958333 460.57,276.55 460.83,274.73 L460.83,274.47 L482.28,274.47 L482.02,276.42 C481.24,281.793333 479.441667,285.91 476.625,288.77 C473.808333,291.63 469.865,293.623333 464.795,294.75 C459.725,295.876667 453.03,296.44 444.71,296.44 L440.29,296.44 Z M462.91,257.05 L463.17,254.71 C463.343333,254.103333 463.43,253.236667 463.43,252.11 C463.43,250.376667 462.996667,249.055 462.13,248.145 C461.263333,247.235 459.855,246.585 457.905,246.195 C455.955,245.805 453.203333,245.61 449.65,245.61 L447.05,245.61 C442.456667,245.61 438.968333,245.956667 436.585,246.65 C434.201667,247.343333 432.49,248.47 431.45,250.03 C430.41,251.59 429.673333,253.93 429.24,257.05 L462.91,257.05 Z" id="e-2" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <rect id="ground" fill="#252423" x="0" y="300" width="640" height="200"></rect>
        <path d="M477.57,317.5 C475.663333,317.5 474.103333,317.413333 472.89,317.24 L473.28,315.03 C474.666667,315.203333 476.183333,315.29 477.83,315.29 C479.91,315.29 481.535,314.878333 482.705,314.055 C483.875,313.231667 484.828333,311.78 485.565,309.7 C486.301667,307.62 486.973333,304.543333 487.58,300.47 L497.07,233 L499.8,233 L490.31,300.6 C489.703333,304.846667 488.923333,308.183333 487.97,310.61 C487.016667,313.036667 485.716667,314.791667 484.07,315.875 C482.423333,316.958333 480.256667,317.5 477.57,317.5 Z" id="j" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M534.26,296.31 C525.333333,296.31 518.616667,295.985 514.11,295.335 C509.603333,294.685 506.396667,293.45 504.49,291.63 C502.583333,289.81 501.63,286.993333 501.63,283.18 C501.63,281.966667 501.695,280.861667 501.825,279.865 C501.955,278.868333 502.106667,277.806667 502.28,276.68 L505.01,276.68 C504.576667,279.02 504.36,281.1 504.36,282.92 C504.36,286.04 505.205,288.358333 506.895,289.875 C508.585,291.391667 511.488333,292.431667 515.605,292.995 C519.721667,293.558333 525.94,293.84 534.26,293.84 L538.81,293.84 C546.436667,293.84 552.243333,293.363333 556.23,292.41 C560.216667,291.456667 563.033333,289.983333 564.68,287.99 C566.326667,285.996667 567.41,283.136667 567.93,279.41 C568.276667,277.243333 568.45,275.466667 568.45,274.08 C568.45,271.48 567.648333,269.508333 566.045,268.165 C564.441667,266.821667 561.581667,265.89 557.465,265.37 C553.348333,264.85 547.173333,264.546667 538.94,264.46 C530.533333,264.373333 524.141667,263.961667 519.765,263.225 C515.388333,262.488333 512.355,261.34 510.665,259.78 C508.975,258.22 508.13,256.01 508.13,253.15 C508.13,251.85 508.346667,249.856667 508.78,247.17 C509.3,243.183333 510.491667,240.128333 512.355,238.005 C514.218333,235.881667 517.316667,234.365 521.65,233.455 C525.983333,232.545 532.31,232.09 540.63,232.09 L543.88,232.09 C551.333333,232.09 557.096667,232.48 561.17,233.26 C565.243333,234.04 568.19,235.383333 570.01,237.29 C571.83,239.196667 572.74,241.926667 572.74,245.48 C572.74,246.866667 572.566667,248.903333 572.22,251.59 L569.62,251.59 C569.966667,249.163333 570.14,247.17 570.14,245.61 C570.14,242.663333 569.338333,240.41 567.735,238.85 C566.131667,237.29 563.466667,236.185 559.74,235.535 C556.013333,234.885 550.683333,234.56 543.75,234.56 L540.5,234.56 C532.7,234.56 526.828333,234.971667 522.885,235.795 C518.941667,236.618333 516.168333,237.918333 514.565,239.695 C512.961667,241.471667 511.9,244.136667 511.38,247.69 C511.033333,249.943333 510.86,251.633333 510.86,252.76 C510.86,255.186667 511.618333,257.028333 513.135,258.285 C514.651667,259.541667 517.403333,260.43 521.39,260.95 C525.376667,261.47 531.313333,261.773333 539.2,261.86 C547.866667,261.946667 554.431667,262.336667 558.895,263.03 C563.358333,263.723333 566.5,264.893333 568.32,266.54 C570.14,268.186667 571.05,270.613333 571.05,273.82 C571.05,275.206667 570.876667,277.156667 570.53,279.67 C569.923333,284.003333 568.645,287.34 566.695,289.68 C564.745,292.02 561.581667,293.71 557.205,294.75 C552.828333,295.79 546.653333,296.31 538.68,296.31 L534.26,296.31 Z" id="s" fill="#FFF" fill-rule="nonzero" opacity="0"></path>
        <path d="M498.143,233.835 L488.870344,300.178569 L488.788109,300.741361 L488.617463,301.83314 C488.588338,302.011345 488.558871,302.187668 488.529064,302.362111 L488.346146,303.386172 C487.847513,306.056727 487.262239,308.244854 486.594348,309.944941 C485.7171,312.177933 484.698132,313.776334 483.252421,314.72746 C481.797469,315.684665 479.913737,316.185 477.423,316.185 L476.965305,316.183252 C476.064438,316.176263 475.250752,316.148336 474.525127,316.099815 L474,316.059" id="j-line" stroke="#FFF" stroke-width="2.5" stroke-linecap="square" fill-rule="nonzero"></path>
        <path d="M571.056,250.2 L571.096942,249.864827 L571.188848,249.040441 L571.266572,248.270344 L571.330128,247.5547 L571.379533,246.893678 C571.386589,246.788069 571.393056,246.684742 571.398934,246.583702 L571.427142,246.004923 L571.441239,245.48118 L571.443,245.24 C571.443,241.962222 570.627859,239.516799 569.031141,237.844047 C567.399823,236.135047 564.665034,234.888305 560.806717,234.149478 C559.004982,233.804465 556.854978,233.536636 554.358335,233.346643 L553.267127,233.269985 L552.133502,233.202869 C551.941031,233.192479 551.746795,233.182487 551.550792,233.172893 L550.353596,233.120112 L549.114053,233.076902 C548.903936,233.070499 548.692055,233.064495 548.478412,233.05889 L547.175405,233.030058 L545.830123,233.010825 C545.146919,233.00361 544.447873,233 543.733,233 L539.760455,233.001167 C539.521331,233.001945 539.28393,233.003112 539.048254,233.004668 L537.654893,233.018665 L536.302944,233.041979 L534.992436,233.0746 C534.777473,233.080812 534.564238,233.087411 534.352731,233.094397 L533.104434,233.140956 L531.897646,233.196793 L530.732393,233.261898 C530.541647,233.27352 530.352633,233.285528 530.165352,233.297922 L529.062455,233.376906 C528.882105,233.390841 528.703489,233.40516 528.526606,233.419864 L527.486127,233.512703 C525.27686,233.723849 523.360848,233.999936 521.739345,234.340452 C517.628698,235.203687 514.748415,236.613616 513.07237,238.523528 C511.375564,240.457098 510.266013,243.301581 509.768327,247.113117 C509.744752,247.259284 509.721835,247.40332 509.699577,247.545222 L509.573921,248.37099 L509.464041,249.145324 L509.369918,249.868009 L509.291531,250.538831 L509.228861,251.157577 L509.181888,251.724033 L509.150592,252.237985 C509.13886,252.4818 509.133,252.705845 509.133,252.91 C509.133,255.466423 509.85986,257.367442 511.298022,258.694976 C512.789477,260.071704 515.632529,261.148002 519.808879,261.850952 L520.194106,261.914083 L520.996187,262.035412 L521.840419,262.150158 C522.273069,262.205884 522.721518,262.259139 523.185753,262.30992 L524.135268,262.408179 C524.297028,262.424006 524.46054,262.439557 524.625806,262.454832 L525.638426,262.543179 L526.693089,262.62491 L527.789772,262.700018 L528.928455,262.768495 L530.109115,262.830336 L531.331731,262.885533 L532.596281,262.93408 L534.571684,262.994417 L535.940974,263.026308 L537.352121,263.051526 L540.2438,263.087698 L542.321694,263.12265 L544.303468,263.167815 L545.571282,263.203605 L546.796423,263.243945 L548.554167,263.312992 L550.216007,263.392298 L551.782007,263.481875 L552.772795,263.547306 L553.721037,263.617312 L554.62675,263.691898 C554.774159,263.70471 554.919797,263.717714 555.063665,263.730909 L556.31067,263.854822 C556.443916,263.869164 556.575393,263.883697 556.7051,263.898422 L557.462118,263.989066 C561.778158,264.53425 564.827086,265.527462 566.636553,267.043501 C568.518609,268.62036 569.453,270.918456 569.453,273.84 C569.453,275.295679 569.274065,277.129762 568.921966,279.328925 C568.374778,283.250439 567.217246,286.306323 565.419606,288.482414 C563.590867,290.69615 560.558909,292.282097 556.350459,293.288466 C554.367104,293.762746 551.961272,294.120693 549.130238,294.363622 L548.048663,294.449331 C547.681491,294.476105 547.307669,294.501085 546.927193,294.524273 L545.765797,294.588462 C545.568902,294.598265 545.370342,294.607621 545.170116,294.61653 L543.94877,294.66462 C543.74188,294.671742 543.533322,294.678418 543.323097,294.684647 L542.041729,294.716673 L540.720306,294.738008 C540.496729,294.740674 540.271482,294.742895 540.044564,294.744671 L538.663,294.75 L534.113,294.75 L532.699126,294.74722 L530.655553,294.732616 L528.7046,294.705476 L527.455386,294.680411 L525.65864,294.632343 L524.512164,294.593309 L523.406746,294.54868 L522.342365,294.49845 L521.318999,294.442614 L520.336627,294.381167 L519.395229,294.314104 L518.494782,294.241421 L517.635265,294.163112 L516.816658,294.079172 C516.550604,294.050253 516.291366,294.020395 516.038938,293.989597 L515.302085,293.894382 C510.978527,293.302737 507.873924,292.19064 505.979904,290.490879 C504.021984,288.733771 503.063,286.102713 503.063,282.68 C503.063,281.25837 503.188903,279.694292 503.439757,277.986433 L503.5,277.59" id="s-line" stroke="#FFF" stroke-width="2.5" stroke-linecap="square" fill-rule="nonzero"></path>
        <path d="M585.36,224.68 L587.96,207 L610.84,207 L608.37,224.68 L585.36,224.68 Z M94.78,296.44 C88.1066667,296.44 82.8416667,295.963333 78.985,295.01 C75.1283333,294.056667 72.3333333,292.496667 70.6,290.33 C68.8666667,288.163333 68,285.216667 68,281.49 C68,279.843333 68.13,278.196667 68.39,276.55 L68.78,273.69 C69.4733333,268.836667 70.8166667,265.153333 72.81,262.64 C74.8033333,260.126667 77.9233333,258.35 82.17,257.31 C86.4166667,256.27 92.4833333,255.75 100.37,255.75 L102.97,255.75 C109.123333,255.75 113.933333,256.205 117.4,257.115 C120.866667,258.025 123.38,259.52 124.94,261.6 L125.33,261.6 L125.98,255.49 C126.153333,253.93 126.24,252.933333 126.24,252.5 C126.24,250.42 125.806667,248.903333 124.94,247.95 C124.073333,246.996667 122.751667,246.368333 120.975,246.065 C119.198333,245.761667 116.576667,245.61 113.11,245.61 L110.51,245.61 C106.436667,245.61 103.338333,245.805 101.215,246.195 C99.0916667,246.585 97.6183333,247.191667 96.795,248.015 C95.9716667,248.838333 95.43,249.986667 95.17,251.46 L95.04,251.85 L73.46,251.85 L73.72,249.9 C74.4133333,244.96 75.995,241.233333 78.465,238.72 C80.935,236.206667 84.835,234.451667 90.165,233.455 C95.495,232.458333 103.143333,231.96 113.11,231.96 L116.23,231.96 C124.463333,231.96 130.855,232.501667 135.405,233.585 C139.955,234.668333 143.291667,236.64 145.415,239.5 C147.538333,242.36 148.6,246.563333 148.6,252.11 C148.6,254.363333 148.296667,257.786667 147.69,262.38 L143.01,295.4 L120.52,295.4 L121.69,288.38 L121.43,288.38 C119.61,290.46 117.833333,292.063333 116.1,293.19 C114.366667,294.316667 112.07,295.14 109.21,295.66 C106.35,296.18 102.45,296.44 97.51,296.44 L94.78,296.44 Z M106.87,282.53 C111.55,282.53 115.016667,282.335 117.27,281.945 C119.523333,281.555 121.083333,280.905 121.95,279.995 C122.816667,279.085 123.38,277.72 123.64,275.9 L123.9,274.86 C123.986667,274.426667 124.03,273.82 124.03,273.04 C124.03,271.826667 123.64,270.895 122.86,270.245 C122.08,269.595 120.628333,269.14 118.505,268.88 C116.381667,268.62 113.24,268.49 109.08,268.49 L107.65,268.49 C102.97,268.49 99.4816667,268.706667 97.185,269.14 C94.8883333,269.573333 93.3066667,270.245 92.44,271.155 C91.5733333,272.065 91.01,273.43 90.75,275.25 L90.62,276.29 L90.49,277.59 C90.49,278.89 90.9666667,279.908333 91.92,280.645 C92.8733333,281.381667 94.4116667,281.88 96.535,282.14 C98.6583333,282.4 101.67,282.53 105.57,282.53 L106.87,282.53 Z M159.1,233 L181.98,233 L180.42,242.75 L180.68,242.75 C182.586667,240.063333 184.688333,237.94 186.985,236.38 C189.281667,234.82 192.011667,233.693333 195.175,233 C198.338333,232.306667 202.216667,231.96 206.81,231.96 L207.98,231.96 C214.74,231.96 220.156667,232.61 224.23,233.91 C228.303333,235.21 231.315,237.42 233.265,240.54 C235.215,243.66 236.19,247.906667 236.19,253.28 C236.19,255.533333 235.973333,258.523333 235.54,262.25 L230.73,295.4 L207.85,295.4 L212.4,263.03 C212.66,261.21 212.79,259.65 212.79,258.35 C212.79,255.836667 212.313333,253.951667 211.36,252.695 C210.406667,251.438333 208.933333,250.593333 206.94,250.16 C204.946667,249.726667 202.173333,249.51 198.62,249.51 L197.19,249.51 C192.683333,249.51 189.086667,250.03 186.4,251.07 C183.713333,252.11 181.698333,253.691667 180.355,255.815 C179.011667,257.938333 178.08,260.776667 177.56,264.33 L173.14,295.4 L150.26,295.4 L159.1,233 Z M269.7,233 L260.86,295.4 L237.98,295.4 L246.82,233 L269.7,233 Z M324.4,231.96 C331.68,231.96 337.161667,233.021667 340.845,235.145 C344.528333,237.268333 346.933333,240.713333 348.06,245.48 L348.19,245.48 C350.616667,240.973333 354.018333,237.593333 358.395,235.34 C362.771667,233.086667 368.34,231.96 375.1,231.96 L376.53,231.96 C382.683333,231.96 387.558333,232.566667 391.155,233.78 C394.751667,234.993333 397.373333,237.03 399.02,239.89 C400.666667,242.75 401.49,246.693333 401.49,251.72 C401.49,254.06 401.186667,257.57 400.58,262.25 L395.9,295.4 L373.02,295.4 L377.7,262.9 C377.96,261.08 378.09,259.52 378.09,258.22 C378.09,255.88 377.678333,254.081667 376.855,252.825 C376.031667,251.568333 374.84,250.701667 373.28,250.225 C371.72,249.748333 369.64,249.51 367.04,249.51 L365.74,249.51 C361.32,249.51 357.918333,249.986667 355.535,250.94 C353.151667,251.893333 351.44,253.388333 350.4,255.425 C349.36,257.461667 348.58,260.343333 348.06,264.07 L343.64,295.4 L320.76,295.4 L325.31,262.9 C325.57,261.686667 325.7,260.17 325.7,258.35 C325.7,255.923333 325.288333,254.06 324.465,252.76 C323.641667,251.46 322.471667,250.593333 320.955,250.16 C319.438333,249.726667 317.423333,249.51 314.91,249.51 L313.61,249.51 C309.103333,249.51 305.68,249.986667 303.34,250.94 C301,251.893333 299.288333,253.366667 298.205,255.36 C297.121667,257.353333 296.32,260.3 295.8,264.2 L291.38,295.4 L268.5,295.4 L277.34,233 L300.22,233 L298.66,242.75 L298.92,242.75 C301.26,239.37 304.336667,236.726667 308.15,234.82 C311.963333,232.913333 316.86,231.96 322.84,231.96 L324.4,231.96 Z M499.8,233 L490.31,300.6 C489.703333,304.846667 488.923333,308.183333 487.97,310.61 C487.016667,313.036667 485.716667,314.791667 484.07,315.875 C482.423333,316.958333 480.256667,317.5 477.57,317.5 C475.663333,317.5 474.103333,317.413333 472.89,317.24 L473.28,315.03 C474.666667,315.203333 476.183333,315.29 477.83,315.29 C479.91,315.29 481.535,314.878333 482.705,314.055 C483.875,313.231667 484.828333,311.78 485.565,309.7 C486.301667,307.62 486.973333,304.543333 487.58,300.47 L497.07,233 L499.8,233 Z M450.56,231.96 C458.62,231.96 465.098333,232.523333 469.995,233.65 C474.891667,234.776667 478.553333,236.813333 480.98,239.76 C483.406667,242.706667 484.62,246.823333 484.62,252.11 C484.62,254.623333 484.446667,256.963333 484.1,259.13 L482.8,268.88 L427.68,268.88 L427.42,270.96 C427.16,272.26 427.03,273.343333 427.03,274.21 C427.03,276.463333 427.571667,278.131667 428.655,279.215 C429.738333,280.298333 431.298333,281.013333 433.335,281.36 C435.371667,281.706667 438.34,281.88 442.24,281.88 L444.71,281.88 C448.956667,281.88 452.185,281.641667 454.395,281.165 C456.605,280.688333 458.165,279.951667 459.075,278.955 C459.985,277.958333 460.57,276.55 460.83,274.73 L460.83,274.47 L482.28,274.47 L482.02,276.42 C481.24,281.793333 479.441667,285.91 476.625,288.77 C473.808333,291.63 469.865,293.623333 464.795,294.75 C459.725,295.876667 453.03,296.44 444.71,296.44 L440.29,296.44 C431.71,296.44 424.928333,295.833333 419.945,294.62 C414.961667,293.406667 411.256667,291.196667 408.83,287.99 C406.403333,284.783333 405.19,280.19 405.19,274.21 C405.19,270.83 405.406667,267.753333 405.84,264.98 L406.1,262.51 C407.313333,253.843333 409.393333,247.343333 412.34,243.01 C415.286667,238.676667 419.381667,235.751667 424.625,234.235 C429.868333,232.718333 437.17,231.96 446.53,231.96 L450.56,231.96 Z M449.65,245.61 L447.05,245.61 C442.456667,245.61 438.968333,245.956667 436.585,246.65 C434.201667,247.343333 432.49,248.47 431.45,250.03 C430.41,251.59 429.673333,253.93 429.24,257.05 L462.91,257.05 L463.17,254.71 C463.343333,254.103333 463.43,253.236667 463.43,252.11 C463.43,250.376667 462.996667,249.055 462.13,248.145 C461.263333,247.235 459.855,246.585 457.905,246.195 C455.955,245.805 453.203333,245.61 449.65,245.61 Z M534.26,296.31 C525.333333,296.31 518.616667,295.985 514.11,295.335 C509.603333,294.685 506.396667,293.45 504.49,291.63 C502.583333,289.81 501.63,286.993333 501.63,283.18 C501.63,281.966667 501.695,280.861667 501.825,279.865 C501.955,278.868333 502.106667,277.806667 502.28,276.68 L505.01,276.68 C504.576667,279.02 504.36,281.1 504.36,282.92 C504.36,286.04 505.205,288.358333 506.895,289.875 C508.585,291.391667 511.488333,292.431667 515.605,292.995 C519.721667,293.558333 525.94,293.84 534.26,293.84 L538.81,293.84 C546.436667,293.84 552.243333,293.363333 556.23,292.41 C560.216667,291.456667 563.033333,289.983333 564.68,287.99 C566.326667,285.996667 567.41,283.136667 567.93,279.41 C568.276667,277.243333 568.45,275.466667 568.45,274.08 C568.45,271.48 567.648333,269.508333 566.045,268.165 C564.441667,266.821667 561.581667,265.89 557.465,265.37 C553.348333,264.85 547.173333,264.546667 538.94,264.46 C530.533333,264.373333 524.141667,263.961667 519.765,263.225 C515.388333,262.488333 512.355,261.34 510.665,259.78 C508.975,258.22 508.13,256.01 508.13,253.15 C508.13,251.85 508.346667,249.856667 508.78,247.17 C509.3,243.183333 510.491667,240.128333 512.355,238.005 C514.218333,235.881667 517.316667,234.365 521.65,233.455 C525.983333,232.545 532.31,232.09 540.63,232.09 L543.88,232.09 C551.333333,232.09 557.096667,232.48 561.17,233.26 C565.243333,234.04 568.19,235.383333 570.01,237.29 C571.83,239.196667 572.74,241.926667 572.74,245.48 C572.74,246.866667 572.566667,248.903333 572.22,251.59 L569.62,251.59 C569.966667,249.163333 570.14,247.17 570.14,245.61 C570.14,242.663333 569.338333,240.41 567.735,238.85 C566.131667,237.29 563.466667,236.185 559.74,235.535 C556.013333,234.885 550.683333,234.56 543.75,234.56 L540.5,234.56 C532.7,234.56 526.828333,234.971667 522.885,235.795 C518.941667,236.618333 516.168333,237.918333 514.565,239.695 C512.961667,241.471667 511.9,244.136667 511.38,247.69 C511.033333,249.943333 510.86,251.633333 510.86,252.76 C510.86,255.186667 511.618333,257.028333 513.135,258.285 C514.651667,259.541667 517.403333,260.43 521.39,260.95 C525.376667,261.47 531.313333,261.773333 539.2,261.86 C547.866667,261.946667 554.431667,262.336667 558.895,263.03 C563.358333,263.723333 566.5,264.893333 568.32,266.54 C570.14,268.186667 571.05,270.613333 571.05,273.82 C571.05,275.206667 570.876667,277.156667 570.53,279.67 C569.923333,284.003333 568.645,287.34 566.695,289.68 C564.745,292.02 561.581667,293.71 557.205,294.75 C552.828333,295.79 546.653333,296.31 538.68,296.31 L534.26,296.31 Z" id="final-logo" fill="#00FF5D" fill-rule="nonzero" opacity="0"></path>
        <path d="M587.970588,316.9 L591.044118,294.738235 L510,294.738235 L514.691176,261.091176 L595.411765,206.9 L632.941176,206.9 L623.720588,272.091176 L639.735294,272.091176 L636.5,294.738235 L620.485294,294.738235 L617.411765,316.9 L587.970588,316.9 Z M538.632353,272.091176 L594.279412,272.091176 L600.102941,230.841176 L599.617647,230.841176 L538.632353,271.605882 L538.632353,272.091176 Z" id="four" fill="#FF4B4B" fill-rule="nonzero"></path>
    </g>
</svg>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/animejs-v4-logo-animation/index.js
================================================
import { createTimeline, stagger, svg, utils, eases } from '../../lib/anime.esm.js';

const [ $dot1 ] = utils.$('#dot-1');
const onions = [];

for (let i = 0; i < 4; i++) {
  const $clone = $dot1.cloneNode();
  $clone.id = 'dot-1-' + i;
  utils.set($clone, { opacity: 0 });
  $dot1.parentNode.appendChild($clone);
  onions.push($clone);
}

utils.set(onions, {
  transformOrigin: '100% 50% 0px'
});
utils.set(['#a-1', '#n-1', '#i-1', '#m-1', '#e-1', '#dot-1', '#line', '#line-0'], {
  transformOrigin: '50% 100% 0px',
});
utils.set('#four', {
  transformOrigin: '50% 50% 0px',
});
utils.set('#dot-1', {
  translateY: 70,
  scaleY: 3.5,
});
utils.set(['#dot-1', '#line path', '#four', ...onions], {
  opacity: 0,
});
utils.set(['#line', '#line-0'], {
  opacity: 1,
});

const splashCurve = eases.cubicBezier(0.225, 1, 0.915, 0.980);
const sweechCurve = eases.outElastic(1.1, 0.9);

const tl = createTimeline({
  // autoplay: false
  // loop: 3,
  // loopDelay: 2000,
});
tl.label('FALL')
tl.add('#line-0', {
  translateY: {to: [-280, 19], ease: 'inQuart', duration: 320 },
  scaleY: { to: [3, 1.75], ease: 'outElastic(1, 1.4)', duration: 300, delay: 320 },
  scaleX: { to: [.8, 1], ease: 'outElastic(1, 1.4)', duration: 650, delay: 320 },
  d: [
    { to: svg.morphTo('#line-0-1', 0), delay: 320, duration: 60, ease: 'inQuad' },
    { to: svg.morphTo('#line-0-2', 0), duration: 80 },
    { to: svg.morphTo('#line-0-3', 0), duration: 90 },
    { to: svg.morphTo('#line-0-4', 0), duration: 90 },
    { to: svg.morphTo('#line-0-6', 0), duration: 140 },
  ],
  ease: 'inOutQuad',
})
.label('WIGGLE')
.add('#line-0', {
  d: [
    { to: svg.morphTo('#line-1', 0), duration: 340, ease: 'inOutQuad' },
    { to: svg.morphTo('#line-2', 0), duration: 260 },
    { to: svg.morphTo('#line-3', 0), duration: 180 },
    { to: svg.morphTo('#line-4', 0), duration: 180 },
    { to: svg.morphTo('#line-5', 0), duration: 340, ease: 'outSine' }
  ],
  translateY: { to: 0, duration: 500 },
  scaleX: { to: .9, delay: 750, duration: 550, ease: 'outQuad' },
  scaleY: 1,
  duration: 900,
})
.label('POP')
.set('#line', { opacity: 0 }, 'POP')
.set('#dot-1', { opacity: 1, transformOrigin: '50% 50% 0px' }, 'POP')
.add(['#a-1', '#n-1', '#i-1', '#m-1', '#e-1'], {
  translateY: [
    { to: [35, -80], duration: 190, ease: splashCurve },
    { to: 4, duration: 120, delay: 20, ease: 'inQuad' },
    { to: 0, duration: 120, ease: 'outQuad' }
  ],
  scaleX: [
    { to: [.25, .85], duration: 190, ease: 'outQuad' },
    { to: 1.08, duration: 120, delay: 85, ease: 'inOutSine' },
    { to: 1, duration: 260, delay: 25, ease: 'outQuad' }
  ],
  scaleY: [
    { to: [.4, 1.5], duration: 120, ease: 'outSine' },
    { to: .6, duration: 120, delay: 180, ease: 'inOutSine' },
    { to: 1.2, duration: 180, delay: 25, ease: 'outQuad' },
    { to: 1, duration: 190, delay: 15, ease: 'outQuad' }
  ],
  duration: 400,
  ease: 'outSine',
}, stagger(80, { from: 'center' }))
.add('#dot-1', {
  translateY: [
    { to: [30, -170], duration: 240, ease: splashCurve },
    { to: 35, duration: 180, delay: 120, ease: 'inQuad' },
    { to: -50, duration: 250, ease: splashCurve },
    { to: 5, duration: 170, delay: 20, ease: 'inQuad' },
    { to: 0, duration: 120, ease: 'outQuad' }
  ],
  scaleX: { to: [1.1, 1], duration: 260, ease: 'outQuad' },
  scaleY: { to: [4, 1], duration: 190, ease: 'outQuad' },
  rotate: [
    { to: '+=.75turn', duration: 480, ease: 'outSine' },
    { to: '+=.25turn', duration: 420, delay: 160, ease: 'outSine' },
  ],
  ease: 'outSine',
}, 'POP')
.add('#logo', {
  scale: [1.3, 1],
  translateY: [-23, 0],
  duration: 1000,
  ease: 'outExpo',
}, 'POP')
.add('#i-1', {
  scaleY: [
    { to: .25, duration: 150, ease: 'outExpo' },
    { to: 1, duration: 700, delay: 0, ease: 'outElastic(2.11, 0.61)' },
  ],
  scaleX: [
    { to: 1.5, duration: 50, ease: 'outSine' },
    { to: 1, duration: 900, delay: 0, ease: 'outElastic(2.11, 0.61)' },
  ],
}, '<<+=380')
.label('SWEECH', '-=290')
.add('#dot-1', {
  ease: sweechCurve,
  duration: 900,
  points: svg.morphTo('#dot-2', 0),
}, 'SWEECH')
.add(onions, {
  opacity: stagger([1, .4]),
  ease: sweechCurve,
  scaleX: [4, 1],
  duration: 900,
  points: svg.morphTo('#dot-2', 0),
  delay: stagger(18)
}, 'SWEECH');

const sweechParams = {
  ease: sweechCurve,
  duration: 900,
}

tl
.add('#a-1', { d: svg.morphTo('#a-2', 0), ...sweechParams }, 'SWEECH+=00')
.add('#n-1', { d: svg.morphTo('#n-2', 0), ...sweechParams }, 'SWEECH+=10')
.add('#i-1', { points: svg.morphTo('#i-2', 0), ...sweechParams }, 'SWEECH+=20')
.add('#m-1', { d: svg.morphTo('#m-2', 0), ...sweechParams }, 'SWEECH+=30')
.add('#e-1', { d: svg.morphTo('#e-2', 0), ...sweechParams }, 'SWEECH+=40')
.add(svg.createDrawable(['#j-line', '#s-line']), {
  opacity: [.25, 1],
  draw: '0 1',
  duration: 620,
  ease: 'outQuint',
  delay: stagger(40)
}, 'SWEECH+=250')
.label('FOUR', '<+=80')
.add('#four', {
  fill: { from: '#FFF', delay: 600, ease: 'out(2)', duration: 900 },
  opacity: { to: [0, 1], duration: 350, ease: 'out(1)' },
  scale: { to: [1.75, 1], duration: 1400, ease: 'inOutExpo' },
}, 'FOUR')
.add('#blur feGaussianBlur', {
  stdDeviation: ['15,15', '0,0'],
  ease: 'out(2)',
  duration: 1000,
}, '<<')
.set(['#j', '#s'], { opacity: 1 }, '<<')
.set(['#j-line', '#s-line', ...onions], { opacity: 0 }, '<<')
.add(['#a-1', '#n-1', '#i-1', '#m-1', '#e-1', '#j', '#s', '#dot-1'],  {
  translateX: '-=68',
  ease: 'inOutQuint',
  duration: 1250,
  delay: stagger(14),
}, '<<')

const chars = ' !#%&"()*+×,.:;-_=><?@[]^/{|}.-~—0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const charsLength = chars.length;

function wrapInSpan(targetDiv) {
  let target = document.querySelector(targetDiv);
  let text = target.textContent;
  let wrappedText = '';

  for (let char of text) {
    wrappedText += `<span>${char === ' ' ? '&nbsp;' : char}</span>`;
  }

  target.innerHTML = wrappedText;
}

wrapInSpan('#sub-text');

tl.label('TEXT', '<-=600')
.add('#sub-text span', {
  opacity: [
    { to: .9, duration: 200 },
    // { to: .9, duration: 1000 }
  ],
  textContent: {
    to: $el => [0, chars.indexOf($el.textContent)],
    modifier: v => { const c = chars[utils.round(v, 0)]; return c ? c : ' ' },
  },
  duration: 800,
  ease: 'inOutExpo',
  delay: stagger(30, { from: 'center', ease: 'inOut(2)' }),
}, 'TEXT')

// .add('#sub-text span', {
//   opacity: [
//     { to: 1, duration: 100 },
//     { to: .7, duration: 1000 }
//   ],
//   ease: 'out(3)',
//   delay: stagger(20, { ease: 'inQuad' }),
// }, '<-=800')

.label('OUTRO', '+=1000')

.add('#four',  {
  translateX: '-=250',
  ease: 'inOutExpo',
  duration: 750,
}, 'OUTRO')

.add(['#j', '#s', '#dot-1'], {
  opacity: 0,
  duration: 620,
  ease: 'outQuint',
}, 'OUTRO')

.add(['#a-1', '#n-1', '#i-1', '#m-1', '#e-1'],  {
  translateY: 80,
  duration: 300,
  ease: 'outQuint',
  delay: stagger(30, { start: 300, from: 'last' }),
}, 'OUTRO')

.add('#sub-text span', {
  textContent: {
    to: $el => [chars.indexOf($el.textContent), 0],
    modifier: v => { const c = chars[utils.round(v, 0)]; return c ? c : ' ' },
  },
  duration: 800,
  ease: 'inOutExpo',
  delay: stagger(30, { from: 'center', reversed: true, ease: 'inOut(2)' }),
}, '<<+=200')
.add('#four', {
  opacity: { to: 0, duration: 650, ease: 'out(1)' },
}, '<<+=750')
.add('#blur feGaussianBlur', {
  stdDeviation: '15,15',
  ease: 'out(2)',
  duration: 750,
}, '<<')

.init();



================================================
FILE: examples/assets/css/styles.css
================================================
:root {
  --black: #252423;
  --white: #F6F4F2;
  --red: #FF4B4B;
  --orange: #FF8F42;
  --lightorange: #FFC730;
  --yellow: #F6FF56;
  --citrus: #A4FF4F;
  --green: #18FF74;
  --darkgreen: #00D672;
  --turquoise: #3CFFEC;
  --skyblue: #61C3FF;
  --kingblue: #5A87FF;
  --lavender: #8453E3;
  --purple: #C26EFF;
  --pink: #FB89FB;
}

*, *:before, *:after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  border: 0;
  font: inherit;
  vertical-align: baseline;
}

html,
body {
  background-color: var(--black);
  color: var(--white);
  font-family: sans-serif;
}

.black { color: var(--black); }
.white { color: var(--white); }
.red { color: var(--red); }
.blue { color: var(--skyblue); }
.green { color: var(--green); }

.grid {
  --one-cell: 100px;
  --border-color: rgba(255,255,255,.75);
  flex-grow: 1;
  position: relative;
  width: 100%;
  height: 100%;
  padding: 0;
}

.grid:before {
  content: "";
  pointer-events: none;
  position: absolute;
  z-index: 0;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background:
    linear-gradient(-90deg, rgba(255,255,255,.05) 1px, transparent 1px),
    linear-gradient(rgba(255,255,255,.05) 1px, transparent 1px),
    linear-gradient(-90deg, rgba(255,255,255,.04) 1px, transparent 1px),
    linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px);
  background-size:
    calc(var(--one-cell) / 10) calc(var(--one-cell) / 10),
    calc(var(--one-cell) / 10) calc(var(--one-cell) / 10),
    var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell),
    var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell);
  background-position: 0 -1px;
  backface-visibility: hidden;
}

.grid:before {
  width: calc(75px + 100%);
  left: -75px;
}

@media (min-width: 500px) {
  .grid:before {
    width: 100%;
    left: 0;
  }
}

.log {
  --width: 22ch;
  --height: 20ch;
  position: fixed;
  z-index: 10;
  top: 0;
  overflow-y: scroll;
  width: var(--width);
  height: var(--height);
  padding-left: 1ch;
  padding-right: 1ch;
  padding-bottom: 1ch;
  font-family: ui-monospace, monospace;
  white-space: pre;
  background-color: rgba(0, 0, 0, .5);
}
.log span {
  animation: reveal 2s ease-in-out forwards;
}
@keyframes reveal {
  from { opacity: 1; }
  to { opacity: .4; }
}


================================================
FILE: examples/canvas-2d/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Canvas 2d animation / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      width: 100%;
      height: 100%;
      background: #000;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }
  </style>
</head>
<body>
  <canvas></canvas>
</body>
<script type="module" src="./index.js"></script>
</html>



================================================
FILE: examples/canvas-2d/index.js
================================================
import { animate, createTimer, utils } from '../../lib/anime.esm.js';

const canvasEl = document.querySelector('canvas');
const ctx = canvasEl.getContext('2d', { alpha: false });
const maxParticules = Number(location.href.split('?')[1]) || 4000;
const colors = ['#FF4B4B','#FF8F42','#FFC730','#F6FF56'];
const viewport = { width: 0, height: 0 };
const particules = [];
const squarePi = 2 * 2 * Math.PI;

function setCanvasSize() {
  const { innerWidth, innerHeight } = window;
  const ratio = 2;
  canvasEl.width = innerWidth * ratio;
  canvasEl.height = innerHeight * ratio;
  canvasEl.style.width = innerWidth + 'px';
  canvasEl.style.height = innerHeight + 'px';
  canvasEl.getContext('2d').scale(ratio, ratio);
  viewport.width = innerWidth;
  viewport.height = innerHeight;
}

function createParticule(x, y) {
  return {
    x,
    y,
    color: utils.randomPick(colors),
    radius: 1,
  }
}

function drawParticule(p) {
  ctx.beginPath();
  ctx.fillStyle = p.color;
  ctx.arc(p.x, p.y, p.radius, 0, squarePi, true);
  ctx.fill();
}

setCanvasSize();
window.addEventListener('resize', setCanvasSize);

function animateParticule(p, i) {
  const newX = utils.random(0, viewport.width);
  const diffX = newX - p.x;
  const durX = Math.abs(diffX * 20);
  const newY = utils.random(0, viewport.height);
  const diffY = newY - p.y;
  const durY = Math.abs(diffY * 20);
  animate(p, {
    x: { to: newX, duration: durX },
    y: { to: newY, duration: durY },
    radius: utils.random(2, 6),
    ease: 'out(1)',
    onComplete: () => { animateParticule(p, i); }
  });
}

for (let i = 0; i < maxParticules; i++) {
  const p = createParticule(viewport.width * .5, viewport.height * .5);
  particules.push(p);
  animateParticule(p, i);
}

createTimer({
  onUpdate: self => {
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = .1;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, viewport.width, viewport.height);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'screen';
    for (let i = 0; i < maxParticules; i++) {
      drawParticule(particules[i]);
    }
  },
})




================================================
FILE: examples/clock-playback-controls/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Clock playback controls / anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      font-family: BerkeleyMono-Regular, monospace;
    }
    #clock {
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      width: 40ch;
      height: 20ch;
      padding: 4ch;
      border-radius: 4ch;
/*      background: #202020;*/
    }
    #digital {
      perspective: 1000px;
      display: flex;
      gap: 1ch;
      height: 4ch;
      margin-top: 4ch;
      margin-bottom: 4ch;
    }
    #digital::after {
      content: "";
      display: block;
      position: absolute;
      top: -150%;
      left: -50%;
      width: 200%;
      height: 400%;
      background-image: linear-gradient(180deg, #1a1a1a 10%, #1a1a1a66 30%, #1a1a1a00 40%, #1a1a1a00 60%,#1a1a1a66 70%, #1a1a1a 90%);
    }
    .slot {
      position: relative;
      width: 1ch;
      height: 2ch;
      color: #fff;
      display: flex;
      transform-style: preserve-3d;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 2em;
    }
    .colon {
      transform: translateZ(3ch);
    }
    .numbers > div {
      position: absolute;
      transform-style: preserve-3d;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
      transform-origin: center center 0px;
    }
    #parameters {
      position: fixed;
      right: 0;
      top: 0;
      width: 100%;
      padding: 3ch;
    }
    fieldset {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: .5ch;
      margin-bottom: 1ch;
    }
    fieldset > input {
      min-width: 0;
      border-radius: .1ch;
      accent-color: white;
      color: white;
      text-align: right;
      background: transparent;
    }
    fieldset > label {
      flex-shrink: 0;
      width: 10ch;
    }
    fieldset > .value {
      width: 16ch;
    }
    fieldset > .range {
      width: 100%;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      position: fixed;
      bottom: 0;
      width: 100%;
      padding: 3ch;
    }
    #controls button {
      width: 20%;
      flex-grow: 1;
      flex-shrink: 0;
      height: 4ch;
      min-width: 0;
      border-radius: 1ch;
      margin: .5ch;
      background-color: #2A2A2A;
      color: #FFF;
    }
    #controls button:hover {
      background-color: #3A3A3A;
    }
    #controls button:focus {
      background-color: #FFF;
      color: #2A2A2A;
    }
  </style>
</head>
<body>
  <div id="clock">
    <div id="digital"></div>
  </div>
  <div id="parameters">
    <fieldset id="currentTime">
      <label>currentTime</label>
      <input class="value" type="text" />
      <input class="range" type="range" min="0" max="86400000" step="1" />
    </fieldset>
    <fieldset id="speed">
      <label>speed</label>
      <input class="value" type="text" value="1" />
      <input class="range" type="range" min=".01" max="2" step=".01" value="1" />
    </fieldset>
  </div>
  <div id="controls">
    <button id="play">PLAY</button>
    <button id="pause">PAUSE</button>
    <button id="reverse">REVERSE</button>
    <button id="alternate">ALTERNATE</button>
    <button id="slowmo">SLOW MO</button>
    <button id="speedup">SPEED UP</button>
    <button id="normalspeed">NORMAL SPEED</button>
    <button id="reset">RESET</button>
    <button id="resume">RESUME</button>
    <button id="seek">SEEK</button>
    <button id="complete">COMPLETE</button>
    <button id="restart">RESTART</button>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/clock-playback-controls/index.js
================================================
import { animate, createTimeline, utils } from '../../lib/anime.esm.js';

const [ $digitalClock ] = utils.$('#digital');

const s = 1000;
const m = 60*s;
const h = 60*m;
const oneday = h * 24;

const masterTL = createTimeline({ defaults: { ease: 'linear' }, autoplay: false });

[h * 10, h, 0, m * 10, m, 0, s * 10, s, 0, 100, 10].forEach(d => {
  const $el = document.createElement('div');
  $digitalClock.appendChild($el);
  $el.classList.add('slot');
  if (!d) {
    $el.classList.add('colon');
    $el.textContent = ':';
  } else {
    $el.classList.add('numbers');
    for (let i = 0; i < 10; i++) {
      const $num = document.createElement('div');
      $num.textContent = `${i}`;
      utils.set($num, { rotateX: (i * 36), z: '3ch' });
      $el.appendChild($num);
    }
    const canStop = d > 100;
    const ease = canStop ? 'cubicBezier(1,0,.6,1.2)' : 'linear';
    const duration = canStop ? 650 : d;
    const position = `+=${canStop ? d - 650 : 0}`;
    const numTL = createTimeline({ defaults: { ease }, loop: true });
    const t = d === h*10 ? 4 : d === h ? 25 : d === m*10 || d === s*10 ? 7 : 11;
    for (let i = 1; i < t; i++) {
      const rotateX = -((i * 36) + (i === t - 1 ? (360 - i * 36) : 0));
      numTL.add($el, { rotateX, duration }, d === h*10 && i === t - 1 ? '+=' + ((h * 4) - 650) : position);
    }
    masterTL.sync(numTL, 0);
  }
});

masterTL.duration = oneday;
masterTL.iterationDuration = oneday;

const getNow = () => new Date().getTime() % oneday;

const [ $currentTimeRange ] = /** @type {Array<HTMLInputElement>} */(utils.$('#currentTime .range'));
const [ $currentTimeValue ] = /** @type {Array<HTMLInputElement>} */(utils.$('#currentTime .value'));

const [ $speedRange ] = /** @type {Array<HTMLInputElement>} */(utils.$('#speed .range'));
const [ $speedValue ] = /** @type {Array<HTMLInputElement>} */(utils.$('#speed .value'));

masterTL.currentTime = getNow();
// masterTL.currentTime = oneday - 3000;

masterTL.onUpdate = ({currentTime, speed}) => {
  $currentTimeRange.value = `${currentTime}`;
  $currentTimeValue.value = `${currentTime}`;
  $speedRange.value = `${speed}`;
  $speedValue.value = `${utils.round(speed, 0)}`;
}

utils.$('#controls button').forEach($button => {
  const id = $button.id;
  $button.onclick = () => {
    if (id === 'seek') {
      animate(masterTL, {
        currentTime: getNow(),
        ease: 'inOut(3)',
        duration: 1500
      })
    } else if (id === 'slowmo') {
      animate(masterTL, {
        speed: .1,
        ease: 'out(3)',
        duration: 1500
      })
    } else if (id === 'speedup') {
      animate(masterTL, {
        speed: 5,
        ease: 'out(3)',
        duration: 1500
      })
    } else if (id === 'normalspeed') {
      animate(masterTL, {
        speed: 1,
        ease: 'out(3)',
        duration: 1500
      })
    } else {
      masterTL[id]();
    }
  }
});

utils.$('fieldset').forEach($el => {
  const $range = /** @type {HTMLInputElement} */($el.querySelector('.range'));
  const $value = /** @type {HTMLInputElement} */($el.querySelector('.value'));
  const prop = $el.id;
  const value = masterTL[prop];
  $range.value = value;
  $value.value = masterTL[prop];
  $range.oninput = () => {
    const newValue = prop === 'currentTime' ? +$range.value % oneday : +$range.value;
    utils.sync(() => masterTL[prop] = newValue);
    $value.value = `${utils.round(newValue, 0)}`;
  };
});


================================================
FILE: examples/draggable-infinite-auto-carousel/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Draggable infinite auto carousel / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    * {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      user-select: none;
    }
    body, html {
      overflow: hidden;
      background: #000;
    }
    #infinite-carousel {
      --spacing: 30px;
      display: hidden;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    .carousel {
      display: flex;
      height: 100%;
      padding: var(--spacing) 0;
      will-change: transform;
    }
    .carousel-item {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 25vw;
      flex-shrink: 0;
      width: 100%;
      height: 100%;
      margin-right: var(--spacing);
      background-color: var(--red);
      border-radius: var(--spacing);
      list-style: none;
    }
  </style>
</head>
<body>
  <div id="infinite-carousel">
    <ul class="carousel">
      <li class="draggable carousel-item" style="width: 35vw">1</li>
      <li class="draggable carousel-item" style="width: 60vw">2</li>
      <li class="draggable carousel-item" style="width: 85vw">3</li>
      <li class="draggable carousel-item" style="width: 60vw">4</li>
    </ul>
  </div>
  <script src="./index.js" type="module"></script>
</body>

</html>



================================================
FILE: examples/draggable-infinite-auto-carousel/index.js
================================================
import {
  animate,
  createTimer,
  createDraggable,
  createAnimatable,
  utils,
} from '../../lib/anime.esm.js';

const [ $carousel ] = /** @type {Array<HTMLElement>} */(utils.$('.carousel'));
$carousel.innerHTML += $carousel.innerHTML; // Clone the children for creating the illusion of infinity
const carouselItems = /** @type {Array<HTMLElement>} */(utils.$('.carousel-item'));

/**
 * @param  {Number} total
 * @param  {HTMLElement} $el
 * @return {Number}
 */
const getTotalWidth = (total, $el) => {
  const style= getComputedStyle($el);
  const marginsWidth = parseInt(style.marginLeft) + parseInt(style.marginRight);
  return total + $el.offsetWidth + marginsWidth;
}

const carousel = { width: carouselItems.reduce(getTotalWidth, 0), speedX: 2, wheelX: 0, wheelY: 0 };

const animatable = createAnimatable($carousel, {
  x: 0, modifier: v => utils.wrap(v, -carousel.width / 2, 0)
});

const { x } = animatable;

const draggable = createDraggable(carousel, {
  trigger: '#infinite-carousel',
  y: false,
  onGrab: () => animate(carousel, { speedX: 0, duration: 500 }),
  onRelease: () => animate(carousel, { speedX: 2, duration: 500 }),
  onResize: () => carousel.width = carouselItems.reduce(getTotalWidth, 0),
  releaseStiffness: 20,
  velocityMultiplier: 1.5
});

createTimer({
  onUpdate: () => {
    x(/** @type {Number} */(x()) - carousel.speedX + draggable.deltaX - carousel.wheelX - carousel.wheelY);
  }
});

// Support mousewheel

const wheelDeltaAnim = animate(carousel, {
  wheelY: 0, // We make sure the wheel delta always goes back to 0
  wheelX: 0, // We make sure the wheel delta always goes back to 0
  duration: 500,
  autoplay: false,
  ease: 'out(4)'
});

/**
 * @type {EventListener}
 * @param {WheelEvent} e
 */
function onWheel(e) {
  e.preventDefault();
  carousel.wheelY = utils.lerp(carousel.wheelY, e.deltaY, .2);
  carousel.wheelX = utils.lerp(carousel.wheelX, e.deltaX, .2);
  wheelDeltaAnim.refresh().restart()
}

$carousel.addEventListener('wheel', onWheel, { passive: false });



================================================
FILE: examples/draggable-mouse-scroll-snap-carousel/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Draggable mouse scroll snap carousel / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    * {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      user-select: none;
    }
    body, html {
      overflow: hidden;
      background: #000;

    }
    #snap-carousel {
      --spacing: 30px;
      overflow: visible;
      position: absolute;
      top: 0;
      left: 100px;
      width: calc(100% - 200px);
      height: 100%;
    }
    .carousel {
      overflow: visible;
      display: flex;
      justify-content: flex-start;
      height: 100%;
      padding: var(--spacing) 0;
      will-change: transform;
    }
    .carousel-item {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 15vw;
      flex-shrink: 0;
      width: calc(50% - (var(--spacing) * 1.5));
      height: 100%;
      margin-left: var(--spacing);
      background-color: var(--red);
      border-radius: var(--spacing);
      list-style: none;
      will-change: transform;
    }
  </style>
</head>
<body>
  <div id="snap-carousel">
    <ul class="carousel">
      <li class="draggable carousel-item">1</li>
      <li class="draggable carousel-item">2</li>
      <li class="draggable carousel-item">3</li>
      <li class="draggable carousel-item">4</li>
      <li class="draggable carousel-item">5</li>
      <li class="draggable carousel-item">6</li>
      <li class="draggable carousel-item">7</li>
      <li class="draggable carousel-item">8</li>
    </ul>
  </div>
  <script src="./index.js" type="module"></script>
</body>

</html>



================================================
FILE: examples/draggable-mouse-scroll-snap-carousel/index.js
================================================
import {
  createTimer,
  createDraggable,
  utils,
} from '../../lib/anime.esm.js';

const carousel = {
  totalWidth: 0,
  itemWidth: 0,
  spacing: 0,
  released: false,
  deltaX: 0,
  deltaY: 0,
  prevX: 0,
  prevY: 0,
  wheeling: false,
  wheelable: true,
};

const [ $carousel ] = /** @type {Array<HTMLElement>} */(utils.$('.carousel'));
const carouselItems = /** @type {Array<HTMLElement>} */(utils.$('.carousel-item'));

const updateDimensions = () => {
  carousel.spacing = utils.get('#snap-carousel', '--spacing', false);
  carousel.totalWidth = carouselItems.reduce((total, $el) => {
    return total + $el.offsetWidth + carousel.spacing;
  }, 0);
  carousel.itemWidth = carouselItems[0].offsetWidth + carousel.spacing;
}

updateDimensions();

const draggable = createDraggable($carousel, {
  trigger: document.body,
  container: () => [0, 0, 0, -carousel.totalWidth + $carousel.offsetWidth - carousel.spacing],
  x: { snap: () => carousel.itemWidth },
  y: false,
  onResize: () => updateDimensions(),
  onAfterResize: self => self.setX(utils.snap(self.x, self.snapX)),
  onGrab: () => carousel.wheelable = false,
  onRelease: () => carousel.wheelable = true,
  releaseStiffness: 100,
  velocityMultiplier: 1.5,
  containerFriction: .5,
});

// Mousewheel Support

// Debouncing wheel delta calculation prevent false positives for the carousel.wheeling flag
const wheelTimer = createTimer({
  frameRate: 30,
  duration: 100,
  autoplay: false,
  onUpdate: () => {
    const newDeltaX = Math.abs(carousel.deltaX);
    const newDeltaY = Math.abs(carousel.deltaY);
    carousel.wheeling = carousel.prevY < newDeltaY || carousel.prevX < newDeltaX;
    carousel.prevX = newDeltaX;
    carousel.prevY = newDeltaY;
  }
});

const wheelVelocityTimer = createTimer({
  duration: 500,
  autoplay: false,
  onUpdate: () => {
    if (!carousel.wheelable) return;
    const [ _, cr, __, cl ] = draggable.containerBounds;
    const cf = (1 - draggable.containerFriction) * draggable.dragSpeed;
    const cx = draggable.x + carousel.deltaX + carousel.deltaY;
    // Apply friction when out of bounds
    const x = cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx;
    const dx = x - draggable.coords[2];
    draggable.pointer[2] = draggable.pointer[0];
    draggable.pointer[4] = draggable.pointer[0];
    draggable.pointer[0] = x;
    draggable.computeVelocity(dx, 0);
    draggable.angle = 0;
  }
});

/** @param {WheelEvent} e */
function onWheel(e) {
  e.preventDefault();
  carousel.deltaX = utils.lerp(carousel.deltaX, -e.deltaX, .5);
  carousel.deltaY = utils.lerp(carousel.deltaY, -e.deltaY, .5);
  wheelTimer.restart();
  wheelVelocityTimer.restart();
  if (!carousel.wheelable) return;
  if (carousel.wheeling) {
    draggable.stop();
    draggable.setX(draggable.pointer[0], true);
    carousel.released = false;
    draggable.grabbed = true; // Needed to trigger handleUp();
  } else if (!carousel.released) {
    draggable.handleUp();
  }
}

window.addEventListener('wheel', onWheel, { passive: false });



================================================
FILE: examples/draggable-playground/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Draggable playground / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>

    body {
      --one-cell: 100px;
      --border-color: rgba(255,255,255,.75);
    }

    .grid::before {
      content: "";
      pointer-events: none;
      position: absolute;
      z-index: 0;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(-90deg, rgba(255,255,255,.05) 1px, transparent 1px), linear-gradient(rgba(255,255,255,.05) 1px, transparent 1px), linear-gradient(-90deg, rgba(255,255,255,.04) 1px, transparent 1px), linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px), linear-gradient(transparent 3px, var(--black) 3px, var(--black) calc(var(--one-cell) - 2px), transparent calc(var(--one-cell) - 2px)), linear-gradient(-90deg, var(--white) 1px, transparent 1px), linear-gradient(-90deg, transparent 3px, var(--black) 3px, var(--black) calc(var(--one-cell) - 2px), transparent calc(var(--one-cell) - 2px)), linear-gradient(var(--white) 1px, transparent 1px), var(--black);
      background-size: calc(var(--one-cell) / 10) calc(var(--one-cell) / 10), calc(var(--one-cell) / 10) calc(var(--one-cell) / 10), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell), var(--one-cell) var(--one-cell);
      background-position: calc(var(--one-cell) * .25) -1px;
    }

    #draggables {
      overflow: hidden;
      position: relative;
      display: flex;
      flex-grow: 1;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: flex-start;
      padding: 0 0 var(--one-cell) 0;
      transform-origin: 50% 0% 0px;
      will-change: transform;
    }

    .example {
      position: relative;
      min-width: calc(var(--one-cell) * 1);
      margin: calc(var(--one-cell) * .25);
      margin-bottom: 0;
    }

    @media (min-width: 500px) {
      #draggables.grid {
        padding-bottom: calc(var(--one-cell) * 1);
      }
      #draggables.grid:before {
        width: calc(100% + calc(var(--one-cell) * .5));
        left: calc(var(--one-cell) * -.5);
        background-position: calc(var(--one-cell) * 1) -1px;
      }
      .example {
        margin: calc(var(--one-cell) * .5);
        margin-bottom: 0;
      }
    }

    .example h2 {
      font-family: Input Mono;
      height: calc(var(--one-cell) * .5);
      padding-top: 15px;
      padding-bottom: 15px;
    }

    .example-content {
      display: flex;
      justify-content: flex-start;
      width: 100%;
    }

    .example-content-vertical {
      flex-direction: column;
    }

    .draggable {
      display: flex;
      position: relative;
      z-index: 100;
    }

    .draggable::after {
      content: "";
      display: block;
      pointer-events: none;
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin-left: -10px;
      margin-top: -10px;
      background-size: 5px 5px;
      background-image:
        radial-gradient(circle at center, var(--black) 1px, transparent 0),
        radial-gradient(circle at center, var(--black) 1px, transparent 0);
    }

    .carousel .draggable {
      padding-top: 1rem;
      padding-left: 1rem;
      color: var(--black);
    }

    .rectangle {
      width: calc(var(--one-cell) * 2);
      height: calc(var(--one-cell) * 1);
      background-color: var(--red);
      border-radius: 20px;
    }

    .square {
      width: calc(var(--one-cell) * .8);
      height: calc(var(--one-cell) * .8);
      background-color: var(--red);
      border-radius: 20px;
    }

    .bar {
      overflow: hidden;
      width: calc(var(--one-cell) * .1);
      height: calc(var(--one-cell) * .8);
      background-color: var(--red);
      border-radius: 20px;
    }

    .margin {
      position: relative;
      z-index: 1;
      box-shadow: 0 0 0 1px var(--border-color);
      border-radius: 20px;
      padding: 10px;
    }

    .margin:before {
      content: "";
      pointer-events: none;
      display: block;
      position: absolute;
      z-index: 2;
      left: 10px;
      top: 10px;
      width: calc(100% - 20px);
      height: calc(100% - 20px);
      border: 1px dashed rgba(255,255,255,.25);
      border-radius: 10px;
    }

    .margin-overlay {
      position: absolute;
      pointer-events: none;
      z-index: 3;
      top: calc(var(--one-cell) * .5);
      left: 0;
      width: 100%;
      height: calc(100% - calc(var(--one-cell) * .5));
    }

    .margin-overlay + .margin:before {
      display: none;
    }

    .margin-overlay + .margin {
      box-shadow: none;
    }

    .margin .draggable {
      background-color: var(--red);
      border-radius: 10px;
    }

    .range-x {
      width: calc(var(--one-cell) * 3);
      height: calc(var(--one-cell) * 1);
    }

    .range-y {
      width: calc(var(--one-cell) * 1);
      height: calc(var(--one-cell) * 3);
    }

    .dynamic {
      width: calc(var(--one-cell) * 3);
      height: calc(var(--one-cell) * 1);
    }

    .dynamic .square,
    .dynamic .bar {
      position: absolute;
      left: 0;
      top: 0;
    }

    .dynamic .bar-left {
      left: 0;
      right: auto;
      border-radius: 10px 0 0 10px;
    }

    .dynamic .bar-right {
      left: auto;
      right: 0;
      border-radius: 0 10px 10px 0;
    }

    .container {
      overflow: hidden;
      width: calc((var(--one-cell) * 3));
      height: calc((var(--one-cell) * 3));
    }

    .container.overflow {
      overflow: auto;
      overscroll-behavior: contain;
    }

    #fixed-container {
      width: calc((var(--one-cell) * 2));
      height: calc((var(--one-cell) * 1));
      box-shadow: 0 0 0 1px var(--border-color);
      border-radius: 20px;
    }

    #fixed {
      position: fixed;
      top: calc((var(--one-cell) * .75));
      left: calc((var(--one-cell) * .25));
      box-shadow: 0 0 1rem 0 rgba(0,0,0,.2);
    }

    @media (min-width: 500px) {
      #fixed {
        position: fixed;
        top: calc((var(--one-cell) * 1));
        left: calc((var(--one-cell) * .5));
      }
    }

    #container-no-scroll {
      overflow: visible;
      z-index: 2;
    }

    .transformed-example {
      transform: scaleY(.75) scaleX(.75) rotate(-40deg) skew(15deg);
    }

    .transformed-example .margin-overlay {
      top: 0;
      width: calc((var(--one-cell) * 3));
      height: calc((var(--one-cell) * 3));
    }

    .scroller,
    .scroller:before {
      width: calc((var(--one-cell) * 8) - 20px);
      height: calc((var(--one-cell) * 8) - 20px);
    }

    .list {
      position: relative;
      overflow: visible;
      width: 100%;
      height: calc((var(--one-cell) * 3) - 20px);
    }

    .list-item {
      position: absolute;
      width: 100%;
      height: calc(var(--one-cell) * .5);
    }

    .carousel {
      display: flex;
      position: relative;
      overflow: visible;
      width: 100%;
      height: calc((var(--one-cell) * 3) - 20px);
    }

    .carousel-buttons {
      position: fixed;
      bottom: .5rem;
      left: 2rem;
      right: 2rem;
      z-index: 1;
      display: flex;
      justify-content: space-between;
    }

    .button {
      padding: .25em .5em;
      border-radius: 10px;
      cursor: pointer;
    }

    .carousel-item {
      width: calc((var(--one-cell) * 3) - 20px);
      height: calc((var(--one-cell) * 3) - 20px);
    }

    .carousel-item:nth-child(even),
    .list-item:nth-child(even) {
      background-color: var(--yellow);
    }

    .carousel-link {
      display: block;
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      bottom: 20px;
      border: 2px dotted var(--red);
    }

    #snap-carousel {
      display: flex;
      overflow: hidden;
    }

    #snap-carousel .carousel {
      display: flex;
      flex-shrink: 0;
      width: auto;
    }

    #snap-carousel .carousel-item {
      flex-shrink: 0;
      width: 100px;
    }

    #snap-carousel .carousel-item:nth-child(2n) {
      width: 200px;
    }

    #snap-carousel .carousel-item:nth-child(4n) {
      width: 280px;
    }

    .flicker .carousel-item:not(:last-child) {
      margin-right: 10px;
    }

    #map-props {
      overflow: initial;
      perspective: 1000px;
      touch-action: pan-x;
      width: 100%;
      height: calc((var(--one-cell) * 1));
      margin-top: 2rem;
      margin-bottom: 2rem;
    }

    #map-props .carousel {
      position: relative;
      transform-style: preserve-3d;
      height: 100%;
    }

    #map-props .carousel-item {
      pointer-events: none;
      position: absolute;
      transform-style: preserve-3d;
      left: 0;
      top: 0;
      width: min(25%, 105px);
      height: calc((var(--one-cell) * 1));
      border-radius: 10px;
      background: var(--yellow);
      backface-visibility: hidden;
    }

/*    #map-props .carousel-item:after {
      transform: scale(2.75);
    }*/

    .form {
      top: 62px;
      left: 60px;
      background: var(--black);
      padding: 20px;
      box-shadow: 0 0 0 1px var(--red);
    }

    .trigger {
      position: absolute;
      width: calc(var(--one-cell) * 3.2);
      height: calc(var(--one-cell) * 3.2);
      margin-left: calc(var(--one-cell) * -1.2);
      margin-top: calc(var(--one-cell) * -1.2);
      background: var(--yellow);
    }

    #onsnap-callback {
      z-index: 3;
    }

    /* Drawer */

    #toggle-drawer {
      position: absolute;
      z-index: 1;
      top: .5em;
      right: .5em;
      left: .5em;
      bottom: .5em;
      border-radius: .75em;
    }

    .drawer {
      overscroll-behavior: contain;
      position: fixed;
      z-index: 999;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      border-top-left-radius: .5rem;
      border-top-right-radius: .5rem;
      background-color: var(--red);
      will-change: transform;
      box-shadow: 0 500px 0 0 var(--red);
    }

    .drawer-content {
      overflow: auto;
      overscroll-behavior: contain;
      position: relative;
      z-index: 0;
      max-height: calc(100svh - 2rem);
      padding: 3rem 2rem;
    }

    .drawer-trigger {
      position: absolute;
      z-index: 1;
      width: 100%;
      height: 3rem;
      background-color: var(--red);
      border-top-left-radius: .5rem;
      border-top-right-radius: .5rem;
    }

    .drawer-trigger::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      display: block;
      width: 5rem;
      height: .25rem;
      border-radius: .25rem;
      background-color: #FFF;
      transform: translate3d(-50%,-50%, 0);
    }

    .drawer-content p,
    .drawer-content button {
      margin-bottom: 10px;
    }

    #nested-draggable {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: var(--yellow);
      margin-bottom: 10px;
      border-radius: .5rem;
    }

  </style>
</head>
<body>
  <div id="draggables" class="grid">
    <div class="example">
      <h2>Fixed (vel: <span id="log">0</span>)</h2>
      <div id="fixed-container" class="example-content">
        <div id="fixed" class="draggable rectangle">
          <button id="toggle-drawer" class="button"><span>Toggle Drawer</span></button>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Snap</h2>
      <div class="example-content example-content-vertical">
        <div id="body-snap" class="draggable rectangle"></div>
      </div>
    </div>
    <div class="example">
      <h2>Snap X</h2>
      <div class="example-content example-content-vertical">
        <div class="range margin range-x">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Snap Y</h2>
      <div class="example-content">
        <div class="range margin range-y">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Container</h2>
      <div class="example-content example-content-vertical">
        <div id="container-no-scroll" class="container margin">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Container auto scroll</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="container-scroll" class="container margin overflow">
          <div class="scroller grid">
            <div class="draggable square"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Transformed container</h2>
      <div class="example-content example-content-vertical transformed-example">
        <div class="margin margin-overlay"></div>
        <div id="transformed-container" class="container overflow margin">
          <div class="scroller grid">
            <div class="draggable square"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Snap carousel</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="snap-carousel" class="flicker container margin">
          <ul class="carousel">
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
            <a href="https://animejs.com" target="_blank" class="draggable carousel-item"></a>
            <li class="draggable carousel-item"><a href="https://animejs.com" target="_blank" class="carousel-link"></a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Bounded flick</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="bounded-flick" class="flicker container margin">
          <ul class="carousel">
            <li class="draggable carousel-item"></li>
            <li class="draggable carousel-item"></li>
            <li class="draggable carousel-item"></li>
            <li class="draggable carousel-item"></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>Object target</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="infinite-flick" class="flicker container margin">
          <ul class="carousel">
            <li class="draggable carousel-item">1</li>
            <li class="draggable carousel-item">2</li>
            <li class="draggable carousel-item">1</li>
            <li class="draggable carousel-item">2</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="example">
      <h2>onSnap() callback</h2>
      <div class="example-content example-content-vertical">
        <div class="margin margin-overlay"></div>
        <div id="onsnap-callback" class="container margin overflow">
          <ul class="list">
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
            <li class="draggable list-item"></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="example">
      <h2>Array container</h2>
      <div class="example-content example-content-vertical">
        <div id="array-container" class="container margin">
          <div class="draggable square"></div>
        </div>
      </div>
    </div>

    <div class="example">
      <h2>Dynamic padding</h2>
      <div class="example-content example-content-vertical">
        <div class="range margin dynamic">
          <div class="draggable bar bar-left"></div>
          <div class="draggable bar bar-right"></div>
          <div class="draggable square"></div>
        </div>
      </div>
    </div>

  </div>

  <div class="drawer">
    <div id="nested-draggable" class="draggable square"></div>
    <div class="drawer-trigger"></div>
    <div class="drawer-content">
      <div id="map-props">
        <ul class="carousel">
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
          <li class="draggable carousel-item"></li>
        </ul>
      </div>
      <div class="carousel-buttons">
        <button class="button carousel-prev">PREV</button>
        <button class="button carousel-next">NEXT</button>
      </div>
      <p>
        This is the drawer content. <a href="https://animejs.com">This is a link with a <span>span</span>.</a> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
      <p>
        This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
      <p>
        This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
      <p>
        This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar. This is the drawer content. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam iaculis cursus nisi sit amet pulvinar.
      </p>
    </div>
  </div>

  <script src="./index.js" type="module"></script>

</body>

</html>



================================================
FILE: examples/draggable-playground/index.js
================================================
import {
  animate,
  createTimer,
  createDraggable,
  createAnimatable,
  utils,
  stagger,
  eases,
  createSpring,
  createTimeline,
  engine,
} from '../../lib/anime.esm.js';

engine.timeUnit = 'ms';
// engine.timeUnit = 's';

const [ $log ] = utils.$('#log');

createDraggable('#fixed', {
  container: document.body,
  onDrag: self => {
    $log.innerHTML = `${utils.round(self.velocity, 3)}`;
  }
});

let scrollTop, scrollStyles;

function blockScrolling() {
  if (scrollStyles) return;
  const $scroll = document.scrollingElement;
  scrollTop = $scroll.scrollTop;
  scrollStyles = utils.set([document.documentElement, $scroll], {
    overflow: 'hidden', position: 'sticky', height: window.innerHeight - 1 + 'px'
  });
}

function enableScrolling() {
  if (!scrollStyles) return;
  scrollStyles.revert();
  scrollStyles = null;
  window.scrollTo({ top: scrollTop, behavior: 'instant' });
}

const [ $drawer ] = /** @type {Array<HTMLElement>} */(utils.$('.drawer'));

const drawerOpenAnim = createTimeline({
  autoplay: false,
  defaults: { ease: 'linear' }
})
.add('#draggables', {
  y: [10, 0],
  scale: $el => [1 - (20 / $el.offsetWidth), 1],
  borderRadius: ['.5rem', 0],
  opacity: [.5, 1],
}, 0)
.add(document.body, {
  backgroundColor: { from: '#000' },
}, 0)
.add($drawer, {
  opacity: [1, 0],
  duration: 10,
  delay: 990,
  ease: 'out(4)',
}, 0);

const drawer = createDraggable($drawer, {
  container: () => [0, $drawer.offsetWidth, $drawer.offsetHeight, 0],
  y: { snap: ({ $target }) => $target.offsetHeight },
  x: false,
  velocityMultiplier: 4,
  containerFriction: 1,
  onUpdate: (self) => {
    drawerOpenAnim.progress = self.progressY;
    self.progressY < .95 ? blockScrolling() : enableScrolling();
  },
  onResize: (self) => {
    self.progressY = self.progressY > .5 ? 1 : 0
  }
});

utils.$('#toggle-drawer')[0].onclick = () => {
  drawer.stop();
  animate(drawer, {
    progressY: drawer.y < 100 ? 1 : 0,
    duration: 375,
    ease: 'out(4)',
  });
}

drawer.progressY = 1;

createDraggable('#nested-draggable', {
  container: '.drawer',
});

createDraggable('#body-snap', {
  container: document.body,
  x: { snap: 200 },
  y: { snap: 100 },
});

const [ $rangeX ] = utils.$('.range-x .draggable');

const rangeX = createDraggable($rangeX, {
  container: '.range-x',
  containerPadding: 10,
  snap: 200,
  y: false,
  onGrab: () => animateRangeX.pause(), // Here we manually pause the animation animating the draggable
  onSettle: () => {
    animateRangeX.refresh().restart();
  }
});

const animateRangeX = animate(rangeX, {
  progressX: el => el.progressX > .5 ? 0 : 1,
  // loop: true,
  duration: 1500,
  ease: 'inOut(3)',
  onLoop: self => self.refresh()
});

const rangeY = createDraggable('.range-y .draggable', {
  container: '.range-y',
  containerPadding: 10,
  snap: 200,
  x: false,
  // containerFriction: 0,
  // minVelocity: 2,
  // minVelocity: 2,
  cursor: { onHover: 'ns-resize', onGrab: 'move' },
  // cursor: false,
  releaseEase: createSpring({
    mass: 1,
    stiffness: 400,
    damping: 30
  }),
});

createDraggable('#container-no-scroll .draggable', {
  container: '#container-no-scroll',
  containerPadding: 10,
});

createDraggable('#container-scroll .draggable', {
  container: '#container-scroll',
  containerPadding: 10,
  scrollThreshold: 10,
});

createDraggable('#transformed-container .draggable', {
  container: '#transformed-container',
  containerPadding: 10,
});

createDraggable('#array-container .draggable', {
  container: [0, 200, 200, 0],
  containerPadding: 50,
});

// Bounded flick carousel

const boundedFlickLength = utils.$('#bounded-flick .carousel-item').length;
const boundedFlickWidth = 290;

const boundedFlicker = createDraggable('#bounded-flick .carousel', {
  container: [0, 0, 0, -boundedFlickWidth * (boundedFlickLength - 1)],
  y: false,
  snap: boundedFlickWidth,
});

utils.set('#bounded-flick .carousel', {
  width: `${boundedFlickLength * boundedFlickWidth - 10}`
});

// Snap carousel
const [ $snapCarousel ] = utils.$('#snap-carousel .carousel');
const snapCarouselItems = /** @type {Array<HTMLElement>} */(utils.$('#snap-carousel .carousel-item'));

const snapTo = snapCarouselItems.map($el => -$el.offsetLeft);

createDraggable($snapCarousel, {
  trigger: '#snap-carousel',
  x: { modifier: utils.wrap(snapTo[snapTo.length / 2], 0) },
  y: false,
  snap: snapTo,
  // containerFriction: 1,
});

// Object target

const [ $flickCarousel ] = utils.$('#infinite-flick .carousel');
const flickLength = utils.$('#infinite-flick .carousel-item').length;
const flickData = { width: 290, speedX: 2, wheelY: 0 };

utils.set($flickCarousel, { width: `${flickLength * flickData.width - 10}` });

const flickAnimatable = createAnimatable($flickCarousel, {
  x: 0,
  modifier: utils.wrap(-flickData.width * (flickLength / 2), 0),
});

const flickDraggable = createDraggable(flickData, {
  trigger: '#infinite-flick',
  y: false,
  onGrab: () => animate(flickData, { speedX: 0, duration: 500 }),
  onRelease: () => animate(flickData, { speedX: 2, duration: 500 }),
  releaseStiffness: 10,
});

createTimer({
  onUpdate: () => {
    const { x } = flickAnimatable;
    x(/** @type {Number} */(x()) - flickData.speedX + flickDraggable.deltaX - flickData.wheelY);
  }
});

// Support mousewheel

const wheelDeltaAnim = animate(flickData, {
  wheelY: () => 0,
  duration: 500,
  autoplay: false,
});

/**
 * @type {EventListener}
 * @param {WheelEvent} e
 */
function onWheel(e) {
  e.preventDefault();
  flickData.wheelY = utils.lerp(flickData.wheelY, e.deltaY, .2);
  wheelDeltaAnim.refresh().restart()
}

$flickCarousel.addEventListener('wheel', onWheel, { passive: false });

// Draggable list

const list = [];
const snap = 60;
let bodySticky;

utils.$('#onsnap-callback .draggable').forEach(($listItem, itemIndex) => {
  const draggable = createDraggable($listItem, {
    container: '#onsnap-callback',
    x: false,
    containerPadding: 10,
    snap,
    onGrab: self => {
      animate(self.$target, { scale: 1.05, duration: 350 });
      bodySticky = utils.set(document.scrollingElement, { position: 'sticky' }) // Hack for Safari mobile
    },
    onRelease: self => {
      animate(self.$target, { scale: 1.00, duration: 450 });
      bodySticky.revert();
    },
    onSnap: self => {
      const fromIndex = list.indexOf(self);
      const toIndex = utils.round(0).clamp(0, list.length - 1)(self.destY / snap);
      if (toIndex !== fromIndex) {
        list.splice(fromIndex, 1);
        list.splice(toIndex, 0, self);
        list.forEach((item, i) => {
          if (i !== toIndex) {
            animate(item, {
              y: i * snap,
              duration: 750,
              ease: eases.outElastic(.8, 1)
            });
          }
        });
      }
    }
  });
  draggable.y = itemIndex * snap;
  utils.set($listItem, { willChange: 'transform', z: 10 });
  list.push(draggable);
});

utils.set('#onsnap-callback .list', { height: `${list.length * snap - 10}` });

// Map value carousel

const carouselItems = utils.$('#map-props .carousel-item');
const itemAngle = 360 / carouselItems.length;

utils.set('#map-props .carousel-item', {
  top: '50%',
  left: '50%',
  x: '-50%',
  y: '-50%',
  rotateY: stagger(itemAngle),
  z: 'min(40vw, 200px)',
});

const carousel = createDraggable('#map-props .carousel', {
  x: { mapTo: 'rotateY' },
  y: false,
  snap: itemAngle,
  dragSpeed: .4,
  releaseStiffness: 10,
  containerPadding: 10,
});

const [ $prev, $next ] = utils.$('.carousel-buttons .button');

const prev = e => {
  e.preventDefault();
  animate(carousel, { x: utils.snap(carousel.x + 40, itemAngle), duration: 500, ease: 'out(4)' });
}
const next = e => {
  e.preventDefault();
  animate(carousel, { x: utils.snap(carousel.x - 40, itemAngle), duration: 500, ease: 'out(4)' });
}

$prev.addEventListener('click', prev);
$next.addEventListener('click', next);

// Dynamic values

const dynamicDraggables = utils.$('.dynamic .draggable').map($el => {
  return createDraggable($el, {
    container: '.dynamic',
    containerPadding: 10,
    snap: 1,
    containerFriction: 1,
  });
});

const [ left, right, center ] = dynamicDraggables;

// Set the initial padding values
left.containerPadding[1] = 100;
right.containerPadding[3] = 100;
center.parameters.containerPadding = () => [10, Math.abs(right.x - 10), 10, left.x + 10];
center.refresh();

// Update center and right padding on left drag
left.onUpdate = ({ x }) => {
  right.containerPadding[3] = x + 90;
  center.refresh();
}

// Update center and left padding on right drag
right.onUpdate = ({ x }) => {
  left.containerPadding[1] = Math.abs(x - 90);
  center.refresh();
}

// left.animateInView();
// center.animateInView();
// right.animateInView();



================================================
FILE: examples/easings-visualizer/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Easings visualizer</title>
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-width: 100dvw;
      min-height: 100dvh;
    }

    polyline {
      vector-effect: non-scaling-stroke;
    }

    input[type=number] {
      -moz-appearance: textfield;
      appearance: textfield;
      margin: 0;
    }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    #eases-visualizer {
      --unit: 1dvw;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      width: 100dvw;
      min-height: 100dvh;
    }

    @media (min-width: 640px) {
      #eases-visualizer {
        --unit: .7125dvw;
      }
    }

    #eases-editor {
      position: fixed;
      right: 0;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 70vw;
    }

    @media (min-width: 640px) {
      #eases-editor {
        width: 50%;
        height: 100%;
      }
    }

    #eases-container {
      --one-cell: calc(var(--unit) * 10);
      position: relative;
      width: calc(var(--one-cell) * 5);
      height: calc(var(--one-cell) * 5);
      display: grid;
      grid-template-columns: 3fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 3fr;
      gap: 0px 0px;
      grid-auto-flow: row;
      grid-template-areas:
        "time time ."
        "graph graph preview"
        "graph graph preview";
    }

    .eases-editor-cell {
      position: relative;
    }

    #eases-graph {
      grid-area: graph;
      border: 1px dotted rgba(255, 255, 255, .5);
    }

    #eases-container:before {
      content: "";
      position: absolute;
      left: -100%;
      top: -100%;
      display: block;
      width: 300%;
      height: 300%;
      background:
        linear-gradient(-90deg, rgba(255,255,255,.05) 1px, transparent 1px),
        linear-gradient(rgba(255,255,255,.05) 1px, transparent 1px),
        linear-gradient(-90deg, rgba(255,255,255,.04) 1px, transparent 1px),
        linear-gradient(rgba(255,255,255,.04) 1px, transparent 1px),
        linear-gradient(transparent 3px, var(--black) 3px, var(--black) calc(var(--one-cell) - 2px), transparent calc(var(--one-cell) - 2px)),
        linear-gradient(-90deg, var(--white) 1px, transparent 1px),
        linear-gradient(-90deg, transparent 3px, var(--black) 3px, var(--black) calc(var(--one-cell) - 2px), transparent calc(var(--one-cell) - 2px)),
        linear-gradient(var(--white) 1px, transparent 1px), var(--black);
      background-size:
        calc(var(--one-cell) / 10) calc(var(--one-cell) / 10),
        calc(var(--one-cell) / 10) calc(var(--one-cell) / 10),
        var(--one-cell) var(--one-cell),
        var(--one-cell) var(--one-cell),
        var(--one-cell) var(--one-cell),
        var(--one-cell) var(--one-cell),
        var(--one-cell) var(--one-cell),
        var(--one-cell) var(--one-cell);
    }

    #eases-graph svg {
      overflow: visible;
      position: absolute;
      width: 100%;
      height: 100%;
      stroke-width: 1px;
      will-change: transform;
    }

    #eases-time {
      grid-area: time;
      border-top: 1px dashed rgba(255, 255, 255, .5);
    }

    #eases-preview {
      grid-area: preview;
      border-right: 1px dashed rgba(255, 255, 255, .5);
    }

    .axis {
      z-index: 1;
      position: absolute;
    }

    .axis:after {
      content: "";
      display: block;
      position: absolute;
      top: -1.25rem;
      right: -1.25rem;
      width: calc(2.5rem + 1px);
      height: calc(2.5rem + 1px);
    }

    .axis-x {
      bottom: -1px;
      right: -1px;
      width: calc(var(--unit) * 50);
      height: 1px;
      background-color: var(--red);
      z-index: 1;
    }

    .axis-x:not(:first-child) {
      z-index: 0;
    }

    .axis-x:first-child:after {
      background-color: var(--red);
      box-shadow: 0 0 0 1px var(--black);
    }

    .axis-x:not(:first-child):after {
      background-color: var(--red);
    }

    .axis-y {
      top: 0;
      left: -1px;
      width: 1px;
      height: calc(var(--unit) * 50);
      background-color: rgba(255, 255, 255, .25);
    }

    .axis-y:after {
      content: attr(data-value);
      top: -1.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: .75rem;
      font-weight: bold;
      color: var(--white);
      background-color: var(--black);
      border: 1px solid rgba(255, 255, 255, .25);
    }

    /* Easings config */

    #eases-config {
      position: sticky;
      z-index: 2;
      top: 0;
      width: 100%;
      min-height: 100dvh;
      margin-top: 70vw;
      background: var(--black);
    }

    @media (min-width: 640px) {
      #eases-config {
        width: 50%;
        margin-top: 0;
      }
    }

    #ease-controls {
      position: sticky;
      z-index: 2;
      top: 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      width: 100%;
      padding: .75rem;
      padding-bottom: 0;
      background: var(--black);
      box-shadow: 0 10px 10px 0 var(--black);
      border-radius: 1rem 1rem 0 0;
    }

    #ease-name {
      background: transparent;
      color: var(--red);
      width: 100%;
      margin: 0.125rem;
      font-size: 2rem;
    }

    @media (min-width: 1280px) {
      #ease-controls {
        padding: 1.5rem;
        padding-bottom: 0;
      }

      #ease-name {
        margin: 0.5rem;
      }
    }

    #ease-parameters {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      width: 100%;
    }

    .ease-parameter {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      width: calc(25% - .25rem);
      margin: .125rem;
    }

    .parameter-legend {
      display: block;
      height: 1rem;
      font-size: .75rem;
      margin-bottom: .5rem;
    }

    .ease-parameter input[type="number"] {
      display: none;
    }

    .ease-parameter input[type="range"] {
      width: 100%;
    }

    @media (min-width: 1280px) {
      .ease-parameter input[type="number"] {
        display: block;
        width: 2.75rem;
        background-color: transparent;
        color: var(--white);
      }
      .ease-parameter input[type="range"] {
        width: calc(100% - 2.75rem);
      }
    }

    .ease-parameter input:disabled {
      opacity: .25;
    }

    input[type="range"][value] {
      position: relative;
      height: 2rem;
      -webkit-appearance: none;
      background-color: transparent;
      color: currentColor;
    }

    input[type="range"][value]:focus {
      outline: none;
    }

    input[type="range"][value]:after {
      content: "";
      position: absolute;
      top: 1rem;
      left: 0;
      width: 100%;
      height: 1px;
      background-color: currentColor;
    }

    input[type="range"][value]::-webkit-slider-thumb {
      position: relative;
      z-index: 2;
      -webkit-appearance: none;
      border-radius: 4px;
      border: 1px solid currentColor;
      width: 16px;
      height: 29px;
      background-color: var(--black);
      background-image: radial-gradient(transparent 1px, rgba(0, 0, 0, .7) 0), radial-gradient(transparent 1px, currentColor 0), radial-gradient(currentColor 1px, transparent 0);
      background-size: 3px 3px, 3px 3px, 3px 3px;
      background-position: -2px -2px, -2px -2px, -2px -2px;
      box-shadow: inset 0 0 0 4.5px rgba(0, 0, 0, .7), inset 0 0 0 4.5px currentColor;
    }

    /* Ease buttons */

    #eases-list {
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      width: 100%;
      min-height: 100%;
      padding: .75rem;
      background-color: var(--black);
    }

    @media (min-width: 1280px) {
      #eases-list {
        padding: 1.5rem;
      }
    }

    .ease-button {
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: calc(25% - .25rem);
      margin: .125rem;
      padding: .5rem;
      background-color: rgba(255, 255, 255, .05);
      color: var(--white);
      cursor: pointer;
      border-radius: .6rem;
      transition: background-color .25s ease-in-out;
      font-size: .75rem;
    }

    @media (min-width: 1280px) {
      .ease-button {
        width: calc(12.5% - .25rem);
      }
    }

    .ease-button:hover {
      background-color: rgba(255, 255, 255, .1);
      transition: background-color .05s ease-out;
    }

    .ease-button.is-active {
      background: var(--red);
      color: var(--black);
    }

    .ease-button .ease-config {
      position: absolute;
      top: .25rem;
      right: .41rem;
      font-size: .75rem;
    }

    .ease-button svg {
      overflow: visible;
      width: calc(100% - 3rem);
      margin-top: 0.25rem;
      margin-bottom: 0.5rem;
    }

    @media (min-width: 640px) {
      .ease-button svg {
        width: calc(100% - 2rem);
        margin-top: 1rem;
        margin-bottom: 1rem;
      }
    }

    .ease-button svg polyline {
      stroke: var(--red);
    }

    .ease-button.is-active svg polyline {
      stroke: var(--black);
    }

  </style>
</head>
<body>
  <div id="eases-visualizer">
    <div id="eases-editor">
      <div id="eases-container">
        <div id="eases-graph" class="eases-editor-cell">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="grid-small">
            <polyline id="ease-curve" stroke="#FF4B4B" stroke-width="4" points="0 100 50 50 100 0" stroke-linecap="round" stroke-linejoin="round" fill="none" fill-rule="evenodd"/>
          </svg>
        </div>
        <div id="eases-time" class="eases-editor-cell"><div class="axis axis-y" data-value="1.0"></div></div>
        <div id="eases-preview" class="eases-editor-cell">
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
          <div class="axis axis-x"></div>
        </div>
      </div>
    </div>
    <div id="eases-config">
      <div id="ease-controls" class="ease-visualizer-section">
        <input type="text" id="ease-name" value="easeName" readonly/>
        <div id="ease-parameters">
          <fieldset class="ease-parameter">
            <legend id="legend-p1" class="parameter-legend">P1</legend>
            <input data-parameters="p1" type="number" value="1.0" min="0" max="2" step="0.1"/>
            <input data-parameters="p1" type="range" value="1.0" min="0" max="2" step="0.1"/>
          </fieldset>
          <fieldset class="ease-parameter">
            <legend id="legend-p2" class="parameter-legend">P2</legend>
            <input data-parameters="p2" type="number" value="1.0" min="0" max="2" step="0.1"/>
            <input data-parameters="p2" type="range" value="1.0" min="0" max="2" step="0.1"/>
          </fieldset>
          <fieldset class="ease-parameter">
            <legend id="legend-p3" class="parameter-legend">P3</legend>
            <input data-parameters="p3" type="number" value="1.0" min="0" max="2" step="0.1"/>
            <input data-parameters="p3" type="range" value="1.0" min="0" max="2" step="0.1"/>
          </fieldset>
          <fieldset class="ease-parameter">
            <legend id="legend-p4" class="parameter-legend">P4</legend>
            <input data-parameters="p4" type="number" value="1.0" min="0" max="2" step="0.1"/>
            <input data-parameters="p4" type="range" value="1.0" min="0" max="2" step="0.1"/>
          </fieldset>
        </div>
      </div>
      <div id="eases-list" class="ease-visualizer-section"></div>
    </div>
  </div>
  <script type="module" src="index.js"></script>
</body>
</html>



================================================
FILE: examples/easings-visualizer/index.js
================================================
import { animate, createTimeline, eases, createSpring, utils, stagger } from '../../lib/anime.esm.js';

function bindInputsToObject(name, obj, onChange = () => {}) {
  const $bindedInputs = document.querySelectorAll(`[data-${ name }]`);
  $bindedInputs.forEach($input => $input.addEventListener('input', event => {
    const prop = event.currentTarget.dataset[name];
    const value = event.currentTarget.value;
    const $sibling = document.querySelectorAll(`[data-${ name }="${ prop }"]`);
    $sibling.forEach($bind => $bind.value = value);
    obj[prop] = value;
    onChange(obj, prop, value);
  }));
  return $bindedInputs;
}

// SVG curve stuff

function createSvgCurve(strokeWidth = 1) {
  const $svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  const $curve = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
  $svg.setAttribute('viewBox', '0 0 100 100');
  $curve.setAttribute('stroke-width', strokeWidth);
  $curve.setAttribute('points', '0 100 50 50 100 0');
  $curve.setAttribute('stroke-linecap', 'round');
  $curve.setAttribute('stroke-linejoin', 'round');
  $curve.setAttribute('fill', 'none');
  $curve.setAttribute('fill-rule', 'evenodd');
  $svg.appendChild($curve);
  return $svg;
}

function createCurvePoints(maxPoints = 100) {
  const points = [];
  for (let i = 0; i < maxPoints + 1; i++) {
    points.push({
      x: utils.round((i / maxPoints) * 100, 10),
      y: utils.round(100 - ((i / maxPoints) * 100), 10),
    });
  }
  return points;
}

const $easesEditor = document.querySelector('#eases-editor');
const $mainCurve = document.querySelector('#ease-curve');
const $easeName = document.querySelector('#ease-name');
const $easeList = document.querySelector('#eases-list');
const mainCurvePoints = createCurvePoints(400);
const buttonCurvePoints = createCurvePoints(100);
const buttons = [];

utils.set($mainCurve, { points: coordsToPoints(mainCurvePoints) });

const easesLookup = { createSpring, ...eases };

const easesList = {
  in: [{ name: 'power', value: 1.675, min: 1, max: 10, step: .1 }],
  out: [{ name: 'power', value: 1.675, min: 1, max: 10, step: .1 }],
  inOut: [{ name: 'power', value: 1.675, min: 1, max: 10, step: .1 }],
  inSine: null,
  outSine: null,
  inOutSine: null,
  inQuad: null,
  outQuad: null,
  inOutQuad: null,
  inCubic: null,
  outCubic: null,
  inOutCubic: null,
  inQuart: null,
  outQuart: null,
  inOutQuart: null,
  inQuint: null,
  outQuint: null,
  inOutQuint: null,
  inExpo: null,
  outExpo: null,
  inOutExpo: null,
  inCirc: null,
  outCirc: null,
  inOutCirc: null,
  inBack: [{ name: 'overshoot', value: 1.70158, min: 0, max: 5, step: .01 }],
  outBack: [{ name: 'overshoot', value: 1.70158, min: 0, max: 5, step: .01 }],
  inOutBack: [{ name: 'overshoot', value: 1.70158, min: 0, max: 5, step: .01 }],
  inBounce: null,
  outBounce: null,
  inOutBounce: null,
  inElastic: [
    { name: 'amplitude', value: 1, min: 1, max: 3, step: .01 },
    { name: 'period', value: .3, min: 0, max: 2, step: .01 }
  ],
  outElastic: [
    { name: 'amplitude', value: 1, min: 1, max: 3, step: .01 },
    { name: 'period', value: .3, min: 0, max: 2, step: .01 }
  ],
  inOutElastic: [
    { name: 'amplitude', value: 1, min: 1, max: 3, step: .01 },
    { name: 'period', value: .3, min: 0, max: 2, step: .01 }
  ],
  createSpring: [
    { name: 'mass', value: 1, min: 0, max: 10, step: .01 },
    { name: 'stiffness', value: 100, min: 1, max: 1000, step: 1 },
    { name: 'damping', value: 10, min: .1, max: 50, step: .1 },
    { name: 'velocity', value: 0, min: 0, max: 100, step: .1 },
  ],
  steps: [
    { name: 'steps', value: 10, min: 0, max: 50, step: 1 },
    { name: 'jumpterm', value: 0, min: 0, max: 1, step: 1 }
  ],
  irregular: [
    { name: 'steps', value: 10, min: 0, max: 50, step: 1 },
    { name: 'randomness', value: 1, min: 0, max: 4, step: .001 },
  ],
  cubicBezier: [
    { name: 'x1', value: 0.2, min: 0, max: 1, step: .01 },
    { name: 'y1', value: 2.0, min: -2, max: 3, step: .01 },
    { name: 'x2', value: 0.6, min: 0, max: 1, step: .01 },
    { name: 'y2', value: 0.4, min: -2, max: 3, step: .01 },
  ],
  linear: [
    { name: 'p1', value: 0.00, min: -.5, max: 1.5, step: .01 },
    { name: 'p2', value: 0.50, min: -.5, max: 1.5, step: .01 },
    { name: 'p3', value: 1.00, min: -.5, max: 1.5, step: .01 },
  ],
}

function createElement(tag, className = null, innerHTML = null) {
  const el = document.createElement(tag);
  if (className) el.className = className;
  if (innerHTML) el.innerHTML = innerHTML;
  return el;
}

function coordsToPoints(mainCurvePoints) {
  let points = '';
  mainCurvePoints.forEach(p => points += `${p.x} ${p.y} `);
  return points;
}

const parameters = {
  ease: eases.out,
  name: 'out',
  computedEasing: null,
  easeDuration: 450,
  transitionEasing: 'inOut(3)',
  p1: null,
  p2: null,
  p3: null,
  p4: null,
}

function animateEasing() {
  const totalDuration = 1250;
  utils.set('.axis-x:not(:first-child)', { opacity: 0 });
  createTimeline({
    defaults: {
      duration: totalDuration,
      ease: 'linear',
    },
  })
  .add('.axis-y', {
    translateX: ['calc(var,(--unit) * 0)', 'calc(var(--unit) *  40)'],
    onUpdate: self => self.targets[0].dataset.value = utils.round(self.progress, 1),
   }, 0)
  .add('.axis-x:first-child', {
    translateY: ['calc(var(--unit) * 0)', 'calc(var(--unit) * -40)'],
    ease: parameters.computedEasing,
  }, 0)
  .set('.axis-x:not(:first-child)', {
    opacity: [0, .2],
  }, stagger([0, totalDuration], { start: 0 }))
}

function updateCurve($curve, points, ease, params, duration = parameters.easeDuration) {
  const parsedEasing = params ? ease(...params) : ease;
  parameters.computedEasing = parsedEasing;
  utils.set(points, { y: stagger([100, 0], { ease: parsedEasing }) });
  animate($curve, {
    points: coordsToPoints(points),
    duration,
    ease: parameters.transitionEasing,
    composition: duration ? 'add' : 'none',
    modifier: v => utils.round(v, 2)
  });
}

function updateName(name, ease, params) {
  let easeName = name;
  if (params) {
    easeName += '(';
    params.forEach((p, i) => {
      easeName += p + (i === params.length - 1 ? ')' : ', ');
    });
  }
  $easeName.value = easeName;
}

function updateParameters(state) {
  let params;
  for (let p in state) {
    if (p === 'p1' || p === 'p2' || p === 'p3' || p === 'p4') {
      const pVal = state[p];
      if (pVal !== null) {
        if (!params) params = [];
        params.push(+pVal);
      }
    }
  }
  const ease = state.name === 'spring' ? params ? state.ease(...params).ease : state.ease().ease : state.ease
  updateCurve($mainCurve, mainCurvePoints, ease, state.name === 'spring' ? undefined : params);
  updateName(state.name, ease, params);

  animate('.axis-x:not(:first-child)', {
    translateY: stagger([0, -40], {
      ease: parameters.computedEasing,
      modifier: v => `calc(var(--unit) * ${v}`,
    }),
    duration: parameters.easeDuration,
    ease: parameters.transitionEasing,
    composition: 'add',
  });
}

const $parameters = bindInputsToObject('parameters', parameters, updateParameters);

function selectEase(name) {
  const easeFunction = easesLookup[name];
  const easeParams = easesList[name];
  parameters.ease = easeFunction;
  parameters.name = name;
  parameters.p1 = null;
  parameters.p2 = null;
  parameters.p3 = null;
  parameters.p4 = null;
  const $legends = document.querySelectorAll('.parameter-legend');
  $parameters.forEach($el => $el.disabled = true);
  $legends.forEach(($el, i) => {$el.disabled = true; $el.textContent = '--'});
  if (easeParams) {
    easeParams.forEach((p, i) => {
      const propName = 'p' + (i + 1);
      const $ps = document.querySelectorAll(`[data-parameters=${ propName }]`);
      $ps.forEach($p => {
        $p.disabled = false;
        $p.min = p.min;
        $p.max = p.max;
        $p.step = p.step;
        $p.value = p.value;
      });
      $legends[i].innerHTML = '&#9881;&#xFE0E; ' + p.name;
      parameters[propName] = p.value;
    });
  }
  const $button = document.querySelector('.ease-' + name);
  buttons.forEach($el => $el.classList.remove('is-active'));
  $button.classList.add('is-active');
  utils.set('.axis-x:not(:first-child)', { opacity: 0 });
  updateParameters(parameters);
}

function createEaseButton(name, ease, hasParams) {
  const $button = createElement('button', 'ease-button');
  const $name = createElement('span', 'ease-name', name);
  const $svgCurve = createSvgCurve(2);
  updateCurve($svgCurve.querySelector('polyline'), buttonCurvePoints, ease, null, 0);
  $button.classList.add('ease-' + name);
  $button.appendChild($svgCurve);
  $button.appendChild($name);
  if (hasParams) {
    $button.appendChild(createElement('span', 'ease-config', '&#9881;&#xFE0E;'));
  }
  $button.onclick = () => {
    if (name !== parameters.name) {
      selectEase(name);
    }
    if (window.innerWidth < 639) {
      window.scroll({
        top: 0,
        left: 0,
        behavior: 'smooth'
      });
    }
    animateEasing();

  }
  return $button;
}

for (let easeName in easesList) {
  const params = easesList[easeName];
  let ease = easesLookup[easeName];
  if (easeName === 'spring') {
    ease = ease().solver;
  } else if (easeName === 'cubicBezier') {
    ease = ease(0.2, 2.0, 0.6, 0.4);
  } else if (params) {
    ease = ease();
  }
  const $button = createEaseButton(easeName, ease, params);
  $easeList.appendChild($button);
  buttons.push($button);
}

selectEase('out');
animateEasing();

$easesEditor.onclick = animateEasing;



================================================
FILE: examples/irregular-playback-typewriter/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Typewriter / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .playground {
      position: relative;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      width: 30%;
    }

    .playground .typewriter {
      position: relative;
      flex-shrink: 0;
    }

    .playground .typewriter span {
      white-space: pre;
      display: inline-block;
      font-family: Input Mono, monospace;
    }

    .playground .typewriter .cursor {
      position: absolute;
      top: -2px;
      bottom: 0px;
      left: 1ch;
      width: 2px;
      background-color: var(--red);
    }
  </style>
</head>
<body>

  <div class="playground">
    <div class="typewriter">
      <span>H</span><span>e</span><span>l</span><span>l</span><span>o</span><span> </span><span>w</span><span>o</span><span>r</span><span>l</span><span>d</span><span>,</span><span> </span><span>t</span><span>h</span><span>i</span><span>s</span><span> </span><span>i</span><span>s</span><span> </span><span>o</span><span>n</span><span>l</span><span>y</span><span> </span><span>a</span><span> </span><span>t</span><span>e</span><span>s</span><span>t</span><span>.</span>
      <div class="cursor"></div>
    </div>
  </div>

  <script type="module" src="./index.js"></script>

</body>
</html>



================================================
FILE: examples/irregular-playback-typewriter/index.js
================================================
import {
  animate,
  createTimeline,
  utils,
  stagger,
  eases,
} from '../../lib/anime.esm.js';

const $spans = utils.$('span');
const $cursor = utils.$('.cursor');
const keystrokesSteps = $spans.length - 1;
const keystrokesInterval = 125;

createTimeline({
  playbackEase: eases.irregular(keystrokesSteps, 2),
})
.set($spans, { opacity: [0, 1] }, stagger(keystrokesInterval))
.add($cursor, {
  left: '100%',
  duration: keystrokesSteps * keystrokesInterval,
  ease: eases.steps(keystrokesSteps),
}, 0)
.init();

animate($cursor, {
  opacity: 0,
  duration: 750,
  ease: 'inIn(2)',
  loop: true,
  alternate: true,
});



================================================
FILE: examples/layered-css-transforms/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Layered CSS transforms / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .layered-animations {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 16rem;
      height: 16rem;
      transform: scale(1.75);
    }

    .layered-animations .shape {
      position: absolute;
      overflow: visible;
      width: 8rem;
      height: 8rem;
      stroke: currentColor;
      fill: transparent;
    }

    .layered-animations .small.shape {
      width: 1.5rem;
      height: 1.5rem;
      stroke: currentColor;
      stroke-width: 2px;
      fill: currentColor;
    }
  </style>
</head>
<body>

  <div class="layered-animations">
    <svg class="small shape color-red" viewBox="0 0 96 96">
      <rect width="48" height="48" x="24" y="24" fill-rule="evenodd" stroke-linecap="square"/>
    </svg>
    <svg class="small shape color-red" viewBox="0 0 96 96">
      <polygon fill-rule="evenodd" points="48 17.28 86.4 80.11584 9.6 80.11584" stroke-linecap="square"/>
    </svg>
    <svg class="small shape color-red" viewBox="0 0 96 96">
      <circle cx="48" cy="48" r="32" fill-rule="evenodd" stroke-linecap="square"/>
    </svg>
    <svg class="shape" viewBox="0 0 96 96">
      <circle cx="48" cy="48" r="28" fill-rule="evenodd" stroke-linecap="square"/>
    </svg>
    <svg class="shape" viewBox="0 0 96 96">
      <rect width="48" height="48" x="24" y="24" fill-rule="evenodd" stroke-linecap="square"/>
    </svg>
    <svg class="shape" viewBox="0 0 96 96">
      <polygon fill-rule="evenodd" points="48 17.28 86.4 80.11584 9.6 80.11584" stroke-linecap="square"/>
    </svg>
  </div>

  <script type="module" src="./index.js"></script>

</body>
</html>



================================================
FILE: examples/layered-css-transforms/index.js
================================================
import { createTimeline, utils, createSpring } from '../../lib/anime.esm.js';

const shapeEls = document.querySelectorAll('.shape');
const triangleEl = document.querySelector('.layered-animations polygon');
const points = triangleEl.getAttribute('points').split(' ').map( v => +v );
const eases = ['inOutQuad', 'inOutCirc', 'inOutSine', createSpring()];

function createKeyframes(value) {
  var keyframes = [];
  for (let i = 0; i < 100; i++) {
    keyframes.push({
      to: value,
      ease: utils.randomPick(eases),
      duration: utils.random(300, 1600)
    });
  }
  return keyframes;
}

function animateShape(el) {

  const circleEl = el.querySelector('circle');
  const rectEl = el.querySelector('rect');
  const polyEl = el.querySelector('polygon');

  const animation = createTimeline({
    onComplete: () => animateShape(el),
  })
  .add(el, {
    translateX: createKeyframes(() => utils.random(-4, 4) + 'rem'),
    translateY: createKeyframes(() => utils.random(-4, 4) + 'rem'),
    rotate: createKeyframes(() => utils.random(-180, 180)),
  }, 0)
  if (circleEl) {
    animation.add(circleEl, {
      r: createKeyframes(() => utils.random(24, 56)),
    }, 0);
  }
  if (rectEl) {
    animation.add(rectEl, {
      width: createKeyframes(() => utils.random(56, 96)),
      height: createKeyframes(() => utils.random(56, 96)),
    }, 0);
  }
  if (polyEl) {
    animation.add(polyEl, {
      points: createKeyframes(() => {
        const s = utils.random(.9, 1.6, 3);
        return `
        ${points[0]*s} ${points[1]*s} ${points[2]*s} ${points[3]*s} ${points[4]*s} ${points[5]*s}
        `;
      }),
    }, 0);
  }

  animation.init();

}

for (var i = 0; i < shapeEls.length; i++) {
  animateShape(shapeEls[i]);
}




================================================
FILE: examples/onscroll-responsive-scope/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>onScroll responsive scope / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    .sticky-container {
      align-items: flex-start;
      height: 400lvh;
    }

    .sticky-content {
      perspective: 1000px;
      perspective-origin: 50%;
      transform-style: preserve-3d;
      position: sticky;
      top: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100lvh;
      width: 100%;
    }

    section {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      min-height: 100lvh;
      border-top: 1px dotted var(--red);
      border-bottom: 1px dotted var(--red);
    }

    section.spacer {
      min-height: 50lvh;
    }

    h2 {
      font-family: ui-monospace, monospace;
      font-size: min(5vw, 24px);
      max-width: 1000px;
    }

    .section-content {
      transform-style: preserve-3d;
      display: flex;
      width: 100%;
      height: 100lvh;
      justify-content: center;
    }

    .stack {
      --w: 22.5vh;
      --h: 30vh;
      position: relative;
      flex-grow: 0;
      flex-shrink: 0;
      transform-style: preserve-3d;
      width: calc(var(--w) * 1);
      height: calc(var(--h) * 1);
      will-change: transform;
    }

    .card {
      transform-style: preserve-3d;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 1rem;
      transform-origin: 50% 105% 0px;
      box-shadow: 0 .125em .75em 1px rgba(0,0,0,.05),
                  0 0 .125em 1px rgba(0,0,0,.1);
    }

    .card > div {
      transform-style: preserve-3d;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-position: center;
      border-radius: inherit;
    }

    .back {
      z-index: 0;
      background-image: url(card-back.svg);
      transform: rotateY(180deg);
      background-color: var(--white);
    }

    .front {
      z-index: 1;
      backface-visibility: hidden;
      background-image: url(card.svg);
      background-color: var(--white);
      background-size: 89%;
      background-repeat: no-repeat;
    }

  </style>
</head>
<body class="grid">
  <section class="spacer"></section>
  <section class="sticky-container">
    <div class="sticky-content">
      <div class="stack">
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
      </div>
    </div>
  </section>
  <section class="spacer"></section>
  <script type="module" src="./index.js"></script>
</body>


</html>



================================================
FILE: examples/onscroll-responsive-scope/index.js
================================================
import {
  animate,
  onScroll,
  stagger,
  createScope,
} from '../../src/anime.js';

createScope({
  mediaQueries: { landscape: '(orientation: landscape)' },
  defaults: { ease: 'out(3)', duration: 500 },
}).add((scope) => {

  let cardsAnimation;

  if (scope.matches.landscape) {
    cardsAnimation = animate('.card', {
      transformOrigin: '50% 150%',
      y: {
        from: stagger(['-40vh','40vh'], {from: 'center'}),
      },
      rotate: {
        to: stagger([-30, 30]),
        delay: stagger([0, 950], { from: 'last', start: 200 }),
        ease: 'inOut(3)',
      },
      x: ['-60vw', stagger(['-20%', '20%'])],
      delay: stagger(60, { from: 'last' }),
      duration: 750,
    });
  } else {
    cardsAnimation = animate('.card', {
      y: ['150vh', stagger(['20%', '-20%'])],
      rotate: {
        from: (_, i) => i % 2 ? '-20deg' : '20deg',
        ease: 'inOut(3)',
      },
      delay: stagger(50, { from: 'last' })
    });
  }

  onScroll({
    target: '.sticky-container',
    enter: 'top',
    leave: 'bottom',
    // debug: true,
    sync: .1
  }).link(cardsAnimation)

});


================================================
FILE: examples/onscroll-sticky/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>onScroll sticky / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
    <style>
    .sticky-container {
      align-items: flex-start;
      height: 400lvh;
    }

    .sticky-content {
      perspective: 1000px;
      perspective-origin: 50%;
      transform-style: preserve-3d;
      position: sticky;
      top: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100lvh;
      width: 100%;
    }
    section {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      min-height: 100lvh;
      border-top: 1px dotted var(--red);
      border-bottom: 1px dotted var(--red);
    }

    section.spacer {
      min-height: 50lvh;
    }

    h2 {
      font-family: ui-monospace, monospace;
      font-size: min(5vw, 24px);
      max-width: 1000px;
    }

    .section-content {
      transform-style: preserve-3d;
      display: flex;
      width: 100%;
      height: 100lvh;
      justify-content: center;
    }

    .stack {
      --w: 22.5vh;
      --h: 30vh;
      position: relative;
      flex-grow: 0;
      flex-shrink: 0;
      transform-style: preserve-3d;
      width: calc(var(--w) * 1);
      height: calc(var(--h) * 1);
      will-change: transform;
    }

    .card {
      transform-style: preserve-3d;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 1rem;
      transform-origin: 50% 105% 0px;
      box-shadow: 0 .125em .75em 1px rgba(0,0,0,.05),
                  0 0 .125em 1px rgba(0,0,0,.1);
    }

    .card > div {
      transform-style: preserve-3d;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-position: center;
      border-radius: inherit;
    }

    .back {
      z-index: 0;
      background-image: url(card-back.svg);
      transform: rotateY(180deg);
      background-color: var(--white);
    }

    .front {
      z-index: 1;
      backface-visibility: hidden;
      background-image: url(card.svg);
      background-color: var(--white);
      background-size: 89%;
      background-repeat: no-repeat;
    }
  </style>
</head>
<body class="grid">
  <section class="spacer"></section>
  <section class="sticky-container">
    <div class="sticky-content">
      <div class="stack">
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
        <div class="card"><div class="front"></div><div class="back"></div></div>
      </div>
    </div>
  </section>
  <section class="spacer"></section>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/onscroll-sticky/index.js
================================================
import {
  utils,
  stagger,
  onScroll,
  createTimeline,
  animate,
} from '../../src/anime.js';

utils.set('.card', {
  rotate: () => utils.random(-1, 1, 2),
  rotateZ: () => utils.random(-1, 1, 2),
  y: stagger(-.5, { from: 'last' }),
  z: stagger(1),
});

const brightness = v => `brightness(${v})`;

utils.set('.front', { filter: stagger([.75, 1], { modifier: brightness }) });
utils.set('.back',  { filter: stagger([1, .75], { modifier: brightness }) });

createTimeline({
  defaults: {
    ease: 'linear',
    duration: 500,
    composition: 'blend',
  },
  autoplay: onScroll({
    target: '.sticky-container',
    enter: 'top top',
    leave: 'bottom bottom',
    sync: .5,
    // debug: true,
  }),
})
.add('.stack', {
  rotateY: [-180, 0],
  ease: 'in(2)',
}, 0)
.add('.card', {
  rotate: 0,
  rotateZ: { to: stagger([0, -360], { from: 'last' }), ease: 'inOut(2)' },
  y: { to: '-60%', duration: 400 },
  transformOrigin: ['50% 100%', '50% 50%'],
  delay: stagger(1, { from: 'first' }),
}, 0)
.init()

utils.$('.card').forEach($card => {
  $card.onmouseenter = () => animate($card, {
    y: '-70%', duration: 350, composition: 'blend',
  });
  $card.onmouseleave = () => animate($card, {
    y: '-60%', duration: 750, composition: 'blend', delay: 75,
  });
})



================================================
FILE: examples/svg-line-drawing/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>SVG line drawing / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
    }
  </style>
</head>
<body>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/svg-line-drawing/index.js
================================================
import {
  svg,
  createTimeline,
  stagger,
  utils,
} from '../../lib/anime.esm.js';

function generateLines(numberOfLines) {
  const svgWidth = 1100;
  const svgHeight = 1100;
  const margin = 50; // Margin from the edges of the SVG
  const spacing = (svgWidth - margin * 2) / (numberOfLines - 1);

  let svgContent = `<svg width="${svgWidth}px" height="${svgHeight}px" viewBox="0 0 ${svgWidth} ${svgHeight}">
      <g id="lines" fill="none" fill-rule="evenodd">`;
  for (let i = 0; i < numberOfLines; i++) {
    const x = margin + i * spacing;
    svgContent += `<line x1="${x}" y1="${margin}" x2="${x}" y2="${svgHeight - margin}" class="line-v" stroke="#A4FF4F" stroke-linecap="butt" stroke-linejoin="round" stroke-width="10"></line>`;
  }

  svgContent += `</g></svg>`;

  return svgContent;
}

function generateCircles(numberOfCircles) {
  const svgWidth = 1100;
  const svgHeight = 1100;
  const centerX = svgWidth / 2;
  const centerY = svgHeight / 2;
  const maxRadius = 500;
  const step = maxRadius / numberOfCircles;

  let svgContent = `<svg width="${svgWidth}px" height="${svgHeight}px" viewBox="0 0 ${svgWidth} ${svgHeight}">
      <g id="circles" fill="none" fill-rule="evenodd">`;

  for (let i = 0; i < numberOfCircles; i++) {
    const radius = (i + 1) * step;
    svgContent += `<circle class="circle" stroke="#A4FF4F" stroke-linecap="butt" stroke-linejoin="round" stroke-width="10" cx="${centerX}" cy="${centerY}" r="${radius}"></circle>`;
  }

  svgContent += `</g></svg>`;

  return svgContent;
}

const svgLines = generateLines(100);
const svgCircles = generateCircles(50);

document.body.innerHTML += svgLines;
document.body.innerHTML += svgCircles;

createTimeline({
  playbackEase: 'out(4)',
  loop: 0,
  defaults: {
    ease: 'inOut(4)',
    duration: 10000,
    loop: true,
  }
})
.add(svg.createDrawable('.line-v'), {
  // strokeWidth: [0, 20, 20, 20, 0],
  draw: [
    '.5 .5',
    () => { const l = utils.random(.05, .45, 2); return `${.5 - l} ${.5 + l}` },
    '0.5 0.5',
  ],
  stroke: '#FF4B4B',
}, stagger([0, 8000], { start: 0, from: 'first' }))
.add(svg.createDrawable('.circle'), {
  draw: [
    () => { const v = utils.random(-1, -.5, 2); return `${v} ${v}`},
    () => `${utils.random(0, .25, 2)} ${utils.random(.5, .75, 2)}`,
    () => { const v = utils.random(1, 1.5, 2); return `${v} ${v}`},
  ],
  stroke: '#FF4B4B',
}, stagger([0, 8000], { start: 0 }))
.init()



================================================
FILE: examples/timeline-50K-stars/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Timeline 50K stars / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #animation {
      overflow: hidden;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 720px;
      height: 480px;
    }
    .star-button {
      --bg-1: #212830;
      --bg-2: #3D444D;
      position: absolute;
      display: flex;
      justify-content: space-between;
      align-content: center;
      width: fit-content;
      min-width: 220px;
      background: var(--bg-1);
      border: 2px solid var(--bg-2);
      border-radius: 10px;
      padding: 8px 30px 8px 22px;
      font-family: "system-ui", "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
      font-size: 26px;
      color: #FFFFFF;
      letter-spacing: 0;
      text-align: right;
      transform-origin: 50% 50%;
      height: 56px;
    }
    .star-button span {
      line-height: 1.4;
      font-variant-numeric: tabular-nums;
    }
    .star-button .label {
      padding: 0 20px;
      width: 120px;
      text-align: center;
    }
    .star-button .count {
      position: relative;
      display: inline-block;
      z-index: 2;
      padding: 0 10px;
      min-width: 40px;
      text-align: center;
    }
    .star-button .count::before {
      content: "";
      position: absolute;
      z-index: -1;
      top: -2px;
      left: -4px;
      right: -4px;
      bottom: -2px;
      display: block;
      border-radius: 20px;
      background-color: var(--bg-2);
    }
    .star-particle {
      position: absolute;
      z-index: 2;
      top: 50%;
      left: 22px;
      width: 36px;
      height: 36px;
      margin-top: -18px;
      overflow: visible;
    }
    .star-icon {
      color: #E3B342;
    }
    .star-icon polygon {
      transform-box: fill-box;
      transform-origin: 50% 50%;
    }
    .cursor {
      position: absolute;
      z-index: 2;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 40px;
      margin: 0 0 0 -10px;
      background-image: url(cursor.png);
      background-size: 80px 40px;
    }
  </style>
</head>
<body>
  <div id="animation">
    <div class="star-button">
      <svg class="star-icon" width="36px" height="36px" viewBox="0 0 36 36">
        <g id="start" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round">
          <polygon stroke="currentColor" stroke-width="3" points="8.75528701 32.6404834 10.3867069 22.2854985 3 15.0120846 13.4003021 13.4259819 18 4 22.5996979 13.4259819 33 15.0120846 25.6132931 22.2175227 27.244713 32.6404834 18 27.7915408"></polygon>
        </g>
      </svg>
      <span class="label">Star</span>
      <span class="count">0</span>
    </div>
    <div class="cursor"></div>
  </div>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/timeline-50K-stars/index.js
================================================
import { animate, createTimeline, utils } from '../../lib/anime.esm.js';

const [$animation] = utils.$('#animation');
const [$button] = utils.$('.star-button');
const [$cursor] = utils.$('.cursor');
const [$count] = utils.$('.count');
const [$label] = utils.$('.label');
const [$star] = utils.$('.star-icon');
const [$starPoly] = utils.$('.star-icon polygon');

const data = {
  count: 1,
  add: 1,
  mult: 0,
}

const increaseCount = (cursor) => {
  $label.innerHTML = `Starred`;
  $starPoly.setAttribute('fill', 'currentColor');
  const $starClone = /** @type {HTMLElement} */($star.cloneNode(true));
  $starClone.classList.add('star-particle');
  $animation.appendChild($starClone);
  const left = /** @type {HTMLElement} */($button).offsetLeft + 4;
  animate($starClone, {
    translateY: { to: utils.random(-175, -225), ease: 'out'},
    translateX: [
      { from: left, to: left + utils.random(-40, 40), ease: 'out'},
      { to: left + utils.random(-40, 40), ease: 'inOut(2)'}
    ],
    color: { from: '#FFDD8E' },
    scale: [1, 1.2, 1, .8],
    ease: 'inOut(2)',
    opacity: 0,
  })
  if (cursor) {
    const $cursorClone = /** @type {HTMLElement} */($cursor.cloneNode(true));
    $animation.appendChild($cursorClone);
    createTimeline()
    .add($cursorClone, {
      x: { to: [utils.random(-250, 250), utils.random(-70, 70)], ease: 'out(3)' },
      y: { to: [utils.random(0, 1) ? -300 : 300, utils.random(0, 10)], ease: 'out(6)' },
      backgroundPosition: { to: '-40px 0px', ease: 'steps(1)', duration: 150 },
      opacity: [0, 1],
      duration: 400,
    })
    .add($cursorClone, {
      x: { to: utils.random(-250, 250), ease: 'inOut(3)' },
      y: { to: utils.random(0, 1) ? -300 : 300, ease: 'inOut(6)' },
      backgroundPosition: { to: '0px 0px', ease: 'steps(1)', duration: 50 },
      opacity: 0,
      duration: 750,
    })
    .init()
  }
}

utils.set($cursor, {
  x: 300,
  y: -250,
});

const clickAnimation = createTimeline({
  loop: 500,
  autoplay: false,
  onLoop: self => self.refresh()
})
.add('.star-button', {
  scale: [1, .97, 1],
  rotate: () => utils.random(-data.mult, data.mult),
  ease: 'out(4)',
}, 0)
.call(() => increaseCount(true), 0)

createTimeline()
.add($cursor, {
  x: { to: 0, ease: 'out(3)' },
  y: { to: 10, ease: 'out(6)' },
  backgroundPosition: { to: '-40px 0px', ease: 'steps(1)', duration: 250 },
  duration: 750,
})
.add('.star-button', {
  scale: [1, .97, 1],
  ease: 'out(4)',
  duration: 750,
}, '<+=500')
.set($count, { innerHTML: '1' }, '<<+=500')
.call(() => increaseCount(true), '<<')
.label('CLICK START', '+=250')
.set($count, { innerHTML: '2' }, 'CLICK START')
.set($count, { innerHTML: '3' }, 'CLICK START+=400')
.set($count, { innerHTML: '4' }, 'CLICK START+=500')
.set($count, { innerHTML: '5' }, 'CLICK START+=600')
.set($count, { innerHTML: '6' }, 'CLICK START+=700')
.add($cursor, {
  x: { to: -150, ease: 'inOut(3)' },
  y: { to: 250, ease: 'inOut(6)' },
  backgroundPosition: { to: '0px 0px', ease: 'steps(1)', duration: 50 },
  duration: 750,
}, 'CLICK START-=500')
.add(data, {
  mult: [0, 0, 1.5, .25, 0, 0],
  duration: 10000,
  ease: 'cubicBezier(1,0,0,1)',
}, 'CLICK START')
.add(clickAnimation, {
  progress: 1,
  duration: 10000,
  ease: 'cubicBezier(.65,0,0,1)',
}, 'CLICK START')
.add($count, {
  innerHTML: ['5', '40000'],
  modifier: utils.round(0),
  ease: 'cubicBezier(1,0,1,1)',
  duration: 5000
}, 'CLICK START+=800')
.add($count, {
  innerHTML: '49999',
  modifier: utils.round(0),
  ease: 'cubicBezier(0,1,0,1)',
  duration: 4250
}, '<')
.add($cursor, {
  x: { to: 0, ease: 'out(3)' },
  y: { to: 10, ease: 'out(6)' },
  backgroundPosition: { to: '-40px 0px', ease: 'steps(1)', duration: 250 },
  duration: 750,
}, '<+=250')
.add('.star-button', {
  scale: [1, .97, 1],
  ease: 'out(4)',
  duration: 750,
}, '<+=500')
.set($count, { innerHTML: '50000' }, '<<+=500')
.call(() => increaseCount(false), '<<')
.add($cursor, {
  x: { to: -150, ease: 'inOut(3)' },
  y: { to: 250, ease: 'inOut(6)' },
  backgroundPosition: { to: '0px 0px', ease: 'steps(1)', duration: 250 },
  duration: 750,
}, '<<+=1000')
.add($animation, {
  scale: 1.25,
  translateZ: 0,
  duration: 13000,
  ease: 'inOutQuad',
}, 'CLICK START')



================================================
FILE: examples/timeline-refresh-starlings/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Timeline refresh starlings / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      overflow: hidden;
      position: absolute;
      width: 100%;
      height: 100dvh;
      background: linear-gradient(
        to top,
        #DCB697 0%,
        #9BA5AE 35%,
        #3E5879 100%
      );
    }
    div {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 1em;
      height: 1em;
      margin: -.5em 0 0 -.5em;
      font-size: clamp(3px, 2vw, 4px);
      border-radius: 1em;
      background-color: currentColor;
    }
  </style>
</head>
<body>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/timeline-refresh-starlings/index.js
================================================
import {
  createTimeline,
  stagger,
  utils,
} from '../../lib/anime.esm.js';

const { random, cos, sin, sqrt, PI } = Math;
const count = 2500;
const duration = 3000;
const win = { w: window.innerWidth * .26, h: window.innerHeight * .26 };
const target = { x: 0, y: 0, r: win.w * .25 };
const radius = Symbol();
const theta = Symbol();

for (let i = 0; i < count; i++) {
  const $el = document.createElement('div');
  const h = utils.random(15, 25);
  const l = utils.random(10, 18);
  utils.set($el, { background: `hsl(${h}, 60%, ${l}%)` });
  $el[theta] = random() * PI * 2;
  $el[radius] = target.r * sqrt(random());
  document.body.appendChild($el);
}

const tl = createTimeline({
  defaults: {
    loop: true,
    ease: 'inOut(1.3)',
    onLoop: self => self.refresh(),
  },
});

tl.add('div', {
  x: $el => target.x + ($el[radius] * cos($el[theta])),
  y: $el => target.y + ($el[radius] * sin($el[theta])),
  duration: () => duration + utils.random(-100, 100),
  ease: 'inOut(1.5)',
  onLoop: self => {
    const t = self.targets[0];
    t[theta] = random() * PI * 2;
    t[radius] = target.r * sqrt(random());
    self.refresh();
  },
}, stagger((duration / count) * 1.125))
.add(target, {
  r: () => win.w * utils.random(.05, .5, 2),
  duration: 1250,
}, 0)
.add(target, {
  x: () => utils.random(-win.w, win.w),
  modifier: x => x + sin(tl.currentTime * .0007) * (win.w * .65),
  duration: 2800,
}, 0)
.add(target, {
  y: () => utils.random(-win.h, win.h),
  modifier: y => y + cos(tl.currentTime * .00012) * (win.h * .65),
  duration: 1800,
}, 0);

tl.seek(20000)


================================================
FILE: examples/timeline-seamless-loop/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Timeline seamless loop / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    #test-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      width: 1px;
      height: 100vh;
    }

    #test-wrapper:before,
    #test-wrapper:after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      display: block;
      transform: translate(-50%, -50%);
      border: 1px solid #FFF;
      border-radius: 50%;
    }
    #test-wrapper:before {
      width: 13vh;
      height: 13vh;
    }
    #test-wrapper:after {
      width: 18vh;
      height: 18vh;
    }
    .el {
      position: absolute;
      opacity: 1;
      width: 12px;
      height: 26vh;
      top: 50%;
      left: 50%;
      margin-left: -6px;
      margin-top: -13vh;
      transform-origin: 50% 50%;
      background: white;
    }
  </style>
</head>
<body>
  <div id="test-wrapper"></div>
  <script type="module" src="index.js"></script>
</body>
</html>



================================================
FILE: examples/timeline-seamless-loop/index.js
================================================
import { createTimeline, utils, stagger } from '../../lib/anime.esm.js';

const wrapperEl = document.querySelector('#test-wrapper');
const numberOfEls = 500;
const loopDuration = 6000;
const animDuration = loopDuration * .2;
const delay = loopDuration / numberOfEls;

let tl = createTimeline({
  defaults: {
    ease: 'inOutSine',
    loopDelay: (loopDuration * .2) - animDuration,
    duration: animDuration
  },
})
.add(wrapperEl, {
  rotate: -360,
  loop: true,
  duration: 24000,
  ease: 'linear',
})

function createEl(i) {
  let el = document.createElement('div');
  const strength = utils.round(+stagger([0, 1], {
    ease: 'inOutSine',
    reversed: true,
    from: 'center',
  })(el, i, numberOfEls), 100);
  const hue = utils.round(360 / numberOfEls * i, 2);
  const bgColor = 'hsl('+hue+',40%,60%)';
  const rotate = (360 / numberOfEls) * i;
  const translateY = '-100%';
  const scale = 1;
  el.classList.add('el');
  utils.set(el, { backgroundColor: bgColor, rotate, translateY, scale });
  tl.add(el, {
    backgroundColor: [
      {to: 'hsl('+hue+','+(40+(20*strength))+'%,'+(60+(20*strength))+'%)'},
      {to: bgColor}
    ],
    rotate: [
      {to: rotate+(10*strength)},
      {to: rotate}
    ],
    translateY: [
      {to: '-100' - (10 * strength) + '%'},
      {to: translateY}
    ],
    scale: [
      {to: [scale, scale+(.25*strength)]},
      {to: scale}
    ],
    loop: -1,
  }, delay * i);
  wrapperEl.appendChild(el);
};

for (let i = 0; i < numberOfEls; i++) createEl(i);

tl.seek(10000);


================================================
FILE: examples/timeline-stress-test/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <title>Timeline stress test / Anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="../assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      overflow: hidden;
      position: absolute;
      width: 100%;
      height: 100dvh;
    }
    div {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 1em;
      height: 1em;
      margin: -.5em 0 0 -.5em;
      font-size: 20px;
      border-radius: 1em;
      background-color: currentColor;
    }
  </style>
</head>
<body>
  <script type="module" src="./index.js"></script>
</body>
</html>



================================================
FILE: examples/timeline-stress-test/index.js
================================================
import {
  createTimeline,
  stagger,
  utils,
} from '../../lib/anime.esm.js';

const count = 2024;
const duration = 10000;
const distance = 20;
const angle = utils.mapRange(0, count, 0, Math.PI * 100);

for (let i = 0; i < count; i++) {
  const $el = document.createElement('div');
  const hue = utils.round(360 / count * i, 0);
  utils.set($el, { background: `hsl(${hue}, 60%, 60%)` });
  document.body.appendChild($el);
}

createTimeline()
.add('div', {
  x: (_, i) => `${Math.sin(angle(i)) * distance}rem`,
  y: (_, i) => `${Math.cos(angle(i)) * distance}rem`,
  scale: [0, .4, .2, .9, 0],
  playbackEase: 'inOutSine',
  loop: true,
  duration,
}, stagger([0, duration]))
.init()
.seek(10000);



================================================
FILE: src/additive.js
================================================
/// <reference path='./types.js' />

import {
  minValue,
  noop,
  valueTypes,
  tickModes,
} from './consts.js';

import {
  cloneArray,
} from './helpers.js';

import {
  render,
} from './render.js';

export const additive = {
  animation: null,
  update: noop,
}

/**
 * @typedef AdditiveAnimation
 * @property {Number} duration
 * @property {Number} _offset
 * @property {Number} _delay
 * @property {Tween} _head
 * @property {Tween} _tail
 */

/**
 * @param  {TweenAdditiveLookups} lookups
 * @return {AdditiveAnimation}
 */
export const addAdditiveAnimation = lookups => {
  let animation = additive.animation;
  if (!animation) {
    animation = {
      duration: minValue,
      computeDeltaTime: noop,
      _offset: 0,
      _delay: 0,
      _head: null,
      _tail: null,
    }
    additive.animation = animation;
    additive.update = () => {
      lookups.forEach(propertyAnimation => {
        for (let propertyName in propertyAnimation) {
          const tweens = propertyAnimation[propertyName];
          const lookupTween = tweens._head;
          if (lookupTween) {
            const valueType = lookupTween._valueType;
            const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
            let additiveValue = lookupTween._fromNumber;
            let tween = tweens._tail;
            while (tween && tween !== lookupTween) {
              if (additiveValues) {
                for (let i = 0, l = tween._numbers.length; i < l; i++) additiveValues[i] += tween._numbers[i];
              } else {
                additiveValue += tween._number;
              }
              tween = tween._prevAdd;
            }
            lookupTween._toNumber = additiveValue;
            lookupTween._toNumbers = additiveValues;
          }
        }
      });
      // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop
      render(animation, 1, 1, 0, tickModes.FORCE);
    }
  }
  return animation;
}



================================================
FILE: src/animatable.js
================================================
/// <reference path='./types.js' />

import {
  compositionTypes,
  noop,
} from './consts.js';

import {
  globals,
} from './globals.js';

import {
  isKey,
  isObj,
  isStr,
  isUnd,
  mergeObjects,
  forEachChildren,
  isArr,
} from './helpers.js';

import {
  JSAnimation,
} from './animation.js';

import {
  parseEasings,
} from './eases.js';

export class Animatable {
  /**
   * @param {TargetsParam} targets
   * @param {AnimatableParams} parameters
   */
  constructor(targets, parameters) {
    if (globals.scope) globals.scope.revertibles.push(this);
    /** @type {AnimationParams} */
    const globalParams = {};
    const properties = {};
    this.targets = [];
    this.animations = {};
    if (isUnd(targets) || isUnd(parameters)) return;
    for (let propName in parameters) {
      const paramValue = parameters[propName];
      if (isKey(propName)) {
        properties[propName] = paramValue;
      } else {
        globalParams[propName] = paramValue;
      }
    }
    for (let propName in properties) {
      const propValue = properties[propName];
      const isObjValue = isObj(propValue);
      /** @type {TweenParamsOptions} */
      let propParams = {};
      let to = '+=0';
      if (isObjValue) {
        const unit = propValue.unit;
        if (isStr(unit)) to += unit;
      } else {
        propParams.duration = propValue;
      }
      propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;
      const animParams = mergeObjects(globalParams, propParams);
      animParams.composition = compositionTypes.replace;
      animParams.autoplay = false;
      const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();
      if (!this.targets.length) this.targets.push(...animation.targets);
      /** @type {AnimatableProperty} */
      this[propName] = (to, duration, ease) => {
        const tween = /** @type {Tween} */(animation._head);
        if (isUnd(to) && tween) {
          const numbers = tween._numbers;
          if (numbers && numbers.length) {
            return numbers;
          } else {
            return tween._modifier(tween._number);
          }
        } else {
          forEachChildren(animation, (/** @type {Tween} */tween) => {
            if (isArr(to)) {
              for (let i = 0, l = /** @type {Array} */(to).length; i < l; i++) {
                if (!isUnd(tween._numbers[i])) {
                  tween._fromNumbers[i] = /** @type {Number} */(tween._modifier(tween._numbers[i]));
                  tween._toNumbers[i] = to[i];
                }
              }
            } else {
              tween._fromNumber = /** @type {Number} */(tween._modifier(tween._number));
              tween._toNumber = /** @type {Number} */(to);
            }
            if (!isUnd(ease)) tween._ease = parseEasings(ease);
            tween._currentTime = 0;
          });
          if (!isUnd(duration)) animation.stretch(duration);
          animation.reset(1).resume();
          return this;
        }
      };
    }
  }

  revert() {
    for (let propName in this.animations) {
      this[propName] = noop;
      this.animations[propName].revert();
    }
    this.animations = {};
    this.targets.length = 0;
    return this;
  }
}

/**
 * @param {TargetsParam} targets
 * @param {AnimatableParams} parameters
 * @return {AnimatableObject}
 */
export const createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */(new Animatable(targets, parameters));


================================================
FILE: src/animation.js
================================================
/// <reference path='./types.js' />

import {
  K,
  minValue,
  tweenTypes,
  valueTypes,
  compositionTypes,
  isDomSymbol,
  transformsSymbol,
  emptyString,
  transformsFragmentStrings,
} from './consts.js';

import {
  mergeObjects,
  cloneArray,
  isArr,
  isObj,
  isUnd,
  isKey,
  addChild,
  forEachChildren,
  clampInfinity,
  clampZero,
  isNum,
  round,
} from './helpers.js';

import {
  globals,
} from './globals.js';

import {
  registerTargets,
} from './targets.js';

import {
  parseEasings,
} from './eases.js';

import {
  getRelativeValue,
  getFunctionValue,
  getOriginalAnimatableValue,
  getTweenType,
  setValue,
  decomposeRawValue,
  decomposeTweenValue,
  decomposedOriginalValue,
  createDecomposedValueTargetObject,
} from './values.js';

import {
  sanitizePropertyName,
} from './properties.js';

import {
  convertValueUnit,
} from './units.js';

import {
  composeTween,
  getTweenSiblings,
  overrideTween,
} from './compositions.js';

import {
  additive,
} from './additive.js';

import {
  Timer,
} from './timer.js';

/**
 * @template {Renderable} T
 * @param {T} renderable
 * @return {T}
 */
export const cleanInlineStyles = renderable => {
  // Allow cleanInlineStyles() to be called on timelines
  if (renderable._hasChildren) {
    forEachChildren(renderable, cleanInlineStyles, true);
  } else {
    const animation = /** @type {JSAnimation} */(renderable);
    animation.pause();
    forEachChildren(animation, (/** @type {Tween} */tween) => {
      const tweenProperty = tween.property;
      const tweenTarget = tween.target;
      if (tweenTarget[isDomSymbol]) {
        const targetStyle = /** @type {DOMTarget} */(tweenTarget).style;
        const originalInlinedValue = animation._inlineStyles[tweenProperty];
        if (tween._tweenType === tweenTypes.TRANSFORM) {
          const cachedTransforms = tweenTarget[transformsSymbol];
          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
            delete cachedTransforms[tweenProperty];
          } else {
            cachedTransforms[tweenProperty] = originalInlinedValue;
          }
          if (tween._renderTransforms) {
            if (!Object.keys(cachedTransforms).length) {
              targetStyle.removeProperty('transform');
            } else {
              let str = emptyString;
              for (let key in cachedTransforms) {
                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';
              }
              targetStyle.transform = str;
            }
          }
        } else {
          if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
            targetStyle.removeProperty(tweenProperty);
          } else {
            targetStyle[tweenProperty] = originalInlinedValue;
          }
        }
        if (animation._tail === tween) {
          animation.targets.forEach(t => {
            if (t.getAttribute && t.getAttribute('style') === emptyString) {
              t.removeAttribute('style');
            };
          });
        }
      }
    })
  }
  return renderable;
}

// Defines decomposed values target objects only once and mutate their properties later to avoid GC
// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object
const fromTargetObject = createDecomposedValueTargetObject();
const toTargetObject = createDecomposedValueTargetObject();
const toFunctionStore = { func: null };
const keyframesTargetArray = [null];
const fastSetValuesArray = [null, null];
/** @type {TweenKeyValue} */
const keyObjectTarget = { to: null };

let tweenId = 0;
let keyframes;
/** @type {TweenParamsOptions & TweenValues} */
let key;

/**
 * @param {DurationKeyframes | PercentageKeyframes} keyframes
 * @param {AnimationParams} parameters
 * @return {AnimationParams}
 */
const generateKeyframes = (keyframes, parameters) => {
  /** @type {AnimationParams} */
  const properties = {};
  if (isArr(keyframes)) {
    const propertyNames = [].concat(.../** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);
    for (let i = 0, l = propertyNames.length; i < l; i++) {
      const propName = propertyNames[i];
      const propArray = /** @type {DurationKeyframes} */(keyframes).map(key => {
        /** @type {TweenKeyValue} */
        const newKey = {};
        for (let p in key) {
          const keyValue = /** @type {TweenPropValue} */(key[p]);
          if (isKey(p)) {
            if (p === propName) {
              newKey.to = keyValue;
            }
          } else {
            newKey[p] = keyValue;
          }
        }
        return newKey;
      });
      properties[propName] = /** @type {ArraySyntaxValue} */(propArray);
    }

  } else {
    const totalDuration = /** @type {Number} */(setValue(parameters.duration, globals.defaults.duration));
    const keys = Object.keys(keyframes)
    .map(key => { return {o: parseFloat(key) / 100, p: keyframes[key]} })
    .sort((a, b) => a.o - b.o);
    keys.forEach(key => {
      const offset = key.o;
      const prop = key.p;
      for (let name in prop) {
        if (isKey(name)) {
          let propArray = /** @type {Array} */(properties[name]);
          if (!propArray) propArray = properties[name] = [];
          const duration = offset * totalDuration;
          let length = propArray.length;
          let prevKey = propArray[length - 1];
          const keyObj = { to: prop[name] };
          let durProgress = 0;
          for (let i = 0; i < length; i++) {
            durProgress += propArray[i].duration;
          }
          if (length === 1) {
            keyObj.from = prevKey.to;
          }
          if (prop.ease) {
            keyObj.ease = prop.ease;
          }
          keyObj.duration = duration - (length ? durProgress : 0);
          propArray.push(keyObj);
        }
      }
      return key;
    });

    for (let name in properties) {
      const propArray = /** @type {Array} */(properties[name]);
      let prevEase;
      // let durProgress = 0
      for (let i = 0, l = propArray.length; i < l; i++) {
        const prop = propArray[i];
        // Emulate WAPPI easing parameter position
        const currentEase = prop.ease;
        prop.ease = prevEase ? prevEase : undefined;
        prevEase = currentEase;
        // durProgress += prop.duration;
        // if (i === l - 1 && durProgress !== totalDuration) {
        //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })
        // }
      }
      if (!propArray[0].duration) {
        propArray.shift();
      }
    }

  }

  return properties;
}

export class JSAnimation extends Timer {
  /**
   * @param {TargetsParam} targets
   * @param {AnimationParams} parameters
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   * @param {Boolean} [fastSet=false]
   * @param {Number} [index=0]
   * @param {Number} [length=0]
   */
  constructor(
    targets,
    parameters,
    parent,
    parentPosition,
    fastSet = false,
    index = 0,
    length = 0
  ) {

    super(/** @type {TimerParams&AnimationParams} */(parameters), parent, parentPosition);

    const parsedTargets = registerTargets(targets);
    const targetsLength = parsedTargets.length;

    // If the parameters object contains a "keyframes" property, convert all the keyframes values to regular properties

    const kfParams = /** @type {AnimationParams} */(parameters).keyframes;
    const params = /** @type {AnimationParams} */(kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */(kfParams), parameters), parameters) : parameters);

    const {
      delay,
      duration,
      ease,
      playbackEase,
      modifier,
      composition,
      onRender,
    } = params;

    const animDefaults = parent ? parent.defaults : globals.defaults;
    const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
    const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;
    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);
    const tEasing = hasSpring ? /** @type {Spring} */(ease).ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);
    const tDuration = hasSpring ? /** @type {Spring} */(ease).duration : setValue(duration, animDefaults.duration);
    const tDelay = setValue(delay, animDefaults.delay);
    const tModifier = modifier || animDefaults.modifier;
    // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation
    const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
    // TODO: Do not create an empty object until we know the animation will generate inline styles
    const animInlineStyles = {};
    // const absoluteOffsetTime = this._offset;
    const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);

    let iterationDuration = NaN;
    let iterationDelay = NaN;
    let animationAnimationLength = 0;
    let shouldTriggerRender = 0;

    for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {

      const target = parsedTargets[targetIndex];
      const ti = index || targetIndex;
      const tl = length || targetsLength;

      let lastTransformGroupIndex = NaN;
      let lastTransformGroupLength = NaN;

      for (let p in params) {

        if (isKey(p)) {

          const tweenType = getTweenType(target, p);

          const propName = sanitizePropertyName(p, target, tweenType);

          let propValue = params[p];

          const isPropValueArray = isArr(propValue);

          if (fastSet && !isPropValueArray) {
            fastSetValuesArray[0] = propValue;
            fastSetValuesArray[1] = propValue;
            propValue = fastSetValuesArray;
          }

          // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })
          // Normalize property values to valid keyframe syntax:
          // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]
          // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];
          if (isPropValueArray) {
            const arrayLength = /** @type {Array} */(propValue).length;
            const isNotObjectValue = !isObj(propValue[0]);
            // Convert [x, y] to [{to: [x, y]}]
            if (arrayLength === 2 && isNotObjectValue) {
              keyObjectTarget.to = /** @type {TweenParamValue} */(/** @type {unknown} */(propValue));
              keyframesTargetArray[0] = keyObjectTarget;
              keyframes = keyframesTargetArray;
            // Convert [x, y, z] to [[x, y], z]
            } else if (arrayLength > 2 && isNotObjectValue) {
              keyframes = [];
              /** @type {Array.<Number>} */(propValue).forEach((v, i) => {
                if (!i) {
                  fastSetValuesArray[0] = v;
                } else if (i === 1) {
                  fastSetValuesArray[1] = v;
                  keyframes.push(fastSetValuesArray);
                } else {
                  keyframes.push(v);
                }
              });
            } else {
              keyframes = /** @type {Array.<TweenKeyValue>} */(propValue);
            }
          } else {
            keyframesTargetArray[0] = propValue;
            keyframes = keyframesTargetArray;
          }

          let siblings = null;
          let prevTween = null;
          let firstTweenChangeStartTime = NaN;
          let lastTweenChangeEndTime = 0;
          let tweenIndex = 0;

          for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {

            const keyframe = keyframes[tweenIndex];

            if (isObj(keyframe)) {
              key = keyframe;
            } else {
              keyObjectTarget.to = /** @type {TweenParamValue} */(keyframe);
              key = keyObjectTarget;
            }

            toFunctionStore.func = null;

            const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);

            let tweenToValue;
            // Allows function based values to return an object syntax value ({to: v})
            if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
              key = computedToValue;
              tweenToValue = computedToValue.to;
            } else {
              tweenToValue = computedToValue;
            }
            const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
            const keyEasing = key.ease;
            const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */(keyEasing).ease);
            // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time
            const tweenEasing = hasSpring ? /** @type {Spring} */(keyEasing).ease : keyEasing || tEasing;
            // Calculate default individual keyframe duration by dividing the tl of keyframes
            const tweenDuration = hasSpring ? /** @type {Spring} */(keyEasing).duration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);
            // Default delay value should only be applied to the first tween
            const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);
            const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
            const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
            // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper
            const tweenModifier = key.modifier || tModifier;
            const hasFromvalue = !isUnd(tweenFromValue);
            const hasToValue = !isUnd(tweenToValue);
            const isFromToArray = isArr(tweenToValue);
            const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);
            const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
            const absoluteStartTime = absoluteOffsetTime + tweenStartTime;

            // Force a onRender callback if the animation contains at least one from value and autoplay is set to false
            if (!shouldTriggerRender && (hasFromvalue || isFromToArray)) shouldTriggerRender = 1;

            let prevSibling = prevTween;

            if (tweenComposition !== compositionTypes.none) {
              if (!siblings) siblings = getTweenSiblings(target, propName);
              let nextSibling = siblings._head;
              // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time
              while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                prevSibling = nextSibling;
                nextSibling = nextSibling._nextRep;
                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time
                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                  while (nextSibling) {
                    overrideTween(nextSibling);
                    // This will ends both the current while loop and the upper one once all the next sibllings have been overriden
                    nextSibling = nextSibling._nextRep;
                  }
                }
              }
            }

            // Decompose values
            if (isFromToValue) {
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
              decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
              if (fromTargetObject.t === valueTypes.NUMBER) {
                if (prevSibling) {
                  if (prevSibling._valueType === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = prevSibling._unit;
                  }
                } else {
                  decomposeRawValue(
                    getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),
                    decomposedOriginalValue
                  );
                  if (decomposedOriginalValue.t === valueTypes.UNIT) {
                    fromTargetObject.t = valueTypes.UNIT;
                    fromTargetObject.u = decomposedOriginalValue.u;
                  }
                }
              }
            } else {
              if (hasToValue) {
                decomposeRawValue(tweenToValue, toTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, toTargetObject);
                } else {
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);
                }
              }
              if (hasFromvalue) {
                decomposeRawValue(tweenFromValue, fromTargetObject);
              } else {
                if (prevTween) {
                  decomposeTweenValue(prevTween, fromTargetObject);
                } else {
                  decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                  // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);
                }
              }
            }

            // Apply operators
            if (fromTargetObject.o) {
              fromTargetObject.n = getRelativeValue(
                !prevSibling ? decomposeRawValue(
                  getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles),
                  decomposedOriginalValue
                ).n : prevSibling._toNumber,
                fromTargetObject.n,
                fromTargetObject.o
              );
            }

            if (toTargetObject.o) {
              toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
            }

            // Values omogenisation in cases of type difference between "from" and "to"
            if (fromTargetObject.t !== toTargetObject.t) {
              if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                notComplexValue.t = valueTypes.COMPLEX;
                notComplexValue.s = cloneArray(complexValue.s);
                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
              } else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
                notUnitValue.t = valueTypes.UNIT;
                notUnitValue.u = unitValue.u;
              } else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
                notColorValue.t = valueTypes.COLOR;
                notColorValue.s = colorValue.s;
                notColorValue.d = [0, 0, 0, 1];
              }
            }

            // Unit conversion
            if (fromTargetObject.u !== toTargetObject.u) {
              let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
              valueToConvert = convertValueUnit(/** @type {DOMTarget} */(target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);
              // TODO:
              // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);
            }

            // Fill in non existing complex values
            if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {
              const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
              const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
              // TODO: Check if n should be used instead of 0 for default complex values
              shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
              shortestValue.s = cloneArray(longestValue.s);
            }

            // Tween factory

            // Rounding is necessary here to minimize floating point errors
            const tweenUpdateDuration = round(+tweenDuration || minValue, 12);

            /** @type {Tween} */
            const tween = {
              parent: this,
              id: tweenId++,
              property: propName,
              target: target,
              _value: null,
              _func: toFunctionStore.func,
              _ease: parseEasings(tweenEasing),
              _fromNumbers: cloneArray(fromTargetObject.d),
              _toNumbers: cloneArray(toTargetObject.d),
              _strings: cloneArray(toTargetObject.s),
              _fromNumber: fromTargetObject.n,
              _toNumber: toTargetObject.n,
              _numbers: cloneArray(fromTargetObject.d), // For additive tween and animatables
              _number: fromTargetObject.n, // For additive tween and animatables
              _unit: toTargetObject.u,
              _modifier: tweenModifier,
              _currentTime: 0,
              _startTime: tweenStartTime,
              _delay: +tweenDelay,
              _updateDuration: tweenUpdateDuration,
              _changeDuration: tweenUpdateDuration,
              _absoluteStartTime: absoluteStartTime,
              // NOTE: Investigate bit packing to stores ENUM / BOOL
              _tweenType: tweenType,
              _valueType: toTargetObject.t,
              _composition: tweenComposition,
              _isOverlapped: 0,
              _isOverridden: 0,
              _renderTransforms: 0,
              _prevRep: null, // For replaced tween
              _nextRep: null, // For replaced tween
              _prevAdd: null, // For additive tween
              _nextAdd: null, // For additive tween
              _prev: null,
              _next: null,
            }

            if (tweenComposition !== compositionTypes.none) {
              composeTween(tween, siblings);
            }

            if (isNaN(firstTweenChangeStartTime)) {
              firstTweenChangeStartTime = tween._startTime;
            }
            // Rounding is necessary here to minimize floating point errors
            lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);
            prevTween = tween;
            animationAnimationLength++;

            addChild(this, tween);

          }

          // Update animation timings with the added tweens properties

          if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
            iterationDelay = firstTweenChangeStartTime;
          }

          if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
            iterationDuration = lastTweenChangeEndTime;
          }

          // TODO: Find a way to inline tween._renderTransforms = 1 here
          if (tweenType === tweenTypes.TRANSFORM) {
            lastTransformGroupIndex = animationAnimationLength - tweenIndex;
            lastTransformGroupLength = animationAnimationLength;
          }

        }

      }

      // Set _renderTransforms to last transform property to correctly render the transforms list
      if (!isNaN(lastTransformGroupIndex)) {
        let i = 0;
        forEachChildren(this, (/** @type {Tween} */tween) => {
          if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
            tween._renderTransforms = 1;
            if (tween._composition === compositionTypes.blend) {
              forEachChildren(additive.animation, (/** @type {Tween} */additiveTween) => {
                if (additiveTween.id === tween.id) {
                  additiveTween._renderTransforms = 1;
                }
              });
            }
          }
          i++;
        });
      }

    }

    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }

    if (iterationDelay) {
      forEachChildren(this, (/** @type {Tween} */tween) => {
        // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too
        if (!(tween._startTime - tween._delay)) {
          tween._delay -= iterationDelay;
        }
        tween._startTime -= iterationDelay;
      });
      iterationDuration -= iterationDelay;
    } else {
      iterationDelay = 0;
    }

    // Prevents iterationDuration to be NaN if no valid animatable props have been provided
    // Prevents _iterationCount to be NaN if no valid animatable props have been provided
    if (!iterationDuration) {
      iterationDuration = minValue;
      this.iterationCount = 0;
    }
    /** @type {TargetsArray} */
    this.targets = parsedTargets;
    /** @type {Number} */
    this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;
    /** @type {Callback<this>} */
    this.onRender = onRender || animDefaults.onRender;
    /** @type {EasingFunction} */
    this._ease = animEase;
    /** @type {Number} */
    this._delay = iterationDelay;
    // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.
    // this._delay = parent ? 0 : iterationDelay;
    // this._offset += parent ? iterationDelay : 0;
    /** @type {Number} */
    this.iterationDuration = iterationDuration;
    /** @type {{}} */
    this._inlineStyles = animInlineStyles;

    if (!this._autoplay && shouldTriggerRender) this.onRender(this);
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === clampZero(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    // NOTE: Find a better way to handle the stretch of an animation after stretch = 0
    forEachChildren(this, (/** @type {Tween} */tween) => {
      // Rounding is necessary here to minimize floating point errors
      tween._updateDuration = clampZero(round(tween._updateDuration * timeScale, 12));
      tween._changeDuration = clampZero(round(tween._changeDuration * timeScale, 12));
      tween._currentTime *= timeScale;
      tween._startTime *= timeScale;
      tween._absoluteStartTime *= timeScale;
    });
    return super.stretch(newDuration);
  }

  /**
   * @return {this}
   */
  refresh() {
    forEachChildren(this, (/** @type {Tween} */tween) => {
      const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);
      decomposeRawValue(ogValue, decomposedOriginalValue);
      tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
      tween._fromNumber = decomposedOriginalValue.n;
      if (tween._func) {
        decomposeRawValue(tween._func(), toTargetObject);
        tween._toNumbers = cloneArray(toTargetObject.d);
        tween._strings = cloneArray(toTargetObject.s);
        tween._toNumber = toTargetObject.n;
      }
    });
    return this;
  }

  /**
   * Cancel the animation and revert all the values affected by this animation to their original state
   * @return {this}
   */
  revert() {
    super.revert();
    return cleanInlineStyles(this);
  }

  /**
   * @param  {Callback<this>} [callback]
   * @return {Promise}
   */
  then(callback) {
    return super.then(callback);
  }

}

/**
 * @param {TargetsParam} targets
 * @param {AnimationParams} parameters
 * @return {JSAnimation}
 */
export const animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();


================================================
FILE: src/anime.js
================================================
export { engine } from './engine.js';
export { createTimer, Timer } from './timer.js';
export { animate, JSAnimation } from './animation.js';
export { createTimeline, Timeline } from './timeline.js';
export { createAnimatable, Animatable } from './animatable.js';
export { createDraggable, Draggable } from './draggable.js';
export { createScope, Scope } from './scope.js';
export { onScroll, ScrollObserver, scrollContainers } from './scroll.js';
export { createSpring, Spring } from './spring.js';
export { waapi, WAAPIAnimation } from './waapi.js';
export { utils } from './utils.js';
export { svg } from './svg.js';
export { stagger } from './stagger.js';
export { eases } from './eases.js';


================================================
FILE: src/clock.js
================================================
import {
  K,
  maxFps,
  minValue,
  tickModes,
} from './consts.js';

import {
  round,
} from './helpers.js';

/*
 * Base class to control framerate and playback rate.
 * Inherited by Engine, Timer, Animation and Timeline.
 */
export class Clock {

  /** @param {Number} [initTime] */
  constructor(initTime = 0) {
    /** @type {Number} */
    this.deltaTime = 0;
    /** @type {Number} */
    this._currentTime = initTime;
    /** @type {Number} */
    this._elapsedTime = initTime;
    /** @type {Number} */
    this._startTime = initTime;
    /** @type {Number} */
    this._lastTime = initTime;
    /** @type {Number} */
    this._scheduledTime = 0;
    /** @type {Number} */
    this._frameDuration = round(K / maxFps, 0);
    /** @type {Number} */
    this._fps = maxFps;
    /** @type {Number} */
    this._speed = 1;
    /** @type {Boolean} */
    this._hasChildren = false;
    /** @type {Tickable|Tween} */
    this._head = null;
    /** @type {Tickable|Tween} */
    this._tail = null;
  }

  get fps() {
    return this._fps;
  }

  set fps(frameRate) {
    const previousFrameDuration = this._frameDuration;
    const fr = +frameRate;
    const fps = fr < minValue ? minValue : fr;
    const frameDuration = round(K / fps, 0);
    this._fps = fps;
    this._frameDuration = frameDuration;
    this._scheduledTime += frameDuration - previousFrameDuration;
  }

  get speed() {
    return this._speed;
  }

  set speed(playbackRate) {
    const pbr = +playbackRate;
    this._speed = pbr < minValue ? minValue : pbr;
  }

  /**
   * @param  {Number} time
   * @return {tickModes}
   */
  requestTick(time) {
    const scheduledTime = this._scheduledTime;
    const elapsedTime = this._elapsedTime;
    this._elapsedTime += (time - elapsedTime);
    // If the elapsed time is lower than the scheduled time
    // this means not enough time has passed to hit one frameDuration
    // so skip that frame
    if (elapsedTime < scheduledTime) return tickModes.NONE;
    const frameDuration = this._frameDuration;
    const frameDelta = elapsedTime - scheduledTime;
    // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.
    // Skips ahead if the actual elapsed time is higher.
    this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
    return tickModes.AUTO;
  }

  /**
   * @param  {Number} time
   * @return {Number}
   */
  computeDeltaTime(time) {
    const delta = time - this._lastTime;
    this.deltaTime = delta;
    this._lastTime = time;
    return delta;
  }

}



================================================
FILE: src/colors.js
================================================
/// <reference path='./types.js' />

import {
  rgbExecRgx,
  rgbaExecRgx,
  hslExecRgx,
  hslaExecRgx,
} from './consts.js';

import {
  round,
  isRgb,
  isHex,
  isHsl,
  isUnd,
} from './helpers.js';

/**
 * RGB / RGBA Color value string -> RGBA values array
 * @param  {String} rgbValue
 * @return {ColorArray}
 */
const rgbToRgba = rgbValue => {
  const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
  const a = !isUnd(rgba[4]) ? +rgba[4] : 1;
  return [
    +rgba[1],
    +rgba[2],
    +rgba[3],
    a
  ]
}

/**
 * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array
 * @param  {String} hexValue
 * @return {ColorArray}
 */
const hexToRgba = hexValue => {
  const hexLength = hexValue.length;
  const isShort = hexLength === 4 || hexLength === 5;
  return [
    +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),
    +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
    +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
    ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)
  ]
}

/**
 * @param  {Number} p
 * @param  {Number} q
 * @param  {Number} t
 * @return {Number}
 */
const hue2rgb = (p, q, t) => {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  return t < 1 / 6 ? p + (q - p) * 6 * t :
         t < 1 / 2 ? q :
         t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :
         p;
}

/**
 * HSL / HSLA Color value string -> RGBA values array
 * @param  {String} hslValue
 * @return {ColorArray}
 */
const hslToRgba = hslValue => {
  const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
  const h = +hsla[1] / 360;
  const s = +hsla[2] / 100;
  const l = +hsla[3] / 100;
  const a = !isUnd(hsla[4]) ? +hsla[4] : 1;
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const q = l < .5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);
    g = round(hue2rgb(p, q, h) * 255, 0);
    b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);
  }
  return [r, g, b, a];
}

/**
 * All in one color converter that converts a color string value into an array of RGBA values
 * @param  {String} colorString
 * @return {ColorArray}
 */
export const convertColorStringValuesToRgbaArray = colorString => {
  return isRgb(colorString) ? rgbToRgba(colorString) :
         isHex(colorString) ? hexToRgba(colorString) :
         isHsl(colorString) ? hslToRgba(colorString) :
         [0, 0, 0, 1];
}



================================================
FILE: src/compositions.js
================================================
/// <reference path='./types.js' />

import {
  compositionTypes,
  minValue,
} from './consts.js';

import {
  cloneArray,
  addChild,
  removeChild,
  forEachChildren,
} from './helpers.js';

import {
  additive,
  addAdditiveAnimation,
} from './additive.js';

const lookups = {
  /** @type {TweenReplaceLookups} */
  _rep: new WeakMap(),
  /** @type {TweenAdditiveLookups} */
  _add: new Map(),
}

/**
 * @param  {Target} target
 * @param  {String} property
 * @param  {String} lookup
 * @return {TweenPropertySiblings}
 */
export const getTweenSiblings = (target, property, lookup = '_rep') => {
  const lookupMap = lookups[lookup];
  let targetLookup = lookupMap.get(target);
  if (!targetLookup) {
    targetLookup = {};
    lookupMap.set(target, targetLookup);
  }
  return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
    _head: null,
    _tail: null,
  }
}

/**
 * @param  {Tween} p
 * @param  {Tween} c
 * @return {Number|Boolean}
 */
const addTweenSortMethod = (p, c) => {
  return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
}

/**
 * @param {Tween} tween
 */
export const overrideTween = tween => {
  tween._isOverlapped = 1;
  tween._isOverridden = 1;
  tween._changeDuration = minValue;
  tween._currentTime = minValue;
}

/**
 * @param  {Tween} tween
 * @param  {TweenPropertySiblings} siblings
 * @return {Tween}
 */
export const composeTween = (tween, siblings) => {

  const tweenCompositionType = tween._composition;

  // Handle replaced tweens

  if (tweenCompositionType === compositionTypes.replace) {

    const tweenAbsStartTime = tween._absoluteStartTime;

    addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');

    const prevSibling = tween._prevRep;

    // Update the previous siblings for composition replace tweens

    if (prevSibling) {

      const prevParent = prevSibling.parent;
      const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;

      // Handle looped animations tween

      if (
        // Check if the previous tween is from a different animation
        tween.parent.id !== prevParent.id &&
        // Check if the animation has loops
        prevParent.iterationCount> 1 &&
        // Check if _absoluteChangeEndTime of last loop overlaps the current tween
        prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime
      ) {

        // TODO: Find a way to only override the iterations overlapping with the tween
        overrideTween(prevSibling);

        let prevPrevSibling = prevSibling._prevRep;

        // If the tween was part of a set of keyframes, override its siblings
        while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
          overrideTween(prevPrevSibling);
          prevPrevSibling = prevPrevSibling._prevRep;
        }

      }

      const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;

      if (prevAbsEndTime > absoluteUpdateStartTime) {

        const prevChangeStartTime = prevSibling._startTime;
        const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);

        prevSibling._changeDuration = absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime;
        prevSibling._currentTime = prevSibling._changeDuration;
        prevSibling._isOverlapped = 1;

        if (prevSibling._changeDuration < minValue) {
          overrideTween(prevSibling);
        }
      }

      // Pause (and cancel) the parent if it only contains overlapped tweens

      let pausePrevParentAnimation = true;

      forEachChildren(prevParent, (/** @type Tween */t) => {
        if (!t._isOverlapped) pausePrevParentAnimation = false;
      });

      if (pausePrevParentAnimation) {
        const prevParentTL = prevParent.parent;
        if (prevParentTL) {
          let pausePrevParentTL = true;
          forEachChildren(prevParentTL, (/** @type JSAnimation */a) => {
            if (a !== prevParent) {
              forEachChildren(a, (/** @type Tween */t) => {
                if (!t._isOverlapped) pausePrevParentTL = false;
              });
            }
          });
          if (pausePrevParentTL) {
            prevParentTL.cancel();
          }
        } else {
          prevParent.cancel();
          // Previously, calling .cancel() on a timeline child would affect the render order of other children
          // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop
          // This is no longer needed since timeline tween composition is now handled separatly
          // Keeping this here for reference
          // prevParent.completed = true;
          // prevParent.pause();
        }
      }

    }

    // let nextSibling = tween._nextRep;

    // // All the next siblings are automatically overridden

    // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

    // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {
    //   while (nextSibling) {
    //     overrideTween(nextSibling);
    //     console.log(tween.id, nextSibling.id);
    //     nextSibling = nextSibling._nextRep;
    //   }
    // }

  // Handle additive tweens composition

  } else if (tweenCompositionType === compositionTypes.blend) {

    const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');
    const additiveAnimation = addAdditiveAnimation(lookups._add);

    let lookupTween = additiveTweenSiblings._head;

    if (!lookupTween) {
      lookupTween = { ...tween };
      lookupTween._composition = compositionTypes.replace;
      lookupTween._updateDuration = minValue;
      lookupTween._startTime = 0;
      lookupTween._numbers = cloneArray(tween._fromNumbers);
      lookupTween._number = 0;
      lookupTween._next = null;
      lookupTween._prev = null;
      addChild(additiveTweenSiblings, lookupTween);
      addChild(additiveAnimation, lookupTween);
    }

    // Convert the values of TO to FROM and set TO to 0

    const toNumber = tween._toNumber;
    tween._fromNumber = lookupTween._fromNumber - toNumber;
    tween._toNumber = 0;
    tween._numbers = cloneArray(tween._fromNumbers);
    tween._number = 0;
    lookupTween._fromNumber = toNumber;

    if (tween._toNumbers) {
      const toNumbers = cloneArray(tween._toNumbers);
      if (toNumbers) {
        toNumbers.forEach((value, i) => {
          tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
          tween._toNumbers[i] = 0;
        });
      }
      lookupTween._fromNumbers = toNumbers;
    }

    addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');

  }

  return tween;

}

/**
 * @param  {Tween} tween
 * @return {Tween}
 */
export const removeTweenSliblings = tween => {
  const tweenComposition = tween._composition;
  if (tweenComposition !== compositionTypes.none) {
    const tweenTarget = tween.target;
    const tweenProperty = tween.property;
    const replaceTweensLookup = lookups._rep;
    const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
    const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
    removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');
    if (tweenComposition === compositionTypes.blend) {
      const addTweensLookup = lookups._add;
      const addTargetProps = addTweensLookup.get(tweenTarget);
      if (!addTargetProps) return;
      const additiveTweenSiblings = addTargetProps[tweenProperty];
      const additiveAnimation = additive.animation;
      removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');
      // If only one tween is left in the additive lookup, it's the tween lookup
      const lookupTween = additiveTweenSiblings._head;
      if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
        removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');
        removeChild(additiveAnimation, lookupTween);
        let shouldClean = true;
        for (let prop in addTargetProps) {
          if (addTargetProps[prop]._head) {
            shouldClean = false;
            break;
          }
        }
        if (shouldClean) {
          addTweensLookup.delete(tweenTarget);
        }
      }
    }
  }
  return tween;
}



================================================
FILE: src/consts.js
================================================
// Environments

// TODO: Do we need to check if we're running inside a worker ?
export const isBrowser = typeof window !== 'undefined';

/** @type {Object|Null} */
export const win = isBrowser ? window : null;

/** @type {Document} */
export const doc = isBrowser ? document : null;

// Enums

/** @enum {Number} */
export const tweenTypes = {
  OBJECT: 0,
  ATTRIBUTE: 1,
  CSS: 2,
  TRANSFORM: 3,
  CSS_VAR: 4,
}

/** @enum {Number} */
export const valueTypes = {
  NUMBER: 0,
  UNIT: 1,
  COLOR: 2,
  COMPLEX: 3,
}

/** @enum {Number} */
export const tickModes = {
  NONE: 0,
  AUTO: 1,
  FORCE: 2,
}

/** @enum {Number} */
export const compositionTypes = {
  replace: 0,
  none: 1,
  blend: 2,
}

// Cache symbols

export const isRegisteredTargetSymbol = Symbol();
export const isDomSymbol = Symbol();
export const isSvgSymbol = Symbol();
export const transformsSymbol = Symbol();
export const morphPointsSymbol = Symbol();
export const proxyTargetSymbol = Symbol();

// Numbers

export const minValue = 1e-11;
export const maxValue = 1e12;
export const K = 1e3;
export const maxFps = 120;

// Strings

export const emptyString = '';
export const shortTransforms = new Map();

shortTransforms.set('x', 'translateX');
shortTransforms.set('y', 'translateY');
shortTransforms.set('z', 'translateZ');

export const validTransforms = [
  'translateX',
  'translateY',
  'translateZ',
  'rotate',
  'rotateX',
  'rotateY',
  'rotateZ',
  'scale',
  'scaleX',
  'scaleY',
  'scaleZ',
  'skew',
  'skewX',
  'skewY',
  'perspective',
  'matrix',
  'matrix3d',
];

export const transformsFragmentStrings = validTransforms.reduce((a, v) => ({...a, [v]: v + '('}), {});

// Functions

/** @return {void} */
export const noop = () => {};

// Regex

export const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
export const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i
export const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i
export const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
export const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
// export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;
export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
// export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)+([a-z]+|%)$/i;
export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i
export const lowerCaseRgx = /([a-z])([A-Z])/g;
export const transformsExecRgx = /(\w+)(\([^)]+\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()
export const relativeValuesExecRgx = /(\*=|\+=|-=)/;



================================================
FILE: src/draggable.js
================================================
/// <reference path='./types.js' />

import {
  globals,
} from './globals.js';

import {
  JSAnimation,
} from './animation.js';

import {
  Animatable,
} from './animatable.js';

import {
  win,
  doc,
  maxValue,
  noop,
  compositionTypes,
} from './consts.js';

import {
  parseTargets,
} from './targets.js';

import {
  snap,
  clamp,
  round,
  isObj,
  isUnd,
  isArr,
  isFnc,
  sqrt,
  max,
  atan2,
  cos,
  sin,
  abs,
  now,
} from './helpers.js';

import {
  getTargetValue,
  setTargetValues,
  remove,
  mapRange,
} from './utils.js';

import {
  Timer,
} from './timer.js';

import {
  setValue,
} from './values.js';

import {
  eases,
  parseEasings,
} from './eases.js';

import {
  createSpring,
} from './spring.js';

/**
 * @param {Event} e
 */
const preventDefault = e => {
  if (e.cancelable) e.preventDefault();
};

class DOMProxy {
  /** @param {Object} el */
  constructor(el) {
    this.el = el;
    this.zIndex = 0;
    this.parentElement = null;
    this.classList = {
      add: noop,
      remove: noop,
    }
  }

  get x() { return this.el.x || 0 };
  set x(v) { this.el.x = v };

  get y() { return this.el.y || 0 };
  set y(v) { this.el.y = v };

  get width() { return this.el.width || 0 };
  set width(v) { this.el.width = v };

  get height() { return this.el.height || 0 };
  set height(v) { this.el.height = v };

  getBoundingClientRect() {
    return {
      top: this.y,
      right: this.x,
      bottom: this.y + this.height,
      left: this.x + this.width,
    }
  }
}

class Transforms {
  /**
   * @param {DOMTarget|DOMProxy} $el
   */
  constructor($el) {
    this.$el = $el;
    this.inlineTransforms = [];
    this.point = new DOMPoint();
    this.inversedMatrix = this.getMatrix().inverse();
  }

  /**
   * @param {Number} x
   * @param {Number} y
   * @return {DOMPoint}
   */
  normalizePoint(x, y) {
    this.point.x = x;
    this.point.y = y;
    return this.point.matrixTransform(this.inversedMatrix);
  }

  /**
   * @callback TraverseParentsCallback
   * @param {DOMTarget} $el
   * @param {Number} i
   */

  /**
   * @param {TraverseParentsCallback} cb
   */
  traverseUp(cb) {
    let $el = /** @type {DOMTarget|Document} */(this.$el.parentElement), i = 0;
    while ($el && $el !== doc) {
      cb(/** @type {DOMTarget} */($el), i);
      $el = /** @type {DOMTarget} */($el.parentElement);
      i++;
    }
  }

  getMatrix() {
    const matrix = new DOMMatrix();
    this.traverseUp($el => {
      const transformValue = getComputedStyle($el).transform;
      if (transformValue) {
        const elMatrix = new DOMMatrix(transformValue);
        matrix.preMultiplySelf(elMatrix);
      }
    });
    return matrix;
  }

  remove() {
    this.traverseUp(($el, i) => {
      this.inlineTransforms[i] = $el.style.transform;
      $el.style.transform = 'none';
    });
  }

  revert() {
    this.traverseUp(($el, i) => {
      const ct = this.inlineTransforms[i];
      if (ct === '') {
        $el.style.removeProperty('transform');
      } else {
        $el.style.transform = ct;
      }
    });
  }
}

/**
 * @typedef {Object} DraggableCursorParams
 * @property {String} [onHover]
 * @property {String} [onGrab]
 */

/**
 * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T
 * @param {T | ((draggable: Draggable) => T)} value
 * @param {Draggable} draggable
 * @return {T}
 */
const parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */(value)(draggable) : value;

let zIndex = 0;

/**
 * @typedef {Object} DraggableAxisParam
 * @property {String} [mapTo]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 */

/**
 * @typedef {Object} DraggableParams
 * @property {DOMTargetSelector} [trigger]
 * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]
 * @property {Boolean|DraggableAxisParam} [x]
 * @property {Boolean|DraggableAxisParam} [y]
 * @property {TweenModifier} [modifier]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]
 * @property {Number|((draggable: Draggable) => Number)} [containerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]
 * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]
 * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]
 * @property {Number|((draggable: Draggable) => Number)} [minVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]
 * @property {Number} [releaseMass]
 * @property {Number} [releaseStiffness]
 * @property {Number} [releaseDamping]
 * @property {Boolean} [releaseDamping]
 * @property {EasingParam} [releaseEase]
 * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]
 * @property {Callback<Draggable>} [onGrab]
 * @property {Callback<Draggable>} [onDrag]
 * @property {Callback<Draggable>} [onRelease]
 * @property {Callback<Draggable>} [onUpdate]
 * @property {Callback<Draggable>} [onSettle]
 * @property {Callback<Draggable>} [onSnap]
 * @property {Callback<Draggable>} [onResize]
 * @property {Callback<Draggable>} [onAfterResize]
 */

export class Draggable {
  /**
   * @param {TargetsParam} target
   * @param {DraggableParams} [parameters]
   */
  constructor(target, parameters = {}) {
    if (!target) return;
    if (globals.scope) globals.scope.revertibles.push(this);
    const paramX = parameters.x;
    const paramY = parameters.y;
    const trigger = parameters.trigger;
    const modifier = parameters.modifier;
    const ease = parameters.releaseEase;
    const customEase = ease && parseEasings(ease);
    const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */(ease).ease);
    const xProp = /** @type {String} */(isObj(paramX) && !isUnd(/** @type {Object} */(paramX).mapTo) ? /** @type {Object} */(paramX).mapTo : 'translateX');
    const yProp = /** @type {String} */(isObj(paramY) && !isUnd(/** @type {Object} */(paramY).mapTo) ? /** @type {Object} */(paramY).mapTo : 'translateY');
    const container = parseDraggableFunctionParameter(parameters.container, this);
    this.containerArray = isArr(container) ? container : null;
    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
    this.useWin = this.$container === doc.body;
    /** @type {Window | HTMLElement} */
    this.$scrollContainer = this.useWin ? win : this.$container;
    this.$target = /** @type {HTMLElement} */(isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);
    this.$trigger = /** @type {HTMLElement} */(parseTargets(trigger ? trigger : target)[0]);
    this.fixed = getTargetValue(this.$target, 'position') === 'fixed';
    // Refreshable parameters
    this.isFinePointer = true;
    /** @type {[Number, Number, Number, Number]} */
    this.containerPadding = [0, 0, 0, 0];
    /** @type {Number} */
    this.containerFriction = 0;
    /** @type {Number} */
    this.releaseContainerFriction = 0;
    /** @type {Number|Array<Number>} */
    this.snapX = 0;
    /** @type {Number|Array<Number>} */
    this.snapY = 0;
    /** @type {Number} */
    this.scrollSpeed = 0;
    /** @type {Number} */
    this.scrollThreshold = 0;
    /** @type {Number} */
    this.dragSpeed = 0;
    /** @type {Number} */
    this.maxVelocity = 0;
    /** @type {Number} */
    this.minVelocity = 0;
    /** @type {Number} */
    this.velocityMultiplier = 0;
    /** @type {Boolean|DraggableCursorParams} */
    this.cursor = false;
    /** @type {Spring} */
    this.releaseXSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({
      mass: setValue(parameters.releaseMass, 1),
      stiffness: setValue(parameters.releaseStiffness, 80),
      damping: setValue(parameters.releaseDamping, 20),
    });
    /** @type {Spring} */
    this.releaseYSpring = hasSpring ? /** @type {Spring} */(ease) : createSpring({
      mass: setValue(parameters.releaseMass, 1),
      stiffness: setValue(parameters.releaseStiffness, 80),
      damping: setValue(parameters.releaseDamping, 20),
    });
    /** @type {EasingFunction} */
    this.releaseEase = customEase || eases.outQuint;
    /** @type {Boolean} */
    this.hasReleaseSpring = hasSpring;
    /** @type {Callback<this>} */
    this.onGrab = parameters.onGrab || noop;
    /** @type {Callback<this>} */
    this.onDrag = parameters.onDrag || noop;
    /** @type {Callback<this>} */
    this.onRelease = parameters.onRelease || noop;
    /** @type {Callback<this>} */
    this.onUpdate = parameters.onUpdate || noop;
    /** @type {Callback<this>} */
    this.onSettle = parameters.onSettle || noop;
    /** @type {Callback<this>} */
    this.onSnap = parameters.onSnap || noop;
    /** @type {Callback<this>} */
    this.onResize = parameters.onResize || noop;
    /** @type {Callback<this>} */
    this.onAfterResize = parameters.onAfterResize || noop;
    /** @type {[Number, Number]} */
    this.disabled = [0, 0];
    /** @type {AnimatableParams} */
    const animatableParams = {};
    if (modifier) animatableParams.modifier = modifier;
    if (isUnd(paramX) || paramX === true) {
      animatableParams[xProp] = 0;
    } else if (isObj(paramX)) {
      const paramXObject = /** @type {DraggableAxisParam} */(paramX);
      const animatableXParams = {};
      if (paramXObject.modifier) animatableXParams.modifier = paramXObject.modifier;
      if (paramXObject.composition) animatableXParams.composition = paramXObject.composition;
      animatableParams[xProp] = animatableXParams;
    } else if (paramX === false) {
      animatableParams[xProp] = 0;
      this.disabled[0] = 1;
    }
    if (isUnd(paramY) || paramY === true) {
      animatableParams[yProp] = 0;
    } else if (isObj(paramY)) {
      const paramYObject = /** @type {DraggableAxisParam} */(paramY);
      const animatableYParams = {};
      if (paramYObject.modifier) animatableYParams.modifier = paramYObject.modifier;
      if (paramYObject.composition) animatableYParams.composition = paramYObject.composition;
      animatableParams[yProp] = animatableYParams;
    } else if (paramY === false) {
      animatableParams[yProp] = 0;
      this.disabled[1] = 1;
    }
    /** @type {AnimatableObject} */
    this.animate = /** @type {AnimatableObject} */(new Animatable(this.$target, animatableParams));
    // Internal props
    this.xProp = xProp;
    this.yProp = yProp;
    this.destX = 0;
    this.destY = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.scroll = {x: 0, y: 0};
    /** @type {[Number, Number, Number, Number]} */
    this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y
    /** @type {[Number, Number]} */
    this.snapped = [0, 0]; // x, y
    /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */
    this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2
    /** @type {[Number, Number]} */
    this.scrollView = [0, 0]; // w, h
    /** @type {[Number, Number, Number, Number]} */
    this.dragArea = [0, 0, 0, 0]; // x, y, w, h
    /** @type {[Number, Number, Number, Number]} */
    this.containerBounds = [-maxValue, maxValue, maxValue, -maxValue]; // t, r, b, l
    /** @type {[Number, Number, Number, Number]} */
    this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l
    /** @type {[Number, Number, Number, Number]} */
    this.targetBounds = [0, 0, 0, 0]; // t, r, b, l
    /** @type {[Number, Number]} */
    this.window = [0, 0]; // w, h
    /** @type {[Number, Number, Number]} */
    this.velocityStack = [0, 0, 0];
    /** @type {Number} */
    this.velocityStackIndex = 0;
    /** @type {Number} */
    this.velocityTime = now();
    /** @type {Number} */
    this.velocity = 0;
    /** @type {Number} */
    this.angle = 0;
    /** @type {JSAnimation} */
    this.cursorStyles = null;
    /** @type {JSAnimation} */
    this.triggerStyles = null;
    /** @type {JSAnimation} */
    this.bodyStyles = null;
    /** @type {JSAnimation} */
    this.targetStyles = null;
    /** @type {JSAnimation} */
    this.touchActionStyles = null;
    this.transforms = new Transforms(this.$target);
    this.overshootCoords = { x: 0, y: 0 };
    this.overshootXTicker = new Timer({ autoplay: false }, null, 0).init();
    this.overshootYTicker = new Timer({ autoplay: false }, null, 0).init();
    this.updateTicker = new Timer({ autoplay: false }, null, 0).init();
    this.overshootXTicker.onUpdate = () => {
      if (this.disabled[0]) return;
      this.updated = true;
      this.manual = true;
      this.animate[this.xProp](this.overshootCoords.x, 0);
    }
    this.overshootXTicker.onComplete = () => {
      if (this.disabled[0]) return;
      this.manual = false;
      this.animate[this.xProp](this.overshootCoords.x, 0);
    }
    this.overshootYTicker.onUpdate = () => {
      if (this.disabled[1]) return;
      this.updated = true;
      this.manual = true;
      this.animate[this.yProp](this.overshootCoords.y, 0);
    }
    this.overshootYTicker.onComplete = () => {
      if (this.disabled[1]) return;
      this.manual = false;
      this.animate[this.yProp](this.overshootCoords.y, 0);
    }
    this.updateTicker.onUpdate = () => this.update();
    this.contained = !isUnd(container);
    this.manual = false;
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.enabled = false;
    this.initialized = false;
    this.activeProp = this.disabled[0] ? yProp : xProp;
    this.animate.animations[this.activeProp].onRender = () => {
      const hasUpdated = this.updated;
      const hasMoved = this.grabbed && hasUpdated;
      const hasReleased = !hasMoved && this.released;
      const x = this.x;
      const y = this.y;
      const dx = x - this.coords[2];
      const dy = y - this.coords[3];
      this.deltaX = dx;
      this.deltaY = dy;
      this.coords[2] = x;
      this.coords[3] = y;
      if (hasUpdated) {
        this.onUpdate(this);
      }
      if (!hasReleased) {
        this.updated = false;
      } else {
        this.computeVelocity(dx, dy);
        this.angle = atan2(dy, dx);
      }
    }
    this.animate.animations[this.activeProp].onComplete = () => {
      if ((!this.grabbed && this.released)) {
        // Set eleased to false before calling onSettle to avoid recursion
        this.released = false;
      }
      if (!this.manual) {
        this.deltaX = 0;
        this.deltaY = 0;
        this.velocity = 0;
        this.velocityStack[0] = 0;
        this.velocityStack[1] = 0;
        this.velocityStack[2] = 0;
        this.velocityStackIndex = 0;
        this.onSettle(this);
      }
    };
    this.resizeTicker = new Timer({
      autoplay: false,
      duration: 150 * globals.timeScale,
      onComplete: () => {
        this.onResize(this);
        this.refresh();
        this.onAfterResize(this);
      },
    }).init();
    this.parameters = parameters;
    this.resizeObserver = new ResizeObserver(() => {
      if (this.initialized) {
        this.resizeTicker.restart();
      } else {
        this.initialized = true;
      }
    });
    this.enable();
    this.refresh();
    this.resizeObserver.observe(this.$container);
    if (!isObj(target)) this.resizeObserver.observe(this.$target);
  }

  /**
   * @param  {Number} dx
   * @param  {Number} dy
   * @return {Number}
   */
  computeVelocity(dx, dy) {
    const prevTime = this.velocityTime;
    const curTime = now();
    const elapsed = curTime - prevTime;
    if (elapsed < 17) return this.velocity;
    this.velocityTime = curTime;
    const velocityStack = this.velocityStack;
    const vMul = this.velocityMultiplier;
    const minV = this.minVelocity;
    const maxV = this.maxVelocity;
    const vi = this.velocityStackIndex;
    velocityStack[vi] = round(clamp((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);
    const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);
    this.velocity = velocity;
    this.velocityStackIndex = (vi + 1) % 3;
    return velocity;
  }

  /**
   * @param {Number}  x
   * @param {Boolean} [muteUpdateCallback]
   * @return {this}
   */
  setX(x, muteUpdateCallback = false) {
    if (this.disabled[0]) return;
    const v = round(x, 5);
    this.overshootXTicker.pause();
    this.manual = true;
    this.updated = !muteUpdateCallback;
    this.destX = v;
    this.snapped[0] = snap(v, this.snapX);
    this.animate[this.xProp](v, 0);
    this.manual = false;
    return this;
  }

  /**
   * @param {Number}  y
   * @param {Boolean} [muteUpdateCallback]
   * @return {this}
   */
  setY(y, muteUpdateCallback = false) {
    if (this.disabled[1]) return;
    const v = round(y, 5);
    this.overshootYTicker.pause();
    this.manual = true;
    this.updated = !muteUpdateCallback;
    this.destY = v;
    this.snapped[1] = snap(v, this.snapY);
    this.animate[this.yProp](v, 0);
    this.manual = false;
    return this;
  }

  get x() {
    return round(/** @type {Number} */(this.animate[this.xProp]()), globals.precision);
  }

  set x(x) {
    this.setX(x, false);
  }

  get y() {
    return round(/** @type {Number} */(this.animate[this.yProp]()), globals.precision);
  }

  set y(y) {
    this.setY(y, false);
  }

  get progressX() {
    return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);
  }

  set progressX(x) {
    this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);
  }

  get progressY() {
    return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);
  }

  set progressY(y) {
    this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);
  }

  updateScrollCoords() {
    const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);
    const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    const threshold = this.scrollThreshold;
    this.scroll.x = sx;
    this.scroll.y = sy;
    this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;
    this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;
    this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;
    this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;
  }

  updateBoundingValues() {
    const $container = this.$container;
    const cx = this.x;
    const cy = this.y;
    const cx2 = this.coords[2];
    const cy2 =  this.coords[3];
    // Prevents interfering with the scroll area in cases the target is outside of the container
    // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates
    this.coords[2] = 0;
    this.coords[3] = 0;
    this.setX(0, true);
    this.setY(0, true);
    this.transforms.remove();
    const iw = this.window[0] = win.innerWidth;
    const ih = this.window[1] = win.innerHeight;
    const uw = this.useWin;
    const sw = $container.scrollWidth;
    const sh = $container.scrollHeight;
    const fx = this.fixed;
    const transformContainerRect = $container.getBoundingClientRect();
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    this.dragArea[0] = uw ? 0 : transformContainerRect.left;
    this.dragArea[1] = uw ? 0 : transformContainerRect.top;
    this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;
    this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;
    this.updateScrollCoords();
    const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();
    this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);
    this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);
    const containerOverflow = getTargetValue($container, 'overflow');
    const visibleOverflow = containerOverflow === 'visible';
    const hiddenOverflow = containerOverflow === 'hidden';
    this.canScroll = fx ? false :
      this.contained &&
      (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&
      (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&
      (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));
    if (this.contained) {
      const sx = this.scroll.x;
      const sy = this.scroll.y;
      const canScroll = this.canScroll;
      const targetRect = this.$target.getBoundingClientRect();
      const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;
      const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;
      const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;
      const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;
      this.targetBounds[0] = round((targetRect.top + sy) - (uw ? 0 : top), 0);
      this.targetBounds[1] = round((targetRect.right + sx) - (uw ? iw : right), 0);
      this.targetBounds[2] = round((targetRect.bottom + sy) - (uw ? ih : bottom), 0);
      this.targetBounds[3] = round((targetRect.left + sx) - (uw ? 0 : left), 0);
      if (this.containerArray) {
        this.containerBounds[0] = this.containerArray[0] + cpt;
        this.containerBounds[1] = this.containerArray[1] - cpr;
        this.containerBounds[2] = this.containerArray[2] - cpb;
        this.containerBounds[3] = this.containerArray[3] + cpl;
      } else {
        this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);
        this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);
        this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);
        this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);
      }
    }
    this.transforms.revert();
    // Restore coordinates
    this.coords[2] = cx2;
    this.coords[3] = cy2;
    this.setX(cx, true);
    this.setY(cy, true);
  }

  /**
   * Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB
   *
   * @param  {Array} bounds
   * @param  {Number} x
   * @param  {Number} y
   * @return {Number}
   */
  isOutOfBounds(bounds, x, y) {
    if (!this.contained) return 0;
    const [ bt, br, bb, bl ] = bounds;
    const [ dx, dy ] = this.disabled;
    const obx = !dx && x < bl || !dx && x > br;
    const oby = !dy && y < bt || !dy && y > bb;
    return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;
  }

  refresh() {
    const params = this.parameters;
    const paramX = params.x;
    const paramY = params.y;
    const container = parseDraggableFunctionParameter(params.container, this);
    const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;
    const containerPadding = /** @type {[Number, Number, Number, Number]} */(isArr(cp) ? cp : [cp, cp, cp, cp]);
    const cx = this.x;
    const cy = this.y;
    const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);
    const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };
    if (parsedCursorStyles) {
      const { onHover, onGrab } = /** @type {DraggableCursorParams} */(parsedCursorStyles);
      if (onHover) cursorStyles.onHover = onHover;
      if (onGrab) cursorStyles.onGrab = onGrab;
    }
    this.containerArray = isArr(container) ? container : null;
    this.$container = /** @type {HTMLElement} */(container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */(container))[0] : doc.body);
    this.useWin = this.$container === doc.body;
    /** @type {Window | HTMLElement} */
    this.$scrollContainer = this.useWin ? win : this.$container;
    this.isFinePointer = matchMedia('(pointer:fine)').matches;
    this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);
    this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);
    this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);
    this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);
    this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);
    this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);
    this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);
    this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);
    this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);
    this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);
    this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);
    this.cursor = parsedCursorStyles === false ? false : cursorStyles;
    this.updateBoundingValues();

    // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);
    // if (ob === 1 || ob === 3) this.progressX = px;
    // if (ob === 2 || ob === 3) this.progressY = py;

    // if (this.initialized && this.contained) {
    //   if (this.progressX !== px) this.progressX = px;
    //   if (this.progressY !== py) this.progressY = py;
    // }

    const [ bt, br, bb, bl ] = this.containerBounds;
    this.setX(clamp(cx, bl, br), true);
    this.setY(clamp(cy, bt, bb), true);
  }

  update() {
    this.updateScrollCoords();
    if (this.canScroll) {
      const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
      const [ sw, sh ] = this.scrollView;
      const daw = this.dragArea[2];
      const dah = this.dragArea[3];
      const csx = this.scroll.x;
      const csy = this.scroll.y;
      const nsw = this.$container.scrollWidth;
      const nsh = this.$container.scrollHeight;
      const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;
      const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;
      const swd = sw - csw;
      const shd = sh - csh;
      // Handle cases where the scrollarea dimensions changes during drag
      if (this.dragged && swd > 0) {
        this.coords[0] -= swd;
        this.scrollView[0] = csw;
      }
      if (this.dragged && shd > 0) {
        this.coords[1] -= shd;
        this.scrollView[1] = csh;
      }
      // Handle autoscroll when target is at the edges of the scroll bounds
      const s = this.scrollSpeed * 10;
      const threshold = this.scrollThreshold;
      const [ x, y ] = this.coords;
      const [ st, sr, sb, sl ] = this.scrollBounds;
      const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);
      const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);
      const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);
      const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);
      if (t || b || l || r) {
        const [nx, ny] = this.disabled;
        let scrollX = csx;
        let scrollY = csy;
        if (!nx) {
          scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);
          this.coords[0] -= csx - scrollX;
        }
        if (!ny) {
          scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);
          this.coords[1] -= csy - scrollY;
        }
        // Note: Safari mobile requires to use different scroll methods depending if using the window or not
        if (this.useWin) {
          this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));
        } else {
          this.$scrollContainer.scrollTo(scrollX, scrollY);
        }
      }
    }
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
    this.coords[0] += (px1 - px3) * this.dragSpeed;
    this.coords[1] += (py1 - py3) * this.dragSpeed;
    this.pointer[4] = px1;
    this.pointer[5] = py1;
    const [ cx, cy ] = this.coords;
    const [ sx, sy ] = this.snapped;
    const cf = (1 - this.containerFriction) * this.dragSpeed;
    this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);
    this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);
    this.computeVelocity(px1 - px3, py1 - py3);
    this.angle = atan2(py1 - py2, px1 - px2);
    const [ nsx, nsy ] = this.snapped;
    if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {
      this.onSnap(this);
    }
  }

  stop() {
    this.updateTicker.pause();
    this.overshootXTicker.pause();
    this.overshootYTicker.pause();
    // Pauses the in bounds onRelease animations
    for (let prop in this.animate.animations) this.animate.animations[prop].pause();
    remove(this, null, 'x');
    remove(this, null, 'y');
    remove(this, null, 'progressX');
    remove(this, null, 'progressY');
    remove(this.scroll); // Removes any active animations on the container scroll
    remove(this.overshootCoords); // Removes active overshoot animations
    return this;
  }

  /**
   * @param {Number} [duration]
   * @param {Number} [gap]
   * @param {EasingParam} [ease]
   * @return {this}
   */
  scrollInView(duration, gap = 0, ease = eases.inOutQuad) {
    this.updateScrollCoords();
    const x = this.destX;
    const y = this.destY;
    const scroll = this.scroll;
    const scrollBounds = this.scrollBounds;
    const canScroll = this.canScroll;
    if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {
      const [ st, sr, sb, sl ] = scrollBounds;
      const t = round(clamp(y - st, -maxValue, 0), 0);
      const r = round(clamp(x - sr, 0, maxValue), 0);
      const b = round(clamp(y - sb, 0, maxValue), 0);
      const l = round(clamp(x - sl, -maxValue, 0), 0);
      new JSAnimation(scroll, {
        x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),
        y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),
        duration: isUnd(duration) ? 350 * globals.timeScale : duration,
        ease,
        onUpdate: () => {
          this.canScroll = false;
          this.$scrollContainer.scrollTo(scroll.x, scroll.y);
        }
      }).init().then(() => {
        this.canScroll = canScroll;
      })
    }
    return this;
  }

  handleHover() {
    if (this.isFinePointer && this.cursor && !this.cursorStyles) {
      this.cursorStyles = setTargetValues(this.$trigger, {
        cursor: /** @type {DraggableCursorParams} */(this.cursor).onHover
      });
    }
  }

  /**
   * @param  {Number} [duration]
   * @param  {Number} [gap]
   * @param  {EasingParam} [ease]
   * @return {this}
   */
  animateInView(duration, gap = 0, ease = eases.inOutQuad) {
    this.stop();
    this.updateBoundingValues();
    const x = this.x;
    const y = this.y;
    const [ cpt, cpr, cpb, cpl ] = this.containerPadding;
    const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;
    const br = this.scroll.x - this.targetBounds[1] - cpr - gap;
    const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;
    const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;
    const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);
    if (ob) {
      const [ disabledX, disabledY ] = this.disabled;
      const destX = clamp(snap(x, this.snapX), bl, br);
      const destY = clamp(snap(y, this.snapY), bt, bb);
      const dur = isUnd(duration) ? 350 * globals.timeScale : duration;
      if (!disabledX && (ob === 1 || ob === 3)) this.animate[this.xProp](destX, dur, ease);
      if (!disabledY && (ob === 2 || ob === 3)) this.animate[this.yProp](destY, dur, ease);
    }
    return this;
  }

  /**
   * @param {MouseEvent|TouchEvent} e
   */
  handleDown(e) {
    const $eTarget = /** @type {HTMLElement} */(e.target);
    if (this.grabbed || /** @type {HTMLInputElement}  */($eTarget).type === 'range') return;

    e.stopPropagation();

    this.grabbed = true;
    this.released = false;
    this.stop();
    this.updateBoundingValues();
    const touches = /** @type {TouchEvent} */(e).changedTouches;
    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
    const { x, y } = this.transforms.normalizePoint(eventX, eventY);
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const cf = (1 - this.containerFriction) * this.dragSpeed;
    const cx = this.x;
    const cy = this.y;
    this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;
    this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;
    this.pointer[0] = x;
    this.pointer[1] = y;
    this.pointer[2] = x;
    this.pointer[3] = y;
    this.pointer[4] = x;
    this.pointer[5] = y;
    this.pointer[6] = x;
    this.pointer[7] = y;
    this.deltaX = 0;
    this.deltaY = 0;
    this.velocity = 0;
    this.velocityStack[0] = 0;
    this.velocityStack[1] = 0;
    this.velocityStack[2] = 0;
    this.velocityStackIndex = 0;
    this.angle = 0;
    if (this.targetStyles) {
      this.targetStyles.revert();
      this.targetStyles = null;
    }
    const z = /** @type {Number} */(getTargetValue(this.$target, 'zIndex', false));
    zIndex = (z > zIndex ? z : zIndex) + 1;
    this.targetStyles = setTargetValues(this.$target, { zIndex });
    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }
    if (this.cursorStyles) {
      this.cursorStyles.revert();
      this.cursorStyles = null;
    }
    if (this.isFinePointer && this.cursor) {
      this.bodyStyles = setTargetValues(doc.body, {
        cursor: /** @type {DraggableCursorParams} */(this.cursor).onGrab
      });
    }
    this.scrollInView(100, 0, eases.out(3));
    this.onGrab(this);

    doc.addEventListener('touchmove', this);
    doc.addEventListener('touchend', this);
    doc.addEventListener('touchcancel', this);
    doc.addEventListener('mousemove', this);
    doc.addEventListener('mouseup', this);
    doc.addEventListener('selectstart', this);
  }

  /**
   * @param {MouseEvent|TouchEvent} e
   */
  handleMove(e) {
    if (!this.grabbed) return;
    const touches = /** @type {TouchEvent} */(e).changedTouches;
    const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */(e).clientX;
    const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */(e).clientY;
    const { x, y } = this.transforms.normalizePoint(eventX, eventY)
    const movedX = x - this.pointer[6];
    const movedY = y - this.pointer[7];

    let $parent = /** @type {HTMLElement} */(e.target);
    let isAtTop = false;
    let isAtBottom = false;
    let canTouchScroll = false;

    while (touches && $parent && $parent !== this.$trigger) {
      const overflowY = getTargetValue($parent, 'overflow-y');
      if (overflowY !== 'hidden' && overflowY !== 'visible') {
        const { scrollTop, scrollHeight, clientHeight } = $parent;
        if (scrollHeight > clientHeight) {
          canTouchScroll = true;
          isAtTop = scrollTop <= 3;
          isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;
          break;
        }
      }
      $parent = /** @type {HTMLElement} */($parent.parentNode);
    }

    if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {

      this.pointer[0] = x;
      this.pointer[1] = y;
      this.pointer[2] = x;
      this.pointer[3] = y;
      this.pointer[4] = x;
      this.pointer[5] = y;
      this.pointer[6] = x;
      this.pointer[7] = y;

    } else {

      preventDefault(e);

      // Needed to prevents click on handleUp
      if (!this.triggerStyles) this.triggerStyles = setTargetValues(this.$trigger, { pointerEvents: 'none' });
      // Needed to prevent page scroll while dragging on touch devvice
      this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });
      this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });
      this.$trigger.addEventListener('touchend', preventDefault);


      if ((!this.disabled[0] && abs(movedX) > 3) || (!this.disabled[1] && abs(movedY) > 3)) {

        this.updateTicker.resume();
        this.pointer[2] = this.pointer[0];
        this.pointer[3] = this.pointer[1];
        this.pointer[0] = x;
        this.pointer[1] = y;
        this.dragged = true;
        this.released = false;
        this.onDrag(this);
      }
    }
  }

  handleUp() {

    if (!this.grabbed) return;

    this.updateTicker.pause();

    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }

    if (this.bodyStyles) {
      this.bodyStyles.revert();
      this.bodyStyles = null;
    }

    const [ disabledX, disabledY ] = this.disabled;
    const [ px1, py1, px2, py2, px3, py3 ] = this.pointer;
    const [ ct, cr, cb, cl ] = this.containerBounds;
    const [ sx, sy ] = this.snapped;
    const springX = this.releaseXSpring;
    const springY = this.releaseYSpring;
    const releaseEase = this.releaseEase;
    const hasReleaseSpring = this.hasReleaseSpring;
    const overshootCoords = this.overshootCoords;
    const cx = this.x;
    const cy = this.y;
    const pv = this.computeVelocity(px1 - px3, py1 - py3);
    const pa = this.angle = atan2(py1 - py2, px1 - px2);
    const ds = pv * 150;
    const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;
    const nx = cx + (cos(pa) * ds);
    const ny = cy + (sin(pa) * ds);
    const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;
    const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;
    const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);
    const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);
    const ob = this.isOutOfBounds(this.containerBounds, nx, ny);

    let durationX = 0;
    let durationY = 0;
    let easeX = releaseEase;
    let easeY = releaseEase;
    let longestReleaseDuration = 0;

    overshootCoords.x = cx;
    overshootCoords.y = cy;

    if (!disabledX) {
      const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;
      const distanceX = round(cx - dx, 0);
      springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;
      const { ease, duration, restDuration } = springX;
      durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);
      if (hasReleaseSpring) easeX = ease;
      if (durationX > longestReleaseDuration) longestReleaseDuration = durationX;
    }

    if (!disabledY) {
      const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;
      const distanceY = round(cy - dy, 0);
      springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;
      const { ease, duration, restDuration } = springY;
      durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);
      if (hasReleaseSpring) easeY = ease;
      if (durationY > longestReleaseDuration) longestReleaseDuration = durationY;
    }

    if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {

        const composition = compositionTypes.blend;

        new JSAnimation(overshootCoords, {
          x: { to: bx, duration: durationX * .65 },
          y: { to: by, duration: durationY * .65 },
          ease: releaseEase,
          composition,
        }).init();

        new JSAnimation(overshootCoords, {
          x: { to: dx, duration: durationX },
          y: { to: dy, duration: durationY },
          ease: releaseEase,
          composition,
        }).init();

        this.overshootXTicker.stretch(durationX).restart();
        this.overshootYTicker.stretch(durationY).restart();

    } else {

      if (!disabledX) this.animate[this.xProp](dx, durationX, easeX);
      if (!disabledY) this.animate[this.yProp](dy, durationY, easeY);

    }

    this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);

    let hasSnapped = false;

    if (dx !== sx) {
      this.snapped[0] = dx;
      if (this.snapX) hasSnapped = true;
    }

    if (dy !== sy && this.snapY) {
      this.snapped[1] = dy;
      if (this.snapY) hasSnapped = true;
    }

    if (hasSnapped) this.onSnap(this);

    this.grabbed = false;
    this.dragged = false;
    this.updated = true;
    this.released = true;

    // It's important to trigger the callback after the release animations to be able to cancel them
    this.onRelease(this);

    this.$trigger.removeEventListener('touchstart', preventDefault);
    this.$trigger.removeEventListener('touchmove', preventDefault);
    this.$trigger.removeEventListener('touchend', preventDefault);

    doc.removeEventListener('touchmove', this);
    doc.removeEventListener('touchend', this);
    doc.removeEventListener('touchcancel', this);
    doc.removeEventListener('mousemove', this);
    doc.removeEventListener('mouseup', this);
    doc.removeEventListener('selectstart', this);
  }

  reset() {
    this.stop();
    this.resizeTicker.pause();
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.setX(0, true);
    this.setY(0, true);
    this.coords[0] = 0;
    this.coords[1] = 0;
    this.pointer[0] = 0;
    this.pointer[1] = 0;
    this.pointer[2] = 0;
    this.pointer[3] = 0;
    this.pointer[4] = 0;
    this.pointer[5] = 0;
    this.pointer[6] = 0;
    this.pointer[7] = 0;
    this.velocity = 0;
    this.velocityStack[0] = 0;
    this.velocityStack[1] = 0;
    this.velocityStack[2] = 0;
    this.velocityStackIndex = 0;
    this.angle = 0;
    return this;
  }

  enable() {
    if (!this.enabled) {
      this.enabled = true;
      this.$target.classList.remove('is-disabled');
      this.touchActionStyles = setTargetValues(this.$trigger, {
        touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'
      });
      this.$trigger.addEventListener('touchstart', this, { passive: true });
      this.$trigger.addEventListener('mousedown', this, { passive: true });
      this.$trigger.addEventListener('mouseenter', this);
    }
    return this;
  }

  disable() {
    this.enabled = false;
    this.grabbed = false;
    this.dragged = false;
    this.updated = false;
    this.released = false;
    this.canScroll = false;
    this.touchActionStyles.revert();
    if (this.cursorStyles) {
      this.cursorStyles.revert();
      this.cursorStyles = null;
    }
    if (this.triggerStyles) {
      this.triggerStyles.revert();
      this.triggerStyles = null;
    }
    if (this.bodyStyles) {
      this.bodyStyles.revert();
      this.bodyStyles = null;
    }
    if (this.targetStyles) {
      this.targetStyles.revert();
      this.targetStyles = null;
    }
    this.stop();
    this.$target.classList.add('is-disabled');
    this.$trigger.removeEventListener('touchstart', this);
    this.$trigger.removeEventListener('mousedown', this);
    this.$trigger.removeEventListener('mouseenter', this);
    doc.removeEventListener('touchmove', this);
    doc.removeEventListener('touchend', this);
    doc.removeEventListener('touchcancel', this);
    doc.removeEventListener('mousemove', this);
    doc.removeEventListener('mouseup', this);
    doc.removeEventListener('selectstart', this);
    return this;
  }

  revert() {
    this.reset();
    this.disable();
    this.$target.classList.remove('is-disabled');
    this.updateTicker.revert();
    this.overshootXTicker.revert();
    this.overshootYTicker.revert();
    this.resizeTicker.revert();
    return this;
  }

  /**
   * @param {Event} e
   */
  handleEvent(e) {
    switch (e.type) {
      case 'mousedown':
        this.handleDown(/** @type {MouseEvent} */(e));
        break;
      case 'touchstart':
        this.handleDown(/** @type {TouchEvent} */(e));
        break;
      case 'mousemove':
        this.handleMove(/** @type {MouseEvent} */(e));
        break;
      case 'touchmove':
        this.handleMove(/** @type {TouchEvent} */(e));
        break;
      case 'mouseup':
        this.handleUp();
        break;
      case 'touchend':
        this.handleUp();
        break;
      case 'touchcancel':
        this.handleUp();
        break;
      case 'mouseenter':
        this.handleHover();
        break;
      case 'selectstart':
        preventDefault(e);
        break;
    }
  }
}

/**
 * @param {TargetsParam} target
 * @param {DraggableParams} [parameters]
 * @return {Draggable}
 */
export const createDraggable = (target, parameters) => new Draggable(target, parameters);



================================================
FILE: src/eases.js
================================================
/// <reference path='./types.js' />

import {
  minValue,
  emptyString,
} from './consts.js';

import {
  isUnd,
  isStr,
  isFnc,
  parseNumber,
  clamp,
  sqrt,
  cos,
  sin,
  ceil,
  floor,
  abs,
  asin,
  PI,
  pow,
} from './helpers.js';

/** @type {EasingFunction} */
export const none = t => t;

// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease © Gaëtan Renaudeau

/**
 * @param  {Number} aT
 * @param  {Number} aA1
 * @param  {Number} aA2
 * @return {Number}
 */
const calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;

/**
 * @param  {Number} aX
 * @param  {Number} mX1
 * @param  {Number} mX2
 * @return {Number}
 */
const binarySubdivide = (aX, mX1, mX2) => {
  let aA = 0, aB = 1, currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (abs(currentX) > .0000001 && ++i < 100);
  return currentT;
}

/**
 * @param  {Number} [mX1]
 * @param  {Number} [mY1]
 * @param  {Number} [mX2]
 * @param  {Number} [mY2]
 * @return {EasingFunction}
 */

export const cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :
  t => t === 0 || t === 1 ? t :
  calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);

/**
 * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function
 * Only covers 'end' and 'start' jumpterms
 * @param  {Number} steps
 * @param  {Boolean} [fromStart]
 * @return {EasingFunction}
 */
export const steps = (steps = 10, fromStart) => {
  const roundMethod = fromStart ? ceil : floor;
  return t => roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);
}

/**
 * Without parameters, the linear function creates a non-eased transition.
 * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.
 * @param  {...String|Number} [args] - Points
 * @return {EasingFunction}
 */
const linear = (...args) => {
  const argsLength = args.length;
  if (!argsLength) return none;
  const totalPoints = argsLength - 1;
  const firstArg = args[0];
  const lastArg = args[totalPoints];
  const xPoints = [0];
  const yPoints = [parseNumber(firstArg)];
  for (let i = 1; i < totalPoints; i++) {
    const arg = args[i];
    const splitValue = isStr(arg) ?
    /** @type {String} */(arg).trim().split(' ') :
    [arg];
    const value = splitValue[0];
    const percent = splitValue[1];
    xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);
    yPoints.push(parseNumber(value));
  }
  yPoints.push(parseNumber(lastArg));
  xPoints.push(1);
  return function easeLinear(t) {
    for (let i = 1, l = xPoints.length; i < l; i++) {
      const currentX = xPoints[i];
      if (t <= currentX) {
        const prevX = xPoints[i - 1];
        const prevY = yPoints[i - 1];
        return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);
      }
    }
    return yPoints[yPoints.length - 1];
  }
}

/**
 * Generate random steps
 * @param  {Number} [length] - The number of steps
 * @param  {Number} [randomness] - How strong the randomness is
 * @return {EasingFunction}
 */
const irregular = (length = 10, randomness = 1) => {
  const values = [0];
  const total = length - 1;
  for (let i = 1; i < total; i++) {
    const previousValue = values[i - 1];
    const spacing = i / total;
    const segmentEnd = (i + 1) / total;
    const randomVariation = spacing + (segmentEnd - spacing) * Math.random();
    // Mix the even spacing and random variation based on the randomness parameter
    const randomValue = spacing * (1 - randomness) + randomVariation * randomness;
    values.push(clamp(randomValue, previousValue, 1));
  }
  values.push(1);
  return linear(...values);
}

// Easing functions adapted from http://www.robertpenner.com/ease © Robert Penner

/**
 * @callback PowerEasing
 * @param {Number|String} [power=1.675]
 * @return {EasingFunction}
 */

/**
 * @callback BackEasing
 * @param {Number|String} [overshoot=1.70158]
 * @return {EasingFunction}
 */

/**
 * @callback ElasticEasing
 * @param {Number|String} [amplitude=1]
 * @param {Number|String} [period=.3]
 * @return {EasingFunction}
 */

/**
 * @callback EaseFactory
 * @param {Number|String} [paramA]
 * @param {Number|String} [paramB]
 * @return {EasingFunction|Number}
 */

/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */

const halfPI = PI / 2;
const doublePI = PI * 2;
/** @type {PowerEasing} */
export const easeInPower = (p = 1.68) => t => pow(t, +p);

/** @type {Record<String, EasesFactory|EasingFunction>} */
const easeInFunctions = {
  [emptyString]: easeInPower,
  Quad: easeInPower(2),
  Cubic: easeInPower(3),
  Quart: easeInPower(4),
  Quint: easeInPower(5),
  /** @type {EasingFunction} */
  Sine: t => 1 - cos(t * halfPI),
  /** @type {EasingFunction} */
  Circ: t => 1 - sqrt(1 - t * t),
  /** @type {EasingFunction} */
  Expo: t => t ? pow(2, 10 * t - 10) : 0,
  /** @type {EasingFunction} */
  Bounce: t => {
    let pow2, b = 4;
    while (t < ((pow2 = pow(2, --b)) - 1) / 11);
    return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);
  },
  /** @type {BackEasing} */
  Back: (overshoot = 1.70158) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,
  /** @type {ElasticEasing} */
  Elastic: (amplitude = 1, period = .3) => {
    const a = clamp(+amplitude, 1, 10);
    const p = clamp(+period, minValue, 2);
    const s = (p / doublePI) * asin(1 / a);
    const e = doublePI / p;
    return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);
  }
}

/**
 * @callback EaseType
 * @param {EasingFunction} Ease
 * @return {EasingFunction}
 */

/** @type {Record<String, EaseType>} */
export const easeTypes = {
  in: easeIn => t => easeIn(t),
  out: easeIn => t => 1 - easeIn(1 - t),
  inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,
  outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,
}

/**
 * @param  {String} string
 * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions
 * @param  {Object} easesLookups
 * @return {EasingFunction}
 */
export const parseEaseString = (string, easesFunctions, easesLookups) => {
  if (easesLookups[string]) return easesLookups[string];
  if (string.indexOf('(') <= -1) {
    const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');
    const parsedFn = /** @type {EasingFunction} */(hasParams ? /** @type {EasesFactory} */(easesFunctions[string])() : easesFunctions[string]);
    return parsedFn ? easesLookups[string] = parsedFn : none;
  } else {
    const split = string.slice(0, -1).split('(');
    const parsedFn = /** @type {EasesFactory} */(easesFunctions[split[0]]);
    return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;
  }
}

/**
 * @typedef  {Object} EasesFunctions
 * @property {typeof linear} linear
 * @property {typeof irregular} irregular
 * @property {typeof steps} steps
 * @property {typeof cubicBezier} cubicBezier
 * @property {PowerEasing} in
 * @property {PowerEasing} out
 * @property {PowerEasing} inOut
 * @property {PowerEasing} outIn
 * @property {EasingFunction} inQuad
 * @property {EasingFunction} outQuad
 * @property {EasingFunction} inOutQuad
 * @property {EasingFunction} outInQuad
 * @property {EasingFunction} inCubic
 * @property {EasingFunction} outCubic
 * @property {EasingFunction} inOutCubic
 * @property {EasingFunction} outInCubic
 * @property {EasingFunction} inQuart
 * @property {EasingFunction} outQuart
 * @property {EasingFunction} inOutQuart
 * @property {EasingFunction} outInQuart
 * @property {EasingFunction} inQuint
 * @property {EasingFunction} outQuint
 * @property {EasingFunction} inOutQuint
 * @property {EasingFunction} outInQuint
 * @property {EasingFunction} inSine
 * @property {EasingFunction} outSine
 * @property {EasingFunction} inOutSine
 * @property {EasingFunction} outInSine
 * @property {EasingFunction} inCirc
 * @property {EasingFunction} outCirc
 * @property {EasingFunction} inOutCirc
 * @property {EasingFunction} outInCirc
 * @property {EasingFunction} inExpo
 * @property {EasingFunction} outExpo
 * @property {EasingFunction} inOutExpo
 * @property {EasingFunction} outInExpo
 * @property {EasingFunction} inBounce
 * @property {EasingFunction} outBounce
 * @property {EasingFunction} inOutBounce
 * @property {EasingFunction} outInBounce
 * @property {BackEasing} inBack
 * @property {BackEasing} outBack
 * @property {BackEasing} inOutBack
 * @property {BackEasing} outInBack
 * @property {ElasticEasing} inElastic
 * @property {ElasticEasing} outElastic
 * @property {ElasticEasing} inOutElastic
 * @property {ElasticEasing} outInElastic
 */

export const eases = (/*#__PURE__*/ (() => {
  const list = { linear, irregular, steps, cubicBezier };
  for (let type in easeTypes) {
    for (let name in easeInFunctions) {
      const easeIn = easeInFunctions[name];
      const easeType = easeTypes[type];
      list[type + name] = /** @type {EasesFactory|EasingFunction} */(
        name === emptyString || name === 'Back' || name === 'Elastic' ?
        (a, b) => easeType(/** @type {EasesFactory} */(easeIn)(a, b)) :
        easeType(/** @type {EasingFunction} */(easeIn))
      );
    }
  }
  return /** @type {EasesFunctions} */(list);
})());

/** @type {Record<String, EasingFunction>} */
const JSEasesLookups = { linear: none };

/**
 * @param  {EasingParam} ease
 * @return {EasingFunction}
 */
export const parseEasings = ease => isFnc(ease) ? ease :
  isStr(ease) ? parseEaseString(/** @type {String} */(ease), eases, JSEasesLookups) :
  none;



================================================
FILE: src/engine.js
================================================
import {
  defaults,
  globals,
  globalVersions,
} from './globals.js';

import {
  tickModes,
  isBrowser,
  K,
  doc,
} from './consts.js';

import {
  now,
  forEachChildren,
  removeChild,
} from './helpers.js';

import {
  Clock,
} from './clock.js';

import {
  additive,
} from './additive.js';

import {
  tick,
} from './render.js';

export const engineTickMethod = isBrowser ? requestAnimationFrame : setImmediate;
export const engineCancelMethod = isBrowser ? cancelAnimationFrame : clearImmediate;

export class Engine extends Clock {

  /** @param {Number} [initTime] */
  constructor(initTime) {
    super(initTime);
    this.useDefaultMainLoop = true;
    this.pauseOnDocumentHidden = true;
    /** @type {DefaultsParams} */
    this.defaults = defaults;
    this.paused = isBrowser && doc.hidden ? true  : false;
    /** @type {Number|NodeJS.Immediate} */
    this.reqId = null;
  }

  update() {
    const time = this._currentTime = now();
    if (this.requestTick(time)) {
      this.computeDeltaTime(time);
      const engineSpeed = this._speed;
      const engineFps = this._fps;
      let activeTickable = /** @type {Tickable} */(this._head);
      while (activeTickable) {
        const nextTickable = activeTickable._next;
        if (!activeTickable.paused) {
          tick(
            activeTickable,
            (time - activeTickable._startTime) * activeTickable._speed * engineSpeed,
            0, // !muteCallbacks
            0, // !internalRender
            activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO
          );
        } else {
          removeChild(this, activeTickable);
          this._hasChildren = !!this._tail;
          activeTickable._running = false;
          if (activeTickable.completed && !activeTickable._cancelled) {
            activeTickable.cancel();
          }
        }
        activeTickable = nextTickable;
      }
      additive.update();
    }
  }

  wake() {
    if (this.useDefaultMainLoop && !this.reqId && !this.paused) {
      this.reqId = engineTickMethod(tickEngine);
    }
    return this;
  }

  pause() {
    this.paused = true;
    return killEngine();
  }

  resume() {
    if (!this.paused) return;
    this.paused = false;
    forEachChildren(this, (/** @type {Tickable} */child) => child.resetTime());
    return this.wake();
  }

  // Getter and setter for speed
  get speed() {
    return this._speed * (globals.timeScale === 1 ? 1 : K);
  }

  set speed(playbackRate) {
    this._speed = playbackRate * globals.timeScale;
    forEachChildren(this, (/** @type {Tickable} */child) => child.speed = child._speed);
  }

  // Getter and setter for timeUnit
  get timeUnit() {
    return globals.timeScale === 1 ? 'ms' : 's';
  };

  set timeUnit(unit) {
    const secondsScale = 0.001;
    const isSecond = unit === 's';
    const newScale = isSecond ? secondsScale : 1;
    if (globals.timeScale !== newScale) {
      globals.timeScale = newScale;
      globals.tickThreshold = 200 * newScale;
      const scaleFactor = isSecond ? secondsScale : K;
      /** @type {Number} */
      (this.defaults.duration) *= scaleFactor;
      this._speed *= scaleFactor;
    }
  }

  // Getter and setter for precision
  get precision() {
    return globals.precision;
  }

  set precision(precision) {
    globals.precision = precision;
  }

};

export const engine = /*#__PURE__*/(() => {
  const engine = new Engine(now());
  if (isBrowser) {
    globalVersions.engine = engine;
    doc.addEventListener('visibilitychange', () => {
      if (!engine.pauseOnDocumentHidden) return;
      doc.hidden ? engine.pause() : engine.resume();
    });
  }
  return engine;
})();


const tickEngine = () => {
  if (engine._head) {
    engine.reqId = engineTickMethod(tickEngine);
    engine.update();
  } else {
    engine.reqId = 0;
  }
};

const killEngine = () => {
  engineCancelMethod(/** @type {NodeJS.Immediate & Number} */(engine.reqId));
  engine.reqId = 0;
  return engine;
};



================================================
FILE: src/globals.js
================================================
/// <reference path='./types.js' />

import {
  K,
  noop,
  maxFps,
  compositionTypes,
  win,
  doc,
  isBrowser,
} from './consts.js';

/** @type {DefaultsParams} */
export const defaults = {
  id: null,
  keyframes: null,
  playbackEase: null,
  playbackRate: 1,
  frameRate: maxFps,
  loop: 0,
  reversed: false,
  alternate: false,
  autoplay: true,
  duration: K,
  delay: 0,
  loopDelay: 0,
  ease: 'out(2)',
  composition: compositionTypes.replace,
  modifier: v => v,
  onBegin: noop,
  onBeforeUpdate: noop,
  onUpdate: noop,
  onLoop: noop,
  onPause: noop,
  onComplete: noop,
  onRender: noop,
}

export const globals = {
  /** @type {DefaultsParams} */
  defaults,
  /** @type {Document|DOMTarget} */
  root: doc,
  /** @type {Scope} */
  scope: null,
  /** @type {Number} */
  precision: 4,
  /** @type {Number} */
  timeScale: 1,
  /** @type {Number} */
  tickThreshold: 200,
}

export const globalVersions = { version: '__packageVersion__', engine: null };

if (isBrowser) {
  if (!win.AnimeJS) win.AnimeJS = [];
  win.AnimeJS.push(globalVersions);
}



================================================
FILE: src/helpers.js
================================================
import {
  isBrowser,
  lowerCaseRgx,
  hexTestRgx,
  maxValue,
  minValue,
} from './consts.js';

import {
  globals,
} from './globals.js';

// Strings

/**
 * @param  {String} str
 * @return {String}
 */
export const toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();

/**
 * Prioritize this method instead of regex when possible
 * @param  {String} str
 * @param  {String} sub
 * @return {Boolean}
 */
export const stringStartsWith = (str, sub) => str.indexOf(sub) === 0;

// Time
// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.
export const now = Date.now;

// Types checkers

export const isArr = Array.isArray;
/**@param {any} a @return {a is Record<String, any>} */
export const isObj = a => a && a.constructor === Object;
/**@param {any} a @return {a is Number} */
export const isNum = a => typeof a === 'number' && !isNaN(a);
/**@param {any} a @return {a is String} */
export const isStr = a => typeof a === 'string';
/**@param {any} a @return {a is Function} */
export const isFnc = a => typeof a === 'function';
/**@param {any} a @return {a is undefined} */
export const isUnd = a => typeof a === 'undefined';
/**@param {any} a @return {a is null | undefined} */
export const isNil = a => isUnd(a) || a === null;
/**@param {any} a @return {a is SVGElement} */
export const isSvg = a => isBrowser && a instanceof SVGElement;
/**@param {any} a @return {Boolean} */
export const isHex = a => hexTestRgx.test(a);
/**@param {any} a @return {Boolean} */
export const isRgb = a => stringStartsWith(a, 'rgb');
/**@param {any} a @return {Boolean} */
export const isHsl = a => stringStartsWith(a, 'hsl');
/**@param {any} a @return {Boolean} */
export const isCol = a => isHex(a) || isRgb(a) || isHsl(a);
/**@param {any} a @return {Boolean} */
export const isKey = a => !globals.defaults.hasOwnProperty(a);

// Number

/**
 * @param  {Number|String} str
 * @return {Number}
 */
export const parseNumber = str => isStr(str) ?
  parseFloat(/** @type {String} */(str)) :
  /** @type {Number} */(str);

// Math

export const pow = Math.pow;
export const sqrt = Math.sqrt;
export const sin = Math.sin;
export const cos = Math.cos;
export const abs = Math.abs;
export const exp = Math.exp;
export const ceil = Math.ceil;
export const floor = Math.floor;
export const asin = Math.asin;
export const max = Math.max;
export const atan2 = Math.atan2;
export const PI = Math.PI;
export const _round = Math.round;


/**
 * @param  {Number} v
 * @param  {Number} min
 * @param  {Number} max
 * @return {Number}
 */
export const clamp = (v, min, max) => v < min ? min : v > max ? max : v;

const powCache = {};

/**
 * @param  {Number} v
 * @param  {Number} decimalLength
 * @return {Number}
 */
export const round = (v, decimalLength) => {
  if (decimalLength < 0) return v;
  if (!decimalLength) return _round(v);
  let p = powCache[decimalLength];
  if (!p) p = powCache[decimalLength] = 10 ** decimalLength;
  return _round(v * p) / p;
};

/**
 * @param  {Number} v
 * @param  {Number|Array<Number>} increment
 * @return {Number}
 */
export const snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;

/**
 * @param  {Number} start
 * @param  {Number} end
 * @param  {Number} progress
 * @return {Number}
 */
export const interpolate = (start, end, progress) => start + (end - start) * progress;

/**
 * @param  {Number} v
 * @return {Number}
 */
export const clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -maxValue : v;

/**
 * @param  {Number} v
 * @return {Number}
 */
export const clampZero = v => v < minValue ? minValue : v;

// Arrays

/**
 * @template T
 * @param {T[]} a
 * @return {T[]}
 */
export const cloneArray = a => isArr(a) ? [ ...a ] : a;

// Objects

/**
 * @template T
 * @template U
 * @param {T} o1
 * @param {U} o2
 * @return {T & U}
 */
export const mergeObjects = (o1, o2) => {
  const merged = /** @type {T & U} */({ ...o1 });
  for (let p in o2) {
    const o1p = /** @type {T & U} */(o1)[p];
    merged[p] = isUnd(o1p) ? /** @type {T & U} */(o2)[p] : o1p;
  };
  return merged;
}

// Linked lists

/**
 * @param {Object} parent
 * @param {Function} callback
 * @param {Boolean} [reverse]
 * @param {String} [prevProp]
 * @param {String} [nextProp]
 * @return {void}
 */
export const forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {
  let next = parent._head;
  let adjustedNextProp = nextProp;
  if (reverse) {
    next = parent._tail;
    adjustedNextProp = prevProp;
  }
  while (next) {
    const currentNext = next[adjustedNextProp];
    callback(next);
    next = currentNext;
  }
}

/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {String} [prevProp]
 * @param  {String} [nextProp]
 * @return {void}
 */
export const removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {
  const prev = child[prevProp];
  const next = child[nextProp];
  prev ? prev[nextProp] = next : parent._head = next;
  next ? next[prevProp] = prev : parent._tail = prev;
  child[prevProp] = null;
  child[nextProp] = null;
}

/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {Function} [sortMethod]
 * @param  {String} prevProp
 * @param  {String} nextProp
 * @return {void}
 */
export const addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {
  let prev = parent._tail;
  while (prev && sortMethod && sortMethod(prev, child)) prev = prev[prevProp];
  const next = prev ? prev[nextProp] : parent._head;
  prev ? prev[nextProp] = child : parent._head = child;
  next ? next[prevProp] = child : parent._tail = child;
  child[prevProp] = prev;
  child[nextProp] = next;
}



================================================
FILE: src/properties.js
================================================
/// <reference path='./types.js' />

import {
  tweenTypes,
  shortTransforms,
} from './consts.js';

import {
  isSvg,
  toLowerCase,
} from './helpers.js';

const propertyNamesCache = {};

/**
 * @param  {String} propertyName
 * @param  {Target} target
 * @param  {tweenTypes} tweenType
 * @return {String}
 */
export const sanitizePropertyName = (propertyName, target, tweenType) => {
  if (tweenType === tweenTypes.TRANSFORM) {
    const t = shortTransforms.get(propertyName);
    return t ? t : propertyName;
  } else if (
    tweenType === tweenTypes.CSS ||
    // Handle special cases where properties like "strokeDashoffset" needs to be set as "stroke-dashoffset"
    // but properties like "baseFrequency" should stay in lowerCamelCase
    (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */(target).style))
  ) {
    const cachedPropertyName = propertyNamesCache[propertyName];
    if (cachedPropertyName) {
      return cachedPropertyName;
    } else {
      const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;
      propertyNamesCache[propertyName] = lowerCaseName;
      return lowerCaseName;
    }
  } else {
    return propertyName;
  }
}



================================================
FILE: src/render.js
================================================
/// <reference path='./types.js' />

import {
  globals,
} from './globals.js';

import {
  tweenTypes,
  valueTypes,
  tickModes,
  compositionTypes,
  emptyString,
  transformsFragmentStrings,
  transformsSymbol,
  minValue,
} from './consts.js';

import {
  now,
  clamp,
  round,
  interpolate,
  forEachChildren,
} from './helpers.js';

/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {tickModes} tickMode
 * @return {Number}
 */
export const render = (tickable, time, muteCallbacks, internalRender, tickMode) => {

  const parent = tickable.parent;
  const duration = tickable.duration;
  const completed = tickable.completed;
  const iterationDuration = tickable.iterationDuration;
  const iterationCount = tickable.iterationCount;
  const _currentIteration = tickable._currentIteration;
  const _loopDelay = tickable._loopDelay;
  const _reversed = tickable._reversed;
  const _alternate = tickable._alternate;
  const _hasChildren = tickable._hasChildren;
  const tickableDelay = tickable._delay;
  const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime

  const tickableEndTime = tickableDelay + iterationDuration;
  const tickableAbsoluteTime = time - tickableDelay;
  const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);
  const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);
  const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
  const isCurrentTimeAboveZero = tickableCurrentTime > 0;
  const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;
  const isSetter = duration <= minValue;
  const forcedTick = tickMode === tickModes.FORCE;

  let isOdd = 0;
  let iterationElapsedTime = tickableAbsoluteTime;
  // Render checks
  // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer
  let hasRendered = 0;

  // Execute the "expensive" iterations calculations only when necessary
  if (iterationCount > 1) {
    // bitwise NOT operator seems to be generally faster than Math.floor() across browsers
    const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));
    tickable._currentIteration = clamp(currentIteration, 0, iterationCount);
    // Prevent the iteration count to go above the max iterations when reaching the end of the animation
    if (isCurrentTimeEqualOrAboveDuration) tickable._currentIteration--;
    isOdd = tickable._currentIteration % 2;
    iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
  }

  // Checks if exactly one of _reversed and (_alternate && isOdd) is true
  const isReversed = _reversed ^ (_alternate && isOdd);
  const _ease = /** @type {Renderable} */(tickable)._ease;
  let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
  if (_ease) iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
  const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;

  tickable._currentTime = tickableAbsoluteTime;
  tickable._iterationTime = iterationTime;
  tickable.backwards = isRunningBackwards;

  if (isCurrentTimeAboveZero && !tickable.began) {
    tickable.began = true;
    if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
      tickable.onBegin(/** @type {CallbackArgument} */(tickable));
    }
  } else if (tickableAbsoluteTime <= 0) {
    tickable.began = false;
  }

  // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function
  // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values
  if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {
    tickable.onLoop(/** @type {CallbackArgument} */(tickable));
  }

  if (
    forcedTick ||
    tickMode === tickModes.AUTO && (
      time >= tickableDelay && time <= tickableEndTime || // Normal render
      time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state
      time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state
    ) ||
    iterationTime >= tickableEndTime && tickablePrevTime !== duration ||
    iterationTime <= tickableDelay && tickablePrevTime > 0 ||
    time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation
    isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped
  ) {

    if (isCurrentTimeAboveZero) {
      // Trigger onUpdate callback before rendering
      tickable.computeDeltaTime(tickablePrevTime);
      if (!muteCallbacks) tickable.onBeforeUpdate(/** @type {CallbackArgument} */(tickable));
    }

    // Start tweens rendering
    if (!_hasChildren) {

      // Time has jumped more than globals.tickThreshold so consider this tick manual
      const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;
      const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;

      // Only Animation can have tweens, Timer returns undefined
      let tween = /** @type {Tween} */(/** @type {JSAnimation} */(tickable)._head);
      let tweenTarget;
      let tweenStyle;
      let tweenTargetTransforms;
      let tweenTargetTransformsProperties;
      let tweenTransformsNeedUpdate = 0;

      while (tween) {

        const tweenComposition = tween._composition;
        const tweenCurrentTime = tween._currentTime;
        const tweenChangeDuration = tween._changeDuration;
        const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
        const tweenNextRep = tween._nextRep;
        const tweenPrevRep = tween._prevRep;
        const tweenHasComposition = tweenComposition !== compositionTypes.none;

        if ((forcedRender || (
            (tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&
            (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime)
          )) && (!tweenHasComposition || (
            !tween._isOverridden &&
            (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&
            (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&
            (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))
          ))
        ) {

          const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);
          const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
          const tweenModifier = tween._modifier;
          const tweenValueType = tween._valueType;
          const tweenType = tween._tweenType;
          const tweenIsObject = tweenType === tweenTypes.OBJECT;
          const tweenIsNumber = tweenValueType === valueTypes.NUMBER;
          // Only round the in-between frames values if the final value is a string
          const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;

          // Recompose tween value
          /** @type {String|Number} */
          let value;
          /** @type {Number} */
          let number;

          if (tweenIsNumber) {
            value = number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision )));
          } else if (tweenValueType === valueTypes.UNIT) {
            // Rounding the values speed up string composition
            number = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber,  tweenProgress), tweenPrecision)));
            value = `${number}${tween._unit}`;
          } else if (tweenValueType === valueTypes.COLOR) {
            const fn = tween._fromNumbers;
            const tn = tween._toNumbers;
            const r = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[0], tn[0], tweenProgress))), 0, 255), 0);
            const g = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[1], tn[1], tweenProgress))), 0, 255), 0);
            const b = round(clamp(/** @type {Number} */(tweenModifier(interpolate(fn[2], tn[2], tweenProgress))), 0, 255), 0);
            const a = clamp(/** @type {Number} */(tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);
            value = `rgba(${r},${g},${b},${a})`;
            if (tweenHasComposition) {
              const ns = tween._numbers;
              ns[0] = r;
              ns[1] = g;
              ns[2] = b;
              ns[3] = a;
            }
          } else if (tweenValueType === valueTypes.COMPLEX) {
            value = tween._strings[0];
            for (let j = 0, l = tween._toNumbers.length; j < l; j++) {
              const n = /** @type {Number} */(tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));
              const s = tween._strings[j + 1];
              value += `${s ? n + s : n}`;
              if (tweenHasComposition) {
                tween._numbers[j] = n;
              }
            }
          }

          // For additive tweens and Animatables
          if (tweenHasComposition) {
            tween._number = number;
          }

          if (!internalRender && tweenComposition !== compositionTypes.blend) {

            const tweenProperty = tween.property;
            tweenTarget = tween.target;

            if (tweenIsObject) {
              tweenTarget[tweenProperty] = value;
            } else if (tweenType === tweenTypes.ATTRIBUTE) {
              /** @type {DOMTarget} */(tweenTarget).setAttribute(tweenProperty, /** @type {String} */(value));
            } else {
              tweenStyle = /** @type {DOMTarget} */(tweenTarget).style;
              if (tweenType === tweenTypes.TRANSFORM) {
                if (tweenTarget !== tweenTargetTransforms) {
                  tweenTargetTransforms = tweenTarget;
                  // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.
                  tweenTargetTransformsProperties = tweenTarget[transformsSymbol];
                }
                tweenTargetTransformsProperties[tweenProperty] = value;
                tweenTransformsNeedUpdate = 1;
              } else if (tweenType === tweenTypes.CSS) {
                tweenStyle[tweenProperty] = value;
              } else if (tweenType === tweenTypes.CSS_VAR) {
                tweenStyle.setProperty(tweenProperty,/** @type {String} */(value));
              }
            }

            if (isCurrentTimeAboveZero) hasRendered = 1;

          } else {
            // Used for composing timeline tweens without having to do a real render
            tween._value = value;
          }

        }

        // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax
        // to reduce memory usage on string composition
        if (tweenTransformsNeedUpdate && tween._renderTransforms) {
          let str = emptyString;
          for (let key in tweenTargetTransformsProperties) {
            str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;
          }
          tweenStyle.transform = str;
          tweenTransformsNeedUpdate = 0;
        }

        tween = tween._next;
      }

      if (!muteCallbacks && hasRendered) {
        /** @type {JSAnimation} */(tickable).onRender(/** @type {JSAnimation} */(tickable));
      }
    }

    if (!muteCallbacks && isCurrentTimeAboveZero) {
      tickable.onUpdate(/** @type {CallbackArgument} */(tickable));
    }

  }

  // End tweens rendering

  // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards
  if (parent && isSetter) {
    if (!muteCallbacks && (
      (parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed) ||
      (isRunningBackwards && tickableAbsoluteTime <= minValue && completed)
    )) {
      tickable.onComplete(/** @type {CallbackArgument} */(tickable));
      tickable.completed = !isRunningBackwards;
    }
  // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops
  } else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
    if (iterationCount === Infinity) {
      // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer
      tickable._startTime += tickable.duration;
    } else if (tickable._currentIteration >= iterationCount - 1) {
      // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick
      tickable.paused = true;
      if (!completed && !_hasChildren) {
        // If the tickable has children, triggers onComplete() only when all children have completed in the tick function
        tickable.completed = true;
        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
          tickable.onComplete(/** @type {CallbackArgument} */(tickable));
          tickable._resolve(/** @type {CallbackArgument} */(tickable));
        }
      }
    }
  // Otherwise set the completed flag to false
  } else {
    tickable.completed = false;
  }

  // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?
  return hasRendered;
}

/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {Number} tickMode
 * @return {void}
 */
export const tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {
  const _currentIteration = tickable._currentIteration;
  render(tickable, time, muteCallbacks, internalRender, tickMode);
  if (tickable._hasChildren) {
    const tl = /** @type {Timeline} */(tickable);
    const tlIsRunningBackwards = tl.backwards;
    const tlChildrenTime = internalRender ? time : tl._iterationTime;
    const tlCildrenTickTime = now();

    let tlChildrenHasRendered = 0;
    let tlChildrenHaveCompleted = true;

    // If the timeline has looped forward, we need to manually triggers children skipped callbacks
    if (!internalRender && tl._currentIteration !== _currentIteration) {
      const tlIterationDuration = tl.iterationDuration;
      forEachChildren(tl, (/** @type {JSAnimation} */child) => {
        if (!tlIsRunningBackwards) {
          // Force an internal render to trigger the callbacks if the child has not completed on loop
          if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {
            render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);
          }
          // Reset their began and completed flags to allow retrigering callbacks on the next iteration
          child.began = false;
          child.completed = false;
        } else {
          const childDuration = child.duration;
          const childStartTime = child._offset + child._delay;
          const childEndTime = childStartTime + childDuration;
          // Triggers the onComplete callback on reverse for children on the edges of the timeline
          if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {
            child.onComplete(child);
          }
        }
      });
      if (!muteCallbacks) tl.onLoop(/** @type {CallbackArgument} */(tl));
    }

    forEachChildren(tl, (/** @type {JSAnimation} */child) => {
      const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds
      const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
      tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
      if (!child.completed && tlChildrenHaveCompleted) tlChildrenHaveCompleted = false;
    }, tlIsRunningBackwards);

    // Renders on timeline are triggered by its children so it needs to be set after rendering the children
    if (!muteCallbacks && tlChildrenHasRendered) tl.onRender(/** @type {CallbackArgument} */(tl));

    // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end
    if (tlChildrenHaveCompleted && tl._currentTime >= tl.duration) {
      // Make sure the paused flag is false in case it has been skipped in the render function
      tl.paused = true;
      if (!tl.completed) {
        tl.completed = true;
        if (!muteCallbacks) {
          tl.onComplete(/** @type {CallbackArgument} */(tl));
          tl._resolve(/** @type {CallbackArgument} */(tl));
        }
      }
    }
  }
}



================================================
FILE: src/scope.js
================================================
/// <reference path='./types.js' />

import {
  doc,
  win,
} from './consts.js';

import {
  globals,
} from './globals.js';

import {
  isFnc,
  mergeObjects,
} from './helpers.js';

import {
  parseTargets,
} from './targets.js';

/**
 * @typedef {Object} ReactRef
 * @property {HTMLElement|SVGElement|null} [current]
 */

/**
 * @typedef {Object} AngularRef
 * @property {HTMLElement|SVGElement} [nativeElement]
 */

/**
 * @typedef {Object} ScopeParams
 * @property {DOMTargetSelector|ReactRef|AngularRef} [root]
 * @property {DefaultsParams} [defaults]
 * @property {Record<String, String>} [mediaQueries]
 */

/**
 * @callback ScopeCleanup
 * @param {Scope} [scope]
 */

/**
 * @callback ScopeConstructor
 * @param {Scope} [scope]
 * @return {ScopeCleanup|void}
 */

/**
 * @callback ScopeMethod
 * @param {...*} args
 * @return {ScopeCleanup|void}
 */

export class Scope {
  /** @param {ScopeParams} [parameters] */
  constructor(parameters = {}) {
    if (globals.scope) globals.scope.revertibles.push(this);
    const rootParam = parameters.root;
    /** @type {Document|DOMTarget} */
    let root = doc;
    if (rootParam) {
      root = /** @type {ReactRef} */(rootParam).current ||
             /** @type {AngularRef} */(rootParam).nativeElement ||
             parseTargets(/** @type {DOMTargetSelector} */(rootParam))[0] ||
             doc;
    }
    const scopeDefaults = parameters.defaults;
    const globalDefault = globals.defaults;
    const mediaQueries = parameters.mediaQueries;
    /** @type {DefaultsParams} */
    this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;
    /** @type {Document|DOMTarget} */
    this.root = root;
    /** @type {Array<ScopeConstructor>} */
    this.constructors = [];
    /** @type {Array<Function>} */
    this.revertConstructors = [];
    /** @type {Array<Revertible>} */
    this.revertibles = [];
    /** @type {Record<String, Function>} */
    this.methods = {};
    /** @type {Record<String, Boolean>} */
    this.matches = {};
    /** @type {Record<String, MediaQueryList>} */
    this.mediaQueryLists = {};
    /** @type {Record<String, any>} */
    this.data = {};
    if (mediaQueries) {
      for (let mq in mediaQueries) {
        const _mq = win.matchMedia(mediaQueries[mq]);
        this.mediaQueryLists[mq] = _mq;
        _mq.addEventListener('change', this);
      }
    }
  }

  /**
   * @callback ScoppedCallback
   * @param {this} scope
   * @return {any}
   *
   * @param {ScoppedCallback} cb
   * @return {this}
   */
  execute(cb) {
    let activeScope = globals.scope;
    let activeRoot = globals.root;
    let activeDefaults = globals.defaults;
    globals.scope = this;
    globals.root = this.root;
    globals.defaults = this.defaults;
    const mqs = this.mediaQueryLists;
    for (let mq in mqs) this.matches[mq] = mqs[mq].matches;
    const returned = cb(this);
    globals.scope = activeScope;
    globals.root = activeRoot;
    globals.defaults = activeDefaults;
    return returned;
  }

  /**
   * @return {this}
   */
  refresh() {
    this.execute(() => {
      let i = this.revertibles.length;
      let y = this.revertConstructors.length;
      while (i--) this.revertibles[i].revert();
      while (y--) this.revertConstructors[y](this);
      this.revertibles.length = 0;
      this.revertConstructors.length = 0;
      this.constructors.forEach( constructor => {
        const revertConstructor = constructor(this);
        if (revertConstructor) {
          this.revertConstructors.push(revertConstructor);
        }
      });
    });
    return this;
  }

  /**
   * @callback contructorCallback
   * @param {this} self
   *
   * @overload
   * @param {String} a1
   * @param {ScopeMethod} a2
   * @return {this}
   *
   * @overload
   * @param {contructorCallback} a1
   * @return {this}
   *
   * @param {String|contructorCallback} a1
   * @param {ScopeMethod} [a2]
   */
  add(a1, a2) {
    if (isFnc(a1)) {
      const constructor = /** @type {contructorCallback} */(a1);
      this.constructors.push(constructor);
      this.execute(() => {
        const revertConstructor = constructor(this);
        if (revertConstructor) {
          this.revertConstructors.push(revertConstructor);
        }
      });
    } else {
      this.methods[/** @type {String} */(a1)] = (/** @type {any} */...args) => this.execute(() => a2(...args));
    }
    return this;
  }

  /**
   * @param {Event} e
   */
  handleEvent(e) {
    switch (e.type) {
      case 'change':
        this.refresh();
        break;
    }
  }

  revert() {
    const revertibles = this.revertibles;
    const revertConstructors = this.revertConstructors;
    const mqs = this.mediaQueryLists;
    let i = revertibles.length;
    let y = revertConstructors.length;
    while (i--) revertibles[i].revert();
    while (y--) revertConstructors[y](this);
    for (let mq in mqs) mqs[mq].removeEventListener('change', this);
    revertibles.length = 0;
    revertConstructors.length = 0;
    this.constructors.length = 0;
    this.matches = {};
    this.methods = {};
    this.mediaQueryLists = {};
    this.data = {};
  }
}

/**
 * @param {ScopeParams} [params]
 * @return {Scope}
 */
export const createScope = params => new Scope(params);


================================================
FILE: src/scroll.js
================================================
import {
  win,
  doc,
  noop,
  isDomSymbol,
  relativeValuesExecRgx,
} from './consts.js';

import {
  globals,
} from './globals.js';

import {
  none,
  parseEasings,
} from './eases.js';

import {
  addChild,
  removeChild,
  forEachChildren,
  interpolate,
  clamp,
  round,
  isFnc,
  isNum,
  isObj,
  isStr,
  isUnd,
} from './helpers.js';

import {
  parseTargets,
} from './targets.js';

import {
  Timer,
} from './timer.js';

import {
  convertValueUnit,
} from './units.js';

import {
  lerp,
  getTargetValue,
  setTargetValues,
  sync,
} from './utils.js';

import {
  decomposeRawValue,
  decomposedOriginalValue,
  getRelativeValue,
  setValue,
} from './values.js';

/**
 * @typedef {String|Number} ScrollThresholdValue
 */

/**
 * @return {Number}
 */
const getMaxViewHeight = () => {
  const $el = document.createElement('div');
  doc.body.appendChild($el);
  $el.style.height = '100lvh';
  const height = $el.offsetHeight;
  doc.body.removeChild($el);
  return height;
}

/**
 * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T
 * @param {T | ((observer: ScrollObserver) => T)} value
 * @param {ScrollObserver} scroller
 * @return {T}
 */
const parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */(value)(scroller) : value;

export const scrollContainers = new Map();

class ScrollContainer {
  /**
   * @param {HTMLElement} $el
   */
  constructor($el) {
    /** @type {HTMLElement} */
    this.element = $el;
    /** @type {Boolean} */
    this.useWin = this.element === doc.body;
    /** @type {Number} */
    this.winWidth = 0;
    /** @type {Number} */
    this.winHeight = 0;
    /** @type {Number} */
    this.width = 0;
    /** @type {Number} */
    this.height = 0;
    /** @type {Number} */
    this.left = 0;
    /** @type {Number} */
    this.top = 0;
    /** @type {Number} */
    this.zIndex = 0;
    /** @type {Number} */
    this.scrollX = 0;
    /** @type {Number} */
    this.scrollY = 0;
    /** @type {Number} */
    this.prevScrollX = 0;
    /** @type {Number} */
    this.prevScrollY = 0;
    /** @type {Number} */
    this.scrollWidth = 0;
    /** @type {Number} */
    this.scrollHeight = 0;
    /** @type {Number} */
    this.velocity = 0;
    /** @type {Boolean} */
    this.backwardX = false;
    /** @type {Boolean} */
    this.backwardY = false;
    /** @type {Timer} */
    this.scrollTicker = new Timer({
      autoplay: false,
      onBegin: () => this.dataTimer.resume(),
      onUpdate: () => {
        const backwards = this.backwardX || this.backwardY;
        forEachChildren(this, (/** @type {ScrollObserver} */child) => child.handleScroll(), backwards);
      },
      onComplete: () => this.dataTimer.pause()
    }).init();
    /** @type {Timer} */
    this.dataTimer = new Timer({
      autoplay: false,
      frameRate: 30,
      onUpdate: self => {
        const dt = self.deltaTime;
        const px = this.prevScrollX;
        const py = this.prevScrollY;
        const nx = this.scrollX;
        const ny = this.scrollY;
        const dx = px - nx;
        const dy = py - ny;
        this.prevScrollX = nx;
        this.prevScrollY = ny;
        if (dx) this.backwardX = px > nx;
        if (dy) this.backwardY = py > ny;
        this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);
      }
    }).init();
    /** @type {Timer} */
    this.resizeTicker = new Timer({
      autoplay: false,
      duration: 250 * globals.timeScale,
      onComplete: () => {
        this.updateWindowBounds();
        this.refreshScrollObservers();
        this.handleScroll();
      }
    }).init();
    /** @type {Timer} */
    this.wakeTicker = new Timer({
      autoplay: false,
      duration: 500 * globals.timeScale,
      onBegin: () => {
        this.scrollTicker.resume();
      },
      onComplete: () => {
        this.scrollTicker.pause();
      }
    }).init();
    /** @type {ScrollObserver} */
    this._head = null;
    /** @type {ScrollObserver} */
    this._tail = null;
    this.updateScrollCoords();
    this.updateWindowBounds();
    this.updateBounds();
    this.refreshScrollObservers();
    this.handleScroll();
    this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());
    this.resizeObserver.observe(this.element);
    (this.useWin ? win : this.element).addEventListener('scroll', this, false);
  }

  updateScrollCoords() {
    const useWin = this.useWin;
    const $el = this.element;
    this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);
    this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);
  }

  updateWindowBounds() {
    this.winWidth = win.innerWidth;
    this.winHeight = getMaxViewHeight();
  }

  updateBounds() {
    const style = getComputedStyle(this.element);
    const $el = this.element;
    this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
    this.updateWindowBounds();
    let width, height;
    if (this.useWin) {
      width = this.winWidth;
      height = this.winHeight;
    } else {
      const elRect = $el.getBoundingClientRect();
      width = elRect.width;
      height = elRect.height;
      this.top = elRect.top;
      this.left = elRect.left;
    }
    this.width = width;
    this.height = height;
  }

  refreshScrollObservers() {
    forEachChildren(this, (/** @type {ScrollObserver} */child) => {
      if (child._debug) {
        child.removeDebug();
      }
    });
    this.updateBounds();
    forEachChildren(this, (/** @type {ScrollObserver} */child) => {
      child.refresh();
      if (child._debug) {
        child.debug();
      }
    });
  }

  refresh() {
    this.updateWindowBounds();
    this.updateBounds();
    this.refreshScrollObservers();
    this.handleScroll();
  }

  handleScroll() {
    this.updateScrollCoords();
    this.wakeTicker.restart();
  }

  /**
   * @param {Event} e
   */
  handleEvent(e) {
    switch (e.type) {
      case 'scroll':
        this.handleScroll();
        break;
    }
  }

  revert() {
    this.scrollTicker.cancel();
    this.dataTimer.cancel();
    this.resizeTicker.cancel();
    this.wakeTicker.cancel();
    this.resizeObserver.unobserve(this.element);
    (this.useWin ? win : this.element).removeEventListener('scroll', this);
    scrollContainers.delete(this.element);
  }
}

/**
 * @param {TargetsParam} target
 * @return {ScrollContainer}
 */
const registerAndGetScrollContainer = target => {
  const $el = /** @type {HTMLElement} */(target ? parseTargets(target)[0] || doc.body : doc.body);
  let scrollContainer = scrollContainers.get($el);
  if (!scrollContainer) {
    scrollContainer = new ScrollContainer($el);
    scrollContainers.set($el, scrollContainer);
  }
  return scrollContainer;
}

/**
 * @param {HTMLElement} $el
 * @param {Number|string} v
 * @param {Number} size
 * @param {Number} [under]
 * @param {Number} [over]
 * @return {Number}
 */
const convertValueToPx = ($el, v, size, under, over) => {
  const clampMin = v === 'min';
  const clampMax = v === 'max';
  const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :
                v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :
                v === 'center' ? '50%' :
                v;
  const { n, u } = decomposeRawValue(value, decomposedOriginalValue);
  let px = n;
  if (u === '%') {
    px = (n / 100) * size;
  } else if (u) {
    px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;
  }
  if (clampMax && under < 0) px += under;
  if (clampMin && over > 0) px += over;
  return px;
}

/**
 * @param {HTMLElement} $el
 * @param {ScrollThresholdValue} v
 * @param {Number} size
 * @param {Number} [under]
 * @param {Number} [over]
 * @return {Number}
 */
const parseBoundValue = ($el, v, size, under, over) => {
  /** @type {Number} */
  let value;
  if (isStr(v)) {
    const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */(v));
    if (matchedOperator) {
      const splitter = matchedOperator[0];
      const operator = splitter[0];
      const splitted = /** @type {String} */(v).split(splitter);
      const clampMin = splitted[0] === 'min';
      const clampMax = splitted[0] === 'max';
      const valueAPx = convertValueToPx($el, splitted[0], size, under, over);
      const valueBPx = convertValueToPx($el, splitted[1], size, under, over);
      if (clampMin) {
        const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);
        value = min < valueAPx ? valueAPx : min;
      } else if (clampMax) {
        const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);
        value = max > valueAPx ? valueAPx : max;
      } else {
        value = getRelativeValue(valueAPx, valueBPx, operator);
      }
    } else {
      value = convertValueToPx($el, v, size, under, over);
    }
  } else {
    value = /** @type {Number} */(v);
  }
  return round(value, 0);
}

/**
 * @param {JSAnimation} linked
 * @return {HTMLElement}
 */
const getAnimationDomTarget = linked => {
  let $linkedTarget;
  const linkedTargets = linked.targets;
  for (let i = 0, l = linkedTargets.length; i < l; i++) {
    const target = linkedTargets[i];
    if (target[isDomSymbol]) {
      $linkedTarget = /** @type {HTMLElement} */(target);
      break;
    }
  }
  return $linkedTarget;
}

let scrollerIndex = 0;

const debugColors = ['#FF4B4B','#FF971B','#FFC730','#F9F640','#7AFF5A','#18FF74','#17E09B','#3CFFEC','#05DBE9','#33B3F1','#638CF9','#C563FE','#FF4FCF','#F93F8A'];

/**
 * @typedef {Object} ScrollThresholdParam
 * @property {ScrollThresholdValue} [target]
 * @property {ScrollThresholdValue} [container]
 */

/**
 * @callback ScrollObserverAxisCallback
 * @param {ScrollObserver} self
 * @return {'x'|'y'}
 */

/**
 * @callback ScrollThresholdCallback
 * @param {ScrollObserver} self
 * @return {ScrollThresholdValue|ScrollThresholdParam}
 */

/**
 * @typedef {Object} ScrollObserverParams
 * @property {Number|String} [id]
 * @property {Boolean|Number|String|EasingParam} [sync]
 * @property {TargetsParam} [container]
 * @property {TargetsParam} [target]
 * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]
 * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]
 * @property {Boolean} [debug]
 * @property {Callback<ScrollObserver>} [onEnter]
 * @property {Callback<ScrollObserver>} [onLeave]
 * @property {Callback<ScrollObserver>} [onEnterForward]
 * @property {Callback<ScrollObserver>} [onLeaveForward]
 * @property {Callback<ScrollObserver>} [onEnterBackward]
 * @property {Callback<ScrollObserver>} [onLeaveBackward]
 * @property {Callback<ScrollObserver>} [onUpdate]
 * @property {Callback<ScrollObserver>} [onSyncComplete]
 */

export class ScrollObserver {
  /**
   * @param {ScrollObserverParams} parameters
   */
  constructor(parameters = {}) {
    if (globals.scope) globals.scope.revertibles.push(this);
    const syncMode = setValue(parameters.sync, 'play pause');
    const ease = syncMode ? parseEasings(/** @type {EasingParam} */(syncMode)) : null;
    const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);
    const isEase = syncMode && !(ease === none && !isLinear);
    const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);
    const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);
    const syncMethods = isMethods ? /** @type {String} */(syncMode).split(' ').map(
      (/** @type {String} */m) => () => {
        const linked = this.linked;
        return linked && linked[m] ? linked[m]() : null;
      }
    ) : null;
    const biDirSync = isMethods && syncMethods.length > 2;
    /** @type {Number} */
    this.index = scrollerIndex++;
    /** @type {String|Number} */
    this.id = !isUnd(parameters.id) ? parameters.id : this.index;
    /** @type {ScrollContainer} */
    this.container = registerAndGetScrollContainer(parameters.container);
    /** @type {HTMLElement} */
    this.target = null;
    /** @type {Tickable|WAAPIAnimation} */
    this.linked = null;
    /** @type {Boolean} */
    this.repeat = null;
    /** @type {Boolean} */
    this.horizontal = null;
    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
    this.enter = null;
    /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
    this.leave = null;
    /** @type {Boolean} */
    this.sync = isEase || isSmooth || !!syncMethods;
    /** @type {EasingFunction} */
    this.syncEase = isEase ? ease : null;
    /** @type {Number} */
    this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */(syncMode) : null;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;
    /** @type {Callback<ScrollObserver>} */
    this.onEnter = parameters.onEnter || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onLeave = parameters.onLeave || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onEnterForward = parameters.onEnterForward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onLeaveForward = parameters.onLeaveForward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onEnterBackward = parameters.onEnterBackward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onLeaveBackward = parameters.onLeaveBackward || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onUpdate = parameters.onUpdate || noop;
    /** @type {Callback<ScrollObserver>} */
    this.onSyncComplete = parameters.onSyncComplete || noop;
    /** @type {Boolean} */
    this.reverted = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Boolean} */
    this.began = false;
    /** @type {Boolean} */
    this.isInView = false;
    /** @type {Boolean} */
    this.forceEnter = false;
    /** @type {Boolean} */
    this.hasEntered = false;
    /** @type {Array.<Number>} */
    this.offsets = [];
    /** @type {Number} */
    this.offset = 0;
    /** @type {Number} */
    this.offsetStart = 0;
    /** @type {Number} */
    this.offsetEnd = 0;
    /** @type {Number} */
    this.distance = 0;
    /** @type {Number} */
    this.prevProgress = 0;
    /** @type {Array} */
    this.thresholds = ['start', 'end', 'end', 'start'];
    /** @type {[Number, Number, Number, Number]} */
    this.coords = [0, 0, 0, 0];
    /** @type {JSAnimation} */
    this.debugStyles = null;
    /** @type {HTMLElement} */
    this.$debug = null;
    /** @type {ScrollObserverParams} */
    this._params = parameters;
    /** @type {Boolean} */
    this._debug = setValue(parameters.debug, false);
    /** @type {ScrollObserver} */
    this._next = null;
    /** @type {ScrollObserver} */
    this._prev = null;
    addChild(this.container, this);
    // Wait for the next frame to add to the container in order to handle calls to link()
    sync(() => {
      if (this.reverted) return;
      if (!this.target) {
        const target = /** @type {HTMLElement} */(parseTargets(parameters.target)[0]);
        this.target = target || doc.body;
        this.refresh();
      }
      if (this._debug) this.debug();
    });
  }

  /**
   * @param {Tickable|WAAPIAnimation} linked
   */
  link(linked) {
    if (linked) {
      // Make sure to pause the linked object in case it's added later
      linked.pause();
      this.linked = linked;
      // Try to use a target of the linked object if no target parameters specified
      if (!this._params.target) {
        /** @type {HTMLElement} */
        let $linkedTarget;
        if (!isUnd(/** @type {JSAnimation} */(linked).targets)) {
          $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(linked));
        } else {
          forEachChildren(/** @type {Timeline} */(linked), (/** @type {JSAnimation} */child) => {
            if (child.targets && !$linkedTarget) {
              $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */(child));
            }
          });
        }
        // Fallback to body if no target found
        this.target = $linkedTarget || doc.body;
        this.refresh();
      }
    }
    return this;
  }

  get velocity() {
    return this.container.velocity;
  }

  get backward() {
    return this.horizontal ? this.container.backwardX : this.container.backwardY;
  }

  get scroll() {
    return this.horizontal ? this.container.scrollX : this.container.scrollY;
  }

  get progress() {
    const p = (this.scroll - this.offsetStart) / this.distance;
    return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);
  }

  refresh() {
    this.reverted = false;
    const params = this._params;
    this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);
    this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';
    this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');
    this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');
    this.updateBounds();
    this.handleScroll();
    return this;
  }

  removeDebug() {
    if (this.$debug) {
      this.$debug.parentNode.removeChild(this.$debug);
      this.$debug = null;
    }
    if (this.debugStyles) {
      this.debugStyles.revert();
      this.$debug = null;
    }
    return this;
  }

  debug() {
    this.removeDebug();
    const container = this.container;
    const isHori = this.horizontal;
    const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');
    const $debug = doc.createElement('div');
    const $thresholds = doc.createElement('div');
    const $triggers = doc.createElement('div');
    const color = debugColors[this.index % debugColors.length];
    const useWin = container.useWin;
    const containerWidth = useWin ? container.winWidth : container.width;
    const containerHeight = useWin ? container.winHeight : container.height;
    const scrollWidth = container.scrollWidth;
    const scrollHeight = container.scrollHeight;
    const size = this.container.width > 360 ? 320 : 260;
    const offLeft = isHori ? 0 : 10;
    const offTop = isHori ? 10 : 0;
    const half = isHori ? 24 : size / 2;
    const labelHeight = isHori ? half : 15;
    const labelWidth = isHori ? 60 : half;
    const labelSize = isHori ? labelWidth : labelHeight;
    const repeat = isHori ? 'repeat-x' : 'repeat-y';
    /**
     * @param {Number} v
     * @return {String}
     */
    const gradientOffset = v => isHori ? '0px '+(v)+'px' : (v)+'px'+' 2px';
    /**
     * @param {String} c
     * @return {String}
     */
    const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;
    /**
     * @param {String} p
     * @param {Number} l
     * @param {Number} t
     * @param {Number} w
     * @param {Number} h
     * @return {String}
     */
    const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;
    $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}
      pointer-events: none;
      z-index: ${this.container.zIndex++};
      display: flex;
      flex-direction: ${isHori ? 'column' : 'row'};
      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));
    `;
    $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;
    if (!$existingDebug) {
      $thresholds.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(half-10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(half-10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};
      `;
    }
    $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;
    if (!$existingDebug) {
      $triggers.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};
      `;
    }
    const labels = [' enter: ', ' leave: '];
    this.coords.forEach((v, i) => {
      const isView = i > 1;
      const value = (isView ? 0 : this.offset) + v;
      const isTail = i % 2;
      const isFirst = value < labelSize;
      const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;
      const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;
      const $label = doc.createElement('div');
      const $text = doc.createElement('div');
      const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';
      const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;
      // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;
      $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;
      $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}
        display: flex;
        flex-direction: ${isHori ? 'column' : 'row'};
        justify-content: flex-${isView ? 'start' : 'end'};
        align-items: flex-${isFlip ? 'end' : 'start'};
        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};
      `;
      $text.style.cssText = `
        overflow: hidden;
        max-width: ${(size / 2) - 10}px;
        height: ${labelHeight};
        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;
        padding: 1px;
        font-family: ui-monospace, monospace;
        font-size: 10px;
        letter-spacing: -.025em;
        line-height: 9px;
        font-weight: 600;
        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};
        white-space: pre;
        text-overflow: ellipsis;
        color: ${isTail ? color : 'rgba(0,0,0,.75)'};
        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};
        border: 2px solid ${isTail ? color : 'transparent'};
        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;
        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;
      `;
      $label.appendChild($text);
      let position = value - flipOffset + (isHori ? 1 : 0);
      $label.style[isHori ? 'left' : 'top'] = `${position}px`;
      // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';
      (isView ? $thresholds : $triggers).appendChild($label);
    });

    $debug.appendChild($thresholds);
    $debug.appendChild($triggers);
    container.element.appendChild($debug);

    if (!$existingDebug) $debug.classList.add('animejs-onscroll-debug');
    this.$debug = $debug;
    const containerPosition = getTargetValue(container.element, 'position');
    if (containerPosition === 'static') {
      this.debugStyles = setTargetValues(container.element, { position: 'relative '});
    }

  }

  updateBounds() {
    if (this._debug) {
      this.removeDebug();
    }
    let stickys;
    const $target = this.target;
    const container = this.container;
    const isHori = this.horizontal;
    const linked = this.linked;
    let linkedTime;
    let $el = $target;
    let offsetX = 0;
    let offsetY = 0;
    /** @type {Element} */
    let $offsetParent = $el;
    if (linked) {
      linkedTime = linked.currentTime;
      linked.seek(0, true);
    }
    const isContainerStatic = getTargetValue(container.element, 'position') === 'static' ? setTargetValues(container.element, { position: 'relative '}) : false;
    while ($el && $el !== container.element && $el !== doc.body) {
      const isSticky = getTargetValue($el, 'position') === 'sticky' ?
                       setTargetValues($el, { position: 'static' }) :
                       false;
      if ($el === $offsetParent) {
        offsetX += $el.offsetLeft || 0;
        offsetY += $el.offsetTop || 0;
        $offsetParent = $el.offsetParent;
      }
      $el = /** @type {HTMLElement} */($el.parentElement);
      if (isSticky) {
        if (!stickys) stickys = [];
        stickys.push(isSticky);
      }
    }
    if (isContainerStatic) isContainerStatic.revert();
    const offset = isHori ? offsetX : offsetY;
    const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;
    const containerSize = isHori ? container.width : container.height;
    const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;
    const maxScroll = scrollSize - containerSize;
    const enter = this.enter;
    const leave = this.leave;

    /** @type {ScrollThresholdValue} */
    let enterTarget = 'start';
    /** @type {ScrollThresholdValue} */
    let leaveTarget = 'end';
    /** @type {ScrollThresholdValue} */
    let enterContainer = 'end';
    /** @type {ScrollThresholdValue} */
    let leaveContainer = 'start';

    if (isStr(enter)) {
      const splitted = /** @type {String} */(enter).split(' ');
      enterContainer = splitted[0];
      enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;
    } else if (isObj(enter)) {
      const e = /** @type {ScrollThresholdParam} */(enter);
      if (!isUnd(e.container)) enterContainer = e.container;
      if (!isUnd(e.target)) enterTarget = e.target;
    } else if (isNum(enter)) {
      enterContainer = /** @type {Number} */(enter);
    }

    if (isStr(leave)) {
      const splitted = /** @type {String} */(leave).split(' ');
      leaveContainer = splitted[0];
      leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;
    } else if (isObj(leave)) {
      const t = /** @type {ScrollThresholdParam} */(leave);
      if (!isUnd(t.container)) leaveContainer = t.container;
      if (!isUnd(t.target)) leaveTarget = t.target;
    } else if (isNum(leave)) {
      leaveContainer = /** @type {Number} */(leave);
    }

    const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);
    const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);
    const under = (parsedEnterTarget + offset) - containerSize;
    const over = (parsedLeaveTarget + offset) - maxScroll;
    const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);
    const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);
    const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;
    const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;
    const scrollDelta = offsetEnd - offsetStart;
    this.offsets[0] = offsetX;
    this.offsets[1] = offsetY;
    this.offset = offset;
    this.offsetStart = offsetStart;
    this.offsetEnd = offsetEnd;
    this.distance = scrollDelta <= 0 ? 0 : scrollDelta;
    this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];
    this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];
    if (stickys) {
      stickys.forEach(sticky => sticky.revert());
    }
    if (linked) {
      linked.seek(linkedTime, true);
    }
    if (this._debug) {
      this.debug();
    }
  }

  handleScroll() {
    const linked = this.linked;
    const sync = this.sync;
    const syncEase = this.syncEase;
    const syncSmooth = this.syncSmooth;
    const shouldSeek = linked && (syncEase || syncSmooth);
    const isHori = this.horizontal;
    const container = this.container;
    const scroll = this.scroll;
    const isBefore = scroll <= this.offsetStart;
    const isAfter = scroll >= this.offsetEnd;
    const isInView = !isBefore && !isAfter;
    const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;
    const forceEnter = !this.hasEntered && isOnTheEdge;
    const $debug = this._debug && this.$debug;
    let hasUpdated = false;
    let syncCompleted = false;
    let p = this.progress;

    if (isBefore && this.began) {
      this.began = false;
    }

    if (p > 0 && !this.began) {
      this.began = true;
    }

    if (shouldSeek) {
      const lp = linked.progress;
      if (syncSmooth && isNum(syncSmooth)) {
        if (/** @type {Number} */(syncSmooth) < 1) {
          const step = 0.0001;
          const snap = lp < p && p === 1 ? step : lp > p && !p ? -step : 0;
          p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */(syncSmooth)), false) + snap, 6);
        }
      } else if (syncEase) {
        p = syncEase(p);
      }
      hasUpdated = p !== this.prevProgress;
      syncCompleted = lp === 1;
      if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {
        container.wakeTicker.restart();
      }
    }

    if ($debug) {
      const sticky = isHori ? container.scrollY : container.scrollX;
      $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';
    }

    // Trigger enter callbacks if already in view or when entering the view
    if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {
      if (isInView) this.isInView = true;
      if (!this.forceEnter || !this.hasEntered) {
        if ($debug && isInView) $debug.style.zIndex = `${this.container.zIndex++}`;
        this.onSyncEnter(this);
        this.onEnter(this);
        if (this.backward) {
          this.onSyncEnterBackward(this);
          this.onEnterBackward(this);
        } else {
          this.onSyncEnterForward(this);
          this.onEnterForward(this);
        }
        this.hasEntered = true;
        if (forceEnter) this.forceEnter = true;
      } else if (isInView) {
        this.forceEnter = false;
      }
    }

    if (isInView || !isInView && this.isInView) {
      hasUpdated = true;
    }

    if (hasUpdated) {
      if (shouldSeek) linked.seek(linked.duration * p);
      this.onUpdate(this);
    }

    if (!isInView && this.isInView) {
      this.isInView = false;
      this.onSyncLeave(this);
      this.onLeave(this);
      if (this.backward) {
        this.onSyncLeaveBackward(this);
        this.onLeaveBackward(this);
      } else {
        this.onSyncLeaveForward(this);
        this.onLeaveForward(this);
      }
      if (sync && !syncSmooth) {
        syncCompleted = true;
      }
    }

    if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {
      if (sync) {
        this.onSyncComplete(this);
      }
      this.completed = true;
      if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {
        this.revert();
      }
    }

    if (p < 1 && this.completed) {
      this.completed = false;
    }

    this.prevProgress = p;
  }

  revert() {
    if (this.reverted) return;
    const container = this.container;
    removeChild(container, this);
    if (!container._head) {
      container.revert();
    }
    if (this._debug) {
      this.removeDebug();
    }
    this.reverted = true;
    return this;
  }

}

/**
 * @param {ScrollObserverParams} [parameters={}]
 * @return {ScrollObserver}
 */
export const onScroll = (parameters = {}) => new ScrollObserver(parameters);



================================================
FILE: src/spring.js
================================================
/// <reference path='./types.js' />

import {
  minValue,
  K,
} from './consts.js';

import {
  globals,
} from './globals.js';

import {
  round,
  clamp,
  sqrt,
  exp,
  cos,
  sin,
  abs,
} from './helpers.js';

import {
  setValue,
} from './values.js';

/*
 * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js
 * Webkit Copyright © 2016 Apple Inc
 */

/**
 * @typedef {Object} SpringParams
 * @property {Number} [mass=1] - Mass, default 1
 * @property {Number} [stiffness=100] - Stiffness, default 100
 * @property {Number} [damping=10] - Damping, default 10
 * @property {Number} [velocity=0] - Initial velocity, default 0
 */

export class Spring {
  /**
   * @param {SpringParams} [parameters]
   */
  constructor(parameters = {}) {
    this.timeStep = .02; // Interval fed to the solver to calculate duration
    this.restThreshold = .0005; // Values below this threshold are considered resting position
    this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold
    this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)
    this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation
    this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration
    this.m = clamp(setValue(parameters.mass, 1), 0, K);
    this.s = clamp(setValue(parameters.stiffness, 100), 1, K);
    this.d = clamp(setValue(parameters.damping, 10), .1, K);
    this.v = clamp(setValue(parameters.velocity, 0), -K, K);
    this.w0 = 0;
    this.zeta = 0;
    this.wd = 0;
    this.b = 0;
    this.solverDuration = 0;
    this.duration = 0;
    this.compute();
    /** @type {EasingFunction} */
    this.ease = t => t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);
  }

  /** @type {EasingFunction} */
  solve(time) {
    const { zeta, w0, wd, b } = this;
    let t = time;
    if (zeta < 1) {
      t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));
    } else {
      t = (1 + b * t) * exp(-t * w0);
    }
    return 1 - t;
  }

  compute() {
    const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;
    const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);
    const zeta = this.zeta = d / (2 * sqrt(s * m));
    const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;
    this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;
    let solverTime = 0;
    let restSteps = 0;
    let iterations = 0;
    while (restSteps < maxRestSteps && iterations < maxIterations) {
      if (abs(1 - this.solve(solverTime)) < restThreshold) {
        restSteps++;
      } else {
        restSteps = 0;
      }
      this.solverDuration = solverTime;
      solverTime += timeStep;
      iterations++;
    }
    this.duration = round(this.solverDuration * K, 0) * globals.timeScale;
  }

  get mass() {
    return this.m;
  }

  set mass(v) {
    this.m = clamp(setValue(v, 1), 0, K);
    this.compute();
  }

  get stiffness() {
    return this.s;
  }

  set stiffness(v) {
    this.s = clamp(setValue(v, 100), 1, K);
    this.compute();
  }

  get damping() {
    return this.d;
  }

  set damping(v) {
    this.d = clamp(setValue(v, 10), .1, K);
    this.compute();
  }

  get velocity() {
    return this.v;
  }

  set velocity(v) {
    this.v = clamp(setValue(v, 0), -K, K);
    this.compute();
  }
}

/**
 * @param {SpringParams} [parameters]
 * @returns {Spring}
 */
export const createSpring = (parameters) => new Spring(parameters);



================================================
FILE: src/stagger.js
================================================
/// <reference path='./types.js' />

import {
  emptyString,
  unitsExecRgx,
} from './consts.js';

import {
  isArr,
  isUnd,
  isNum,
  parseNumber,
  round,
  abs,
  floor,
  sqrt,
  max,
} from './helpers.js';

import {
  parseEasings,
} from './eases.js';

import {
  Timeline,
  parseTimelinePosition,
} from './timeline.js';

/**
 * @typedef  {Object} StaggerParameters
 * @property {Number|String} [start]
 * @property {Number|'first'|'center'|'last'} [from]
 * @property {Boolean} [reversed]
 * @property {Array.<Number>} [grid]
 * @property {('x'|'y')} [axis]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 */

/**
 * @callback StaggerFunction
 * @param {Target} [target]
 * @param {Number} [index]
 * @param {Number} [length]
 * @param {Timeline} [tl]
 * @return {Number|String}
 */

/**
 * @param  {Number|String|[Number|String,Number|String]} val
 * @param  {StaggerParameters} params
 * @return {StaggerFunction}
 */
export const stagger = (val, params = {}) => {
  let values = [];
  let maxValue = 0;
  const from = params.from;
  const reversed = params.reversed;
  const ease = params.ease;
  const hasEasing = !isUnd(ease);
  const hasSpring = hasEasing && !isUnd(/** @type {Spring} */(ease).ease);
  const staggerEase = hasSpring ? /** @type {Spring} */(ease).ease : hasEasing ? parseEasings(ease) : null;
  const grid = params.grid;
  const axis = params.axis;
  const fromFirst = isUnd(from) || from === 0 || from === 'first';
  const fromCenter = from === 'center';
  const fromLast = from === 'last';
  const isRange = isArr(val);
  const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);
  const val2 = isRange ? parseNumber(val[1]) : 0;
  const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);
  const start = params.start || 0 + (isRange ? val1 : 0);
  let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;
  return (_, i, t, tl) => {
    if (fromCenter) fromIndex = (t - 1) / 2;
    if (fromLast) fromIndex = t - 1;
    if (!values.length) {
      for (let index = 0; index < t; index++) {
        if (!grid) {
          values.push(abs(fromIndex - index));
        } else {
          const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          const toX = index % grid[0];
          const toY = floor(index / grid[0]);
          const distanceX = fromX - toX;
          const distanceY = fromY - toY;
          let value = sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') value = -distanceX;
          if (axis === 'y') value = -distanceY;
          values.push(value);
        }
        maxValue = max(...values);
      }
      if (staggerEase) values = values.map(val => staggerEase(val / maxValue) * maxValue);
      if (reversed) values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));
    }
    const spacing = isRange ? (val2 - val1) / maxValue : val1;
    const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */(start);
    /** @type {String|Number} */
    let output = offset + ((spacing * round(values[i], 2)) || 0);
    if (params.modifier) output = params.modifier(output);
    if (unitMatch) output = `${output}${unitMatch[2]}`;
    return output;
  }
}



================================================
FILE: src/svg.js
================================================
/// <reference path='./types.js' />

import {
  K,
  isSvgSymbol,
  morphPointsSymbol,
  proxyTargetSymbol,
} from './consts.js';

import {
  round,
  isSvg,
  atan2,
  PI,
  isFnc,
} from './helpers.js';

import {
  parseTargets
} from './targets.js';

/**
 * @param  {TargetsParam} path
 * @return {SVGGeometryElement|undefined}
 */
const getPath = path => {
  const parsedTargets = parseTargets(path);
  const $parsedSvg = /** @type {SVGGeometryElement} */(parsedTargets[0]);
  if (!$parsedSvg || !isSvg($parsedSvg)) return;
  return $parsedSvg;
}

/**
 * @param  {TargetsParam} path2
 * @param  {Number} [precision]
 * @return {FunctionValue}
 */
const morphTo = (path2, precision = .33) => ($path1) => {
  const $path2 = /** @type {SVGGeometryElement} */(getPath(path2));
  if (!$path2) return;
  const isPath = $path1.tagName === 'path';
  const separator = isPath ? ' ' : ',';
  const previousPoints = $path1[morphPointsSymbol];
  if (previousPoints) $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);

  let v1 = '', v2 = '';

  if (!precision) {
    v1 = $path1.getAttribute(isPath ? 'd' : 'points');
    v2 = $path2.getAttribute(isPath ? 'd' : 'points');
  } else {
    const length1 = /** @type {SVGGeometryElement} */($path1).getTotalLength();
    const length2 = $path2.getTotalLength();
    const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));
    for (let i = 0; i < maxPoints; i++) {
      const t = i / (maxPoints - 1);
      const pointOnPath1 = /** @type {SVGGeometryElement} */($path1).getPointAtLength(length1 * t);
      const pointOnPath2 = $path2.getPointAtLength(length2 * t);
      const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';
      v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';
      v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';
    }
  }

  $path1[morphPointsSymbol] = v2;

  return [v1, v2];
}

/**
 * @param {SVGGeometryElement} $el
 * @param {Number} start
 * @param {Number} end
 * @return {Proxy}
 */
function createDrawableProxy($el, start, end) {
  const strokeLineCap = getComputedStyle($el).strokeLinecap;
  const pathLength = K;
  let currentCap = strokeLineCap;
  const proxy = new Proxy($el, {
    get(target, property) {
      const value = target[property];
      if (property === proxyTargetSymbol) return target;
      if (property === 'setAttribute') {
        /** @param {any[]} args */
        return (...args) => {
          if (args[0] === 'draw') {
            const value = args[1];
            const values = value.split(' ');
            const v1 = +values[0];
            const v2 = +values[1];

            // TOTO: Benchmark if performing two slices is more performant than one split

            // const spaceIndex = value.indexOf(' ');
            // const v1 = round(+value.slice(0, spaceIndex), precision);
            // const v2 = round(+value.slice(spaceIndex + 1), precision);

            const os = v1 * -pathLength;
            const d1 = (v2 * pathLength) + os;
            // Prevents linecap to smear by offsetting the dasharray length by 0.01% when v2 is not at max
            const d2 = (pathLength + ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10) - d1);
            // Handle cases where the cap is still visible when the line is completly hidden
            if (strokeLineCap !== 'butt') {
              const newCap = v1 === v2 ? 'butt' : strokeLineCap;
              if (currentCap !== newCap) {
                target.setAttribute('stroke-linecap', `${newCap}`);
                currentCap = newCap;
              }
            }
            target.setAttribute('stroke-dashoffset', `${os}`);
            target.setAttribute('stroke-dasharray', `${d1} ${d2}`);
          }
          return Reflect.apply(value, target, args);
        };
      }
      if (isFnc(value)) {
        /** @param {any[]} args */
        return (...args) => Reflect.apply(value, target, args);
      } else {
        return value;
      }
    }
  });
  if ($el.getAttribute('pathLength') !== `${pathLength}`) {
    $el.setAttribute('pathLength', `${pathLength}`);
    proxy.setAttribute('draw', `${start} ${end}`);
  }
  return /** @type {typeof Proxy} */(/** @type {unknown} */(proxy));
}

/**
 * @param {TargetsParam} selector
 * @param {Number} [start=0]
 * @param {Number} [end=0]
 * @return {Array.<Proxy>}
 */
const createDrawable = (selector, start = 0, end = 0) => {
  const els = /** @type {Array.<Proxy>} */((/** @type {unknown} */(parseTargets(selector))));
  els.forEach(($el, i) => els[i] = createDrawableProxy(/** @type {SVGGeometryElement} */(/** @type {unknown} */($el)), start, end));
  return els;
};

// Motion path animation

/**
 * @param {SVGGeometryElement} $path
 * @param {Number} progress
 * @param {Number}lookup
 * @return {DOMPoint}
 */
const getPathPoint = ($path, progress, lookup = 0) => {
  return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);
}

/**
 * @param {SVGGeometryElement} $path
 * @param {String} pathProperty
 * @return {FunctionValue}
 */
const getPathProgess = ($path, pathProperty) => {
  return $el => {
    const totalLength = +($path.getTotalLength());
    const inSvg = $el[isSvgSymbol];
    const ctm = $path.getCTM();
    /** @type {TweenObjectValue} */
    return {
      from: 0,
      to: totalLength,
      /** @type {TweenModifier} */
      modifier: progress => {
        if (pathProperty === 'a') {
          const p0 = getPathPoint($path, progress, -1);
          const p1 = getPathPoint($path, progress, +1);
          return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;
        } else {
          const p = getPathPoint($path, progress, 0);
          return pathProperty === 'x' ?
            inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :
            inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f
        }
      }
    }
  }
}

/**
 * @param {TargetsParam} path
 */
const createMotionPath = path => {
  const $path = getPath(path);
  if (!$path) return;
  return {
    translateX: getPathProgess($path, 'x'),
    translateY: getPathProgess($path, 'y'),
    rotate: getPathProgess($path, 'a'),
  }
}

// Check for valid SVG attribute

const cssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];

/**
 * @param  {Target} el
 * @param  {String} propertyName
 * @return {Boolean}
 */
export const isValidSVGAttribute = (el, propertyName) => {
  // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform
  if (cssReservedProperties.includes(propertyName)) return false;
  if (el.getAttribute(propertyName) || propertyName in el) {
    if (propertyName === 'scale') { // Scale
      const elParentNode = /** @type {SVGGeometryElement} */(/** @type {DOMTarget} */(el).parentNode);
      // Only consider scale as a valid SVG attribute on filter element
      return elParentNode && elParentNode.tagName === 'filter';
    }
    return true;
  }
}

export const svg = {
  morphTo,
  createMotionPath,
  createDrawable,
}



================================================
FILE: src/targets.js
================================================
/// <reference path='./types.js' />

import {
  globals,
} from './globals.js';

import {
  isRegisteredTargetSymbol,
  isDomSymbol,
  isSvgSymbol,
  transformsSymbol,
  isBrowser,
} from './consts.js';

import {
  isSvg,
  isNil,
  isArr,
  isStr,
} from './helpers.js';

/**
 * @param  {DOMTargetsParam|TargetsParam} v
 * @return {NodeList|HTMLCollection}
 */
export function getNodeList(v) {
  const n = isStr(v) ? globals.root.querySelectorAll(v) : v;
  if (n instanceof NodeList || n instanceof HTMLCollection) return n;
}

/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
export function parseTargets(targets) {
  if (isNil(targets)) return /** @type {TargetsArray} */([]);
  if (isArr(targets)) {
    const flattened = targets.flat(Infinity);
    /** @type {TargetsArray} */
    const parsed = [];
    for (let i = 0, l = flattened.length; i < l; i++) {
      const item = flattened[i];
      if (!isNil(item)) {
        const nodeList = getNodeList(item);
        if (nodeList) {
          for (let j = 0, jl = nodeList.length; j < jl; j++) {
            const subItem = nodeList[j];
            if (!isNil(subItem)) {
              let isDuplicate = false;
              for (let k = 0, kl = parsed.length; k < kl; k++) {
                if (parsed[k] === subItem) {
                  isDuplicate = true;
                  break;
                }
              }
              if (!isDuplicate) {
                parsed.push(subItem);
              }
            }
          }
        } else {
          let isDuplicate = false;
          for (let j = 0, jl = parsed.length; j < jl; j++) {
            if (parsed[j] === item) {
              isDuplicate = true;
              break;
            }
          }
          if (!isDuplicate) {
            parsed.push(item);
          }
        }
      }
    }
    return parsed;
  }
  if (!isBrowser) return /** @type {JSTargetsArray} */([targets]);
  const nodeList = getNodeList(targets);
  if (nodeList) return /** @type {DOMTargetsArray} */(Array.from(nodeList));
  return /** @type {TargetsArray} */([targets]);
}

/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
export function registerTargets(targets) {
  const parsedTargetsArray = parseTargets(targets);
  const parsedTargetsLength = parsedTargetsArray.length;
  if (parsedTargetsLength) {
    for (let i = 0; i < parsedTargetsLength; i++) {
      const target = parsedTargetsArray[i];
      if (!target[isRegisteredTargetSymbol]) {
        target[isRegisteredTargetSymbol] = true;
        const isSvgType = isSvg(target);
        const isDom = /** @type {DOMTarget} */(target).nodeType || isSvgType;
        if (isDom) {
          target[isDomSymbol] = true;
          target[isSvgSymbol] = isSvgType;
          target[transformsSymbol] = {};
        }
      }
    }
  }
  return parsedTargetsArray;
}



================================================
FILE: src/timeline.js
================================================
/// <reference path='./types.js' />

import {
  globals,
} from './globals.js';

import {
  relativeValuesExecRgx,
  minValue,
  tickModes,
  compositionTypes,
} from './consts.js';

import {
  isObj,
  isFnc,
  isUnd,
  isNil,
  isNum,
  addChild,
  forEachChildren,
  stringStartsWith,
  mergeObjects,
  clampInfinity,
  clampZero,
  isStr,
} from './helpers.js';

import {
  getRelativeValue, setValue,
} from './values.js';

import {
  parseTargets,
} from './targets.js';

import {
  Timer,
} from './timer.js';

import {
  JSAnimation,
  cleanInlineStyles,
} from './animation.js';

import {
  tick,
} from './render.js';

import {
  parseEasings,
} from './eases.js';

import {
  remove,
} from './utils.js';

/**
 * @typedef {Number|String|Function} TimePosition
 */

/**
 * Timeline's children offsets positions parser
 * @param  {Timeline} timeline
 * @param  {String} timePosition
 * @return {Number}
 */
const getPrevChildOffset = (timeline, timePosition) => {
  if (stringStartsWith(timePosition, '<')) {
    const goToPrevAnimationOffset = timePosition[1] === '<';
    const prevAnimation = /** @type {Tickable} */(timeline._tail);
    const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;
    return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;
  }
}

/**
 * @param  {Timeline} timeline
 * @param  {TimePosition} [timePosition]
 * @return {Number}
 */
export const parseTimelinePosition = (timeline, timePosition) => {
  let tlDuration = timeline.iterationDuration;
  if (tlDuration === minValue) tlDuration = 0;
  if (isUnd(timePosition)) return tlDuration;
  if (isNum(+timePosition)) return +timePosition;
  const timePosStr = /** @type {String} */(timePosition);
  const tlLabels = timeline ? timeline.labels : null;
  const hasLabels = !isNil(tlLabels);
  const prevOffset = getPrevChildOffset(timeline, timePosStr);
  const hasSibling = !isUnd(prevOffset);
  const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);
  if (matchedRelativeOperator) {
    const fullOperator = matchedRelativeOperator[0];
    const split = timePosStr.split(fullOperator);
    const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;
    const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;
    const parsedNumericalOffset = +split[1];
    return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);
  } else {
    return hasSibling ? prevOffset :
           hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :
           tlDuration : tlDuration;
  }
}

/**
 * @param {Timeline} tl
 * @return {Number}
 */
function getTimelineTotalDuration(tl) {
  return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;
}

/**
 * @overload
 * @param  {TimerParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @return {Timeline}
 *
 * @overload
 * @param  {AnimationParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @param  {TargetsParam} targets
 * @param  {Number} [index]
 * @param  {Number} [length]
 * @return {Timeline}
 *
 * @param  {TimerParams|AnimationParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @param  {TargetsParam} [targets]
 * @param  {Number} [index]
 * @param  {Number} [length]
 */
function addTlChild(childParams, tl, timePosition, targets, index, length) {
  const isSetter = isNum(childParams.duration) && /** @type {Number} */(childParams.duration) <= minValue;
  // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position
  const adjustedPosition = isSetter ? timePosition - minValue : timePosition;
  tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);
  const tlChild = targets ?
    new JSAnimation(targets,/** @type {AnimationParams} */(childParams), tl, adjustedPosition, false, index, length) :
    new Timer(/** @type {TimerParams} */(childParams), tl, adjustedPosition);
  tlChild.init(1);
  // TODO: Might be better to insert at a position relative to startTime?
  addChild(tl, tlChild);
  forEachChildren(tl, (/** @type {Renderable} */child) => {
    const childTLOffset = child._offset + child._delay;
    const childDur = childTLOffset + child.duration;
    if (childDur > tl.iterationDuration) tl.iterationDuration = childDur;
  });
  tl.duration = getTimelineTotalDuration(tl);
  return tl;
}

export class Timeline extends Timer {

  /**
   * @param {TimelineParams} [parameters]
   */
  constructor(parameters = {}) {
    super(/** @type {TimerParams&TimelineParams} */(parameters), null, 0);
    /** @type {Number} */
    this.duration = 0; // TL duration starts at 0 and grows when adding children
    /** @type {Record<String, Number>} */
    this.labels = {};
    const defaultsParams = parameters.defaults;
    const globalDefaults = globals.defaults;
    /** @type {DefaultsParams} */
    this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;
    /** @type {Callback<this>} */
    this.onRender = parameters.onRender || globalDefaults.onRender;
    const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);
    this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;
    /** @type {Number} */
    this.iterationDuration = 0;
  }

  /**
   * @overload
   * @param {TargetsParam} a1
   * @param {AnimationParams} a2
   * @param {TimePosition} [a3]
   * @return {this}
   *
   * @overload
   * @param {TimerParams} a1
   * @param {TimePosition} [a2]
   * @return {this}
   *
   * @param {TargetsParam|TimerParams} a1
   * @param {AnimationParams|TimePosition} a2
   * @param {TimePosition} [a3]
   */
  add(a1, a2, a3) {
    const isAnim = isObj(a2);
    const isTimer = isObj(a1);
    if (isAnim || isTimer) {
      this._hasChildren = true;
      if (isAnim) {
        const childParams = /** @type {AnimationParams} */(a2);
        // Check for function for children stagger positions
        if (isFnc(a3)) {
          const staggeredPosition = /** @type {Function} */(a3);
          const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */(a1));
          // Store initial duration before adding new children that will change the duration
          const tlDuration = this.duration;
          // Store initial _iterationDuration before adding new children that will change the duration
          const tlIterationDuration = this.iterationDuration;
          // Store the original id in order to add specific indexes to the new animations ids
          const id = childParams.id;
          let i = 0;
          const parsedLength = parsedTargetsArray.length;
          parsedTargetsArray.forEach((/** @type {Target} */target) => {
            // Create a new parameter object for each staggered children
            const staggeredChildParams = { ...childParams };
            // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation
            this.duration = tlDuration;
            this.iterationDuration = tlIterationDuration;
            if (!isUnd(id)) staggeredChildParams.id = id + '-' + i;
            addTlChild(
              staggeredChildParams,
              this,
              staggeredPosition(target, i, parsedLength, this),
              target,
              i,
              parsedLength
            );
            i++;
          });
        } else {
          addTlChild(
            childParams,
            this,
            parseTimelinePosition(this, a3),
            /** @type {TargetsParam} */(a1),
          );
        }
      } else {
        // It's a Timer
        addTlChild(
          /** @type TimerParams */(a1),
          this,
          parseTimelinePosition(this,/** @type TimePosition */(a2)),
        );
      }
      return this.init(1); // 1 = internalRender
    }
  }

  /**
   * @overload
   * @param {Tickable} [synced]
   * @param {TimePosition} [position]
   * @return {this}
   *
   * @overload
   * @param {globalThis.Animation} [synced]
   * @param {TimePosition} [position]
   * @return {this}
   *
   * @overload
   * @param {WAAPIAnimation} [synced]
   * @param {TimePosition} [position]
   * @return {this}
   *
   * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]
   * @param {TimePosition} [position]
   */
  sync(synced, position) {
    if (isUnd(synced) || synced && isUnd(synced.pause)) return this;
    synced.pause();
    const duration = +(/** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */(synced).effect.getTiming().duration : /** @type {Tickable} */(synced).duration);
    return this.add(synced, { currentTime: [0, duration], duration, ease: 'linear' }, position);
  }

  /**
   * @param  {TargetsParam} targets
   * @param  {AnimationParams} parameters
   * @param  {TimePosition} [position]
   * @return {this}
   */
  set(targets, parameters, position) {
    if (isUnd(parameters)) return this;
    parameters.duration = minValue;
    parameters.composition = compositionTypes.replace;
    return this.add(targets, parameters, position);
  }

  /**
   * @param {Callback<Timer>} callback
   * @param {TimePosition} [position]
   * @return {this}
   */
  call(callback, position) {
    if (isUnd(callback) || callback && !isFnc(callback)) return this;
    return this.add({ duration: 0, onComplete: () => callback(this) }, position);
  }

  /**
   * @param {String} labelName
   * @param {TimePosition} [position]
   * @return {this}
   *
   */
  label(labelName, position) {
    if (isUnd(labelName) || labelName && !isStr(labelName)) return this;
    this.labels[labelName] = parseTimelinePosition(this,/** @type TimePosition */(position));
    return this;
  }

  /**
   * @param  {TargetsParam} targets
   * @param  {String} [propertyName]
   * @return {this}
   */
  remove(targets, propertyName) {
    remove(targets, this, propertyName);
    return this;
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === clampZero(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    const labels = this.labels;
    forEachChildren(this, (/** @type {JSAnimation} */child) => {
      child.stretch(child.duration * timeScale);
    });
    for (let labelName in labels) {
      labels[labelName] *= timeScale;
    }
    return super.stretch(newDuration);
  }

  /**
   * @return {this}
   */
  refresh() {
    forEachChildren(this, (/** @type {JSAnimation} */child) => {
      if (child.refresh) child.refresh();
    });
    return this;
  }

  /**
   * @return {this}
   */
  revert() {
    super.revert();
    forEachChildren(this, (/** @type {JSAnimation} */child) => child.revert, true);
    return cleanInlineStyles(this);
  }

  /**
   * @param  {Callback<this>} [callback]
   * @return {Promise}
   */
  then(callback) {
    return super.then(callback);
  }
}

/**
 * @param {TimelineParams} [parameters]
 * @return {Timeline}
 */
export const createTimeline = parameters => new Timeline(parameters).init();


================================================
FILE: src/timer.js
================================================
/// <reference path='./types.js' />

import {
  minValue,
  compositionTypes,
  tickModes,
  noop,
  maxValue,
} from './consts.js';

import {
  now,
  isUnd,
  addChild,
  forEachChildren,
  clampInfinity,
  round,
  clampZero,
  isFnc,
  clamp,
  floor,
} from './helpers.js';

import {
  globals,
} from './globals.js';

import {
  setValue,
} from './values.js';

import {
  tick,
} from './render.js';

import {
  composeTween,
  getTweenSiblings,
  removeTweenSliblings,
} from './compositions.js';

import {
  engine,
} from './engine.js';

import {
  Clock,
} from './clock.js';

/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const resetTimerProperties = timer => {
  timer.paused = true;
  timer.began = false;
  timer.completed = false;
  return timer;
}

/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const reviveTimer = timer => {
  if (!timer._cancelled) return timer;
  if (timer._hasChildren) {
    forEachChildren(timer, reviveTimer);
  } else {
    forEachChildren(timer, (/** @type {Tween} tween*/tween) => {
      if (tween._composition !== compositionTypes.none) {
        composeTween(tween, getTweenSiblings(tween.target, tween.property));
      }
    });
  }
  timer._cancelled = 0;
  return timer;
}

let timerId = 0;

/**
 * Base class used to create Timers, Animations and Timelines
 */
export class Timer extends Clock {
  /**
   * @param {TimerParams} [parameters]
   * @param {Timeline} [parent]
   * @param {Number} [parentPosition]
   */
  constructor(parameters = {}, parent = null, parentPosition = 0) {

    super(0);

    const {
      id,
      delay,
      duration,
      reversed,
      alternate,
      loop,
      loopDelay,
      autoplay,
      frameRate,
      playbackRate,
      onComplete,
      onLoop,
      onPause,
      onBegin,
      onBeforeUpdate,
      onUpdate,
    } = parameters;

    if (globals.scope) globals.scope.revertibles.push(this);

    const timerInitTime = parent ? 0 : engine._elapsedTime;
    const timerDefaults = parent ? parent.defaults : globals.defaults;
    const timerDelay = /** @type {Number} */(isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);
    const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;
    const timerLoop = setValue(loop, timerDefaults.loop);
    const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);
    const timerIterationCount = timerLoop === true ||
                                timerLoop === Infinity ||
                                /** @type {Number} */(timerLoop) < 0 ? Infinity :
                                /** @type {Number} */(timerLoop) + 1;

    let offsetPosition = 0;

    if (parent) {
      offsetPosition = parentPosition;
    } else {
      let startTime = now();
      // Make sure to tick the engine once if suspended to avoid big gaps with the following offsetPosition calculation
      if (engine.paused) {
        engine.requestTick(startTime);
        startTime = engine._elapsedTime;
      }
      offsetPosition = startTime - engine._startTime;
    }

    // Timer's parameters
    this.id = !isUnd(id) ? id : ++timerId;
    /** @type {Timeline} */
    this.parent = parent;
    // Total duration of the timer
    this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;
    /** @type {Boolean} */
    this.backwards = false;
    /** @type {Boolean} */
    this.paused = true;
    /** @type {Boolean} */
    this.began = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Callback<this>} */
    this.onBegin = onBegin || timerDefaults.onBegin;
    /** @type {Callback<this>} */
    this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
    /** @type {Callback<this>} */
    this.onUpdate = onUpdate || timerDefaults.onUpdate;
    /** @type {Callback<this>} */
    this.onLoop = onLoop || timerDefaults.onLoop;
    /** @type {Callback<this>} */
    this.onPause = onPause || timerDefaults.onPause;
    /** @type {Callback<this>} */
    this.onComplete = onComplete || timerDefaults.onComplete;
    /** @type {Number} */
    this.iterationDuration = timerDuration; // Duration of one loop
    /** @type {Number} */
    this.iterationCount = timerIterationCount; // Number of loops
    /** @type {Boolean|ScrollObserver} */
    this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);
    /** @type {Number} */
    this._offset = offsetPosition;
    /** @type {Number} */
    this._delay = timerDelay;
    /** @type {Number} */
    this._loopDelay = timerLoopDelay;
    /** @type {Number} */
    this._iterationTime = 0;
    /** @type {Number} */
    this._currentIteration = 0; // Current loop index
    /** @type {Function} */
    this._resolve = noop; // Used by .then()
    /** @type {Boolean} */
    this._running = false;
    /** @type {Number} */
    this._reversed = +setValue(reversed, timerDefaults.reversed);
    /** @type {Number} */
    this._reverse = this._reversed;
    /** @type {Number} */
    this._cancelled = 0;
    /** @type {Boolean} */
    this._alternate = setValue(alternate, timerDefaults.alternate);
    /** @type {Renderable} */
    this._prev = null;
    /** @type {Renderable} */
    this._next = null;

    // Clock's parameters
    /** @type {Number} */
    this._elapsedTime = timerInitTime;
    /** @type {Number} */
    this._startTime = timerInitTime;
    /** @type {Number} */
    this._lastTime = timerInitTime;
    /** @type {Number} */
    this._fps = setValue(frameRate, timerDefaults.frameRate);
    /** @type {Number} */
    this._speed = setValue(playbackRate, timerDefaults.playbackRate);
  }

  get cancelled() {
    return !!this._cancelled;
  }

  /** @param {Boolean} cancelled  */
  set cancelled(cancelled) {
    cancelled ? this.cancel() : this.reset(1).play();
  }

  get currentTime() {
    return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);
  }

  /** @param {Number} time  */
  set currentTime(time) {
    const paused = this.paused;
    // Pausing the timer is necessary to avoid time jumps on a running instance
    this.pause().seek(+time);
    if (!paused) this.resume();
  }

  get iterationCurrentTime() {
    return round(this._iterationTime, globals.precision);
  }

  /** @param {Number} time  */
  set iterationCurrentTime(time) {
    this.currentTime = (this.iterationDuration * this._currentIteration) + time;
  }

  get progress() {
    return clamp(round(this._currentTime / this.duration, 5), 0, 1);
  }

  /** @param {Number} progress  */
  set progress(progress) {
    this.currentTime = this.duration * progress;
  }

  get iterationProgress() {
    return clamp(round(this._iterationTime / this.iterationDuration, 5), 0, 1);
  }

  /** @param {Number} progress  */
  set iterationProgress(progress) {
    const iterationDuration = this.iterationDuration;
    this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);
  }

  get currentIteration() {
    return this._currentIteration;
  }

  /** @param {Number} iterationCount  */
  set currentIteration(iterationCount) {
    this.currentTime = (this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1));
  }

  get reversed() {
    return !!this._reversed;
  }

  /** @param {Boolean} reverse  */
  set reversed(reverse) {
    reverse ? this.reverse() : this.play();
  }

  get speed() {
    return super.speed;
  }

  /** @param {Number} playbackRate  */
  set speed(playbackRate) {
    super.speed = playbackRate;
    this.resetTime();
  }

  /**
   * @param  {Number} internalRender
   * @return {this}
   */
  reset(internalRender = 0) {
    // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings
    reviveTimer(this);
    if (this._reversed && !this._reverse) this.reversed = false;
    // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden
    // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order
    // NOTE: This is only required for Timelines and might be better to move to the Timeline class?
    this._iterationTime = this.iterationDuration;
    // Set tickMode to tickModes.FORCE to force rendering
    tick(this, 0, 1, internalRender, tickModes.FORCE);
    // Reset timer properties after revive / render to make sure the props are not updated again
    resetTimerProperties(this);
    // Also reset children properties
    if (this._hasChildren) {
      forEachChildren(this, resetTimerProperties);
    }
    return this;
  }

  /**
   * @param  {Number} internalRender
   * @return {this}
   */
  init(internalRender = 0) {
    this.fps = this._fps;
    this.speed = this._speed;
    // Manually calling .init() on timelines should render all children intial state
    // Forces all children to render once then render to 0 when reseted
    if (!internalRender && this._hasChildren) {
      tick(this, this.duration, 1, internalRender, tickModes.FORCE);
    }
    this.reset(internalRender);
    // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link
    const autoplay = this._autoplay;
    if (autoplay === true) {
      this.resume();
    } else if (autoplay && !isUnd(/** @type {ScrollObserver} */(autoplay).linked)) {
      /** @type {ScrollObserver} */(autoplay).link(this);
    }
    return this;
  }

  /** @return {this} */
  resetTime() {
    const timeScale = 1 / (this._speed * engine._speed);
    this._startTime = now() - (this._currentTime + this._delay) * timeScale;
    return this;
  }

  /** @return {this} */
  pause() {
    if (this.paused) return this;
    this.paused = true;
    this.onPause(this);
    return this;
  }

  /** @return {this} */
  resume() {
    if (!this.paused) return this;
    this.paused = false;
    // We can safely imediatly render a timer that has no duration and no children
    if (this.duration <= minValue && !this._hasChildren) {
      tick(this, minValue, 0, 0, tickModes.FORCE);
    } else {
      if (!this._running) {
        addChild(engine, this);
        engine._hasChildren = true;
        this._running = true;
      }
      this.resetTime();
      // Forces the timer to advance by at least one frame when the next tick occurs
      this._startTime -= 12;
      engine.wake();
    }
    return this;
  }

  /** @return {this} */
  restart() {
    return this.reset(0).resume();
  }

  /**
   * @param  {Number} time
   * @param  {Boolean|Number} [muteCallbacks]
   * @param  {Boolean|Number} [internalRender]
   * @return {this}
   */
  seek(time, muteCallbacks = 0, internalRender = 0) {
    // Recompose the tween siblings in case the timer has been cancelled
    reviveTimer(this);
    // If you seek a completed animation, otherwise the next play will starts at 0
    this.completed = false;
    const isPaused = this.paused;
    this.paused = true;
    // timer, time, muteCallbacks, internalRender, tickMode
    tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);
    return isPaused ? this : this.resume();
  }

  /** @return {this} */
  alternate() {
    const reversed = this._reversed;
    const count = this.iterationCount;
    const duration = this.iterationDuration;
    // Calculate the maximum iterations possible given the iteration duration
    const iterations = count === Infinity ? floor(maxValue / duration) : count;
    this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
    if (count === Infinity) {
      // Handle infinite loops to loop on themself
      this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
    } else {
      this.seek((duration * iterations) - this._currentTime);
    }
    this.resetTime();
    return this;
  }

  /** @return {this} */
  play() {
    if (this._reversed) this.alternate();
    return this.resume();
  }

  /** @return {this} */
  reverse() {
    if (!this._reversed) this.alternate();
    return this.resume();
  }

  // TODO: Move all the animation / tweens / children related code to Animation / Timeline

  /** @return {this} */
  cancel() {
    if (this._hasChildren) {
      forEachChildren(this, (/** @type {Renderable} */child) => child.cancel(), true);
    } else {
      forEachChildren(this, removeTweenSliblings);
    }
    this._cancelled = 1;
    // Pausing the timer removes it from the engine
    return this.pause();
  }

  /**
   * @param  {Number} newDuration
   * @return {this}
   */
  stretch(newDuration) {
    const currentDuration = this.duration;
    if (currentDuration === clampZero(newDuration)) return this;
    const timeScale = newDuration / currentDuration;
    const isSetter = newDuration <= minValue;
    this.duration = isSetter ? minValue : clampZero(clampInfinity(round(currentDuration * timeScale, 12)));
    this.iterationDuration = isSetter ? minValue : clampZero(clampInfinity(round(this.iterationDuration * timeScale, 12)));
    this._offset *= timeScale;
    this._delay *= timeScale;
    this._loopDelay *= timeScale;
    return this;
  }

 /**
   * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
   * @return {this}
   */
  revert() {
    tick(this, 0, 1, 0, tickModes.AUTO);
    const ap = /** @type {ScrollObserver} */(this._autoplay);
    if (ap && ap.linked && ap.linked === this) ap.revert();
    return this.cancel();
  }

 /**
   * Imediatly completes the timer, cancels it and triggers the onComplete callback
   * @return {this}
   */
  complete() {
    return this.seek(this.duration).cancel();
  }

  /**
   * @param  {Callback<this>} [callback]
   * @return {Promise}
   */
  then(callback = noop) {
    const then = this.then;
    const onResolve = () => {
      // this.then = null prevents infinite recursion if returned by an async function
      // https://github.com/juliangarnierorg/anime-beta/issues/26
      this.then = null;
      callback(this);
      this.then = then;
      this._resolve = noop;
    }
    return new Promise(r => {
      this._resolve = () => r(onResolve());
      // Make sure to resolve imediatly if the timer has already completed
      if (this.completed) this._resolve();
      return this;
    });
  }

}


/**
 * @param {TimerParams} [parameters]
 * @return {Timer}
 */
export const createTimer = parameters => new Timer(parameters, null, 0).init();


================================================
FILE: src/transforms.js
================================================
/// <reference path='./types.js' />

import {
  transformsExecRgx,
  transformsSymbol,
} from './consts.js';

import {
  isUnd,
  stringStartsWith,
} from './helpers.js';

/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
export const parseInlineTransforms = (target, propName, animationInlineStyles) => {
  const inlineTransforms = target.style.transform;
  let inlinedStylesPropertyValue;
  if (inlineTransforms) {
    const cachedTransforms = target[transformsSymbol];
    let t; while (t = transformsExecRgx.exec(inlineTransforms)) {
      const inlinePropertyName = t[1];
      // const inlinePropertyValue = t[2];
      const inlinePropertyValue = t[2].slice(1, -1);
      cachedTransforms[inlinePropertyName] = inlinePropertyValue;
      if (inlinePropertyName === propName) {
        inlinedStylesPropertyValue = inlinePropertyValue;
        // Store the new parsed inline styles if animationInlineStyles is provided
        if (animationInlineStyles) {
          animationInlineStyles[propName] = inlinePropertyValue;
        }
      }
    }
  }
  return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :
    stringStartsWith(propName, 'scale') ? '1' :
    stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';
}



================================================
FILE: src/types.js
================================================
/* #__PURE__ */

/* Private */

/** @typedef {import('./animation.js').JSAnimation} JSAnimation */
/** @typedef {import('./waapi.js').WAAPIAnimation} WAAPIAnimation */
/** @typedef {import('./timer.js').Timer} Timer */
/** @typedef {import('./timeline.js').Timeline} Timeline */
/** @typedef {import('./draggable.js').Draggable} Draggable */
/** @typedef {import('./scroll.js').ScrollObserver} ScrollObserver */
/** @typedef {import('./scope.js').Scope} Scope */
/** @typedef {import('./spring.js').Spring} Spring */

/* Exports */

/**
 * @typedef {Object} DefaultsParams
 * @property {number|string} [id]
 * @property {PercentageKeyframes|DurationKeyframes} [keyframes]
 * @property {EasingParam} [playbackEase]
 * @property {number} [playbackRate]
 * @property {number} [frameRate]
 * @property {number|boolean} [loop]
 * @property {boolean} [reversed]
 * @property {boolean} [alternate]
 * @property {boolean|ScrollObserver} [autoplay]
 * @property {number|FunctionValue} [duration]
 * @property {number|FunctionValue} [delay]
 * @property {number} [loopDelay]
 * @property {EasingParam} [ease]
 * @property {'none'|'replace'|'blend'|import('./consts.js').compositionTypes} [composition]
 * @property {(v: any) => any} [modifier]
 * @property {(tickable: Tickable) => void} [onBegin]
 * @property {(tickable: Tickable) => void} [onBeforeUpdate]
 * @property {(tickable: Tickable) => void} [onUpdate]
 * @property {(tickable: Tickable) => void} [onLoop]
 * @property {(tickable: Tickable) => void} [onPause]
 * @property {(tickable: Tickable) => void} [onComplete]
 * @property {(renderable: Renderable) => void} [onRender]
 */

/** @typedef {JSAnimation|Timeline} Renderable */
/** @typedef {Timer|Renderable} Tickable */
/** @typedef {Timer&JSAnimation&Timeline} CallbackArgument */
/** @typedef {import('./animatable.js').Animatable|Tickable|Draggable|ScrollObserver|Scope} Revertible */

/**
 * @callback EasingFunction
 * @param {Number} time
 * @return {Number}
 */

/**
 * @typedef {('linear'|'linear(x1, x2 25%, x3)'|'in'|'out'|'inOut'|'inQuad'|'outQuad'|'inOutQuad'|'inCubic'|'outCubic'|'inOutCubic'|'inQuart'|'outQuart'|'inOutQuart'|'inQuint'|'outQuint'|'inOutQuint'|'inSine'|'outSine'|'inOutSine'|'inCirc'|'outCirc'|'inOutCirc'|'inExpo'|'outExpo'|'inOutExpo'|'inBounce'|'outBounce'|'inOutBounce'|'inBack'|'outBack'|'inOutBack'|'inElastic'|'outElastic'|'inOutElastic'|'irregular'|'cubicBezier'|'steps'|'in(p = 1.675)'|'out(p = 1.675)'|'inOut(p = 1.675)'|'inBack(overshoot = 1.70158)'|'outBack(overshoot = 1.70158)'|'inOutBack(overshoot = 1.70158)'|'inElastic(amplitude = 1, period = .3)'|'outElastic(amplitude = 1, period = .3)'|'inOutElastic(amplitude = 1, period = .3)'|'irregular(length = 10, randomness = 1)'|'cubicBezier(x1, y1, x2, y2)'|'steps(steps = 10)')} EaseStringParamNames
 */

// A hack to get both ease names suggestions AND allow any strings
// https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421
/** @typedef {(String & {})|EaseStringParamNames|EasingFunction|Spring} EasingParam */

/** @typedef {HTMLElement|SVGElement} DOMTarget */
/** @typedef {Record<String, any>} JSTarget */
/** @typedef {DOMTarget|JSTarget} Target */
/** @typedef {Target|NodeList|String} TargetSelector */
/** @typedef {DOMTarget|NodeList|String} DOMTargetSelector */
/** @typedef {Array.<DOMTargetSelector>|DOMTargetSelector} DOMTargetsParam */
/** @typedef {Array.<DOMTarget>} DOMTargetsArray */
/** @typedef {Array.<JSTarget>|JSTarget} JSTargetsParam */
/** @typedef {Array.<JSTarget>} JSTargetsArray */
/** @typedef {Array.<TargetSelector>|TargetSelector} TargetsParam */
/** @typedef {Array.<Target>} TargetsArray */

/**
 * @callback FunctionValue
 * @param {Target} target - The animated target
 * @param {Number} index - The target index
 * @param {Number} length - The total number of animated targets
 * @return {Number|String|TweenObjectValue|Array.<Number|String|TweenObjectValue>}
 */

/**
 * @callback TweenModifier
 * @param {Number} value - The animated value
 * @return {Number|String}
 */

/** @typedef {[Number, Number, Number, Number]} ColorArray */

/**
 * @template T
 * @callback Callback
 * @param {T} self - Returns itself
 * @param {PointerEvent} [e]
 * @return {*}
 */

/**
 * @template {object} T
 * @typedef {Object} TickableCallbacks
 * @property {Callback<T>} [onBegin]
 * @property {Callback<T>} [onBeforeUpdate]
 * @property {Callback<T>} [onUpdate]
 * @property {Callback<T>} [onLoop]
 * @property {Callback<T>} [onPause]
 * @property {Callback<T>} [onComplete]
 */

/**
 * @template {object} T
 * @typedef {Object} RenderableCallbacks
 * @property {Callback<T>} [onRender]
 */

/**
 * @typedef {Object} Tween
 * @property {Number} id
 * @property {JSAnimation} parent
 * @property {String} property
 * @property {Target} target
 * @property {String|Number} _value
 * @property {Function|null} _func
 * @property {EasingFunction} _ease
 * @property {Array.<Number>} _fromNumbers
 * @property {Array.<Number>} _toNumbers
 * @property {Array.<String>} _strings
 * @property {Number} _fromNumber
 * @property {Number} _toNumber
 * @property {Array.<Number>} _numbers
 * @property {Number} _number
 * @property {String} _unit
 * @property {TweenModifier} _modifier
 * @property {Number} _currentTime
 * @property {Number} _delay
 * @property {Number} _updateDuration
 * @property {Number} _startTime
 * @property {Number} _changeDuration
 * @property {Number} _absoluteStartTime
 * @property {import('./consts.js').tweenTypes} _tweenType
 * @property {import('./consts.js').valueTypes} _valueType
 * @property {Number} _composition
 * @property {Number} _isOverlapped
 * @property {Number} _isOverridden
 * @property {Number} _renderTransforms
 * @property {Tween} _prevRep
 * @property {Tween} _nextRep
 * @property {Tween} _prevAdd
 * @property {Tween} _nextAdd
 * @property {Tween} _prev
 * @property {Tween} _next
 */

/**
 * @typedef TweenDecomposedValue
 * @property {Number} t - Type
 * @property {Number} n - Single number value
 * @property {String} u - Value unit
 * @property {String} o - Value operator
 * @property {Array.<Number>} d - Array of Numbers (in case of complex value type)
 * @property {Array.<String>} s - Strings (in case of complex value type)
 */

/** @typedef {{_head: null|Tween, _tail: null|Tween}} TweenPropertySiblings */
/** @typedef {Record<String, TweenPropertySiblings>} TweenLookups */
/** @typedef {WeakMap.<Target, TweenLookups>} TweenReplaceLookups */
/** @typedef {Map.<Target, TweenLookups>} TweenAdditiveLookups */

/**
 * @typedef {Object} TimerOptions
 * @property {Number|String} [id]
 * @property {TweenParamValue} [duration]
 * @property {TweenParamValue} [delay]
 * @property {Number} [loopDelay]
 * @property {Boolean} [reversed]
 * @property {Boolean} [alternate]
 * @property {Boolean|Number} [loop]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number} [frameRate]
 * @property {Number} [playbackRate]
 */

/**

/**
 * @typedef {TimerOptions & TickableCallbacks<Timer>} TimerParams
 */

/**
 * @typedef {Number|String|FunctionValue} TweenParamValue
 */

/**
 * @typedef {TweenParamValue|[TweenParamValue, TweenParamValue]} TweenPropValue
 */

/**
 * @typedef {(String & {})|'none'|'replace'|'blend'|import('./consts.js').compositionTypes} TweenComposition
 */

/**
 * @typedef {Object} TweenParamsOptions
 * @property {TweenParamValue} [duration]
 * @property {TweenParamValue} [delay]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 */

/**
 * @typedef {Object} TweenValues
 * @property {TweenParamValue} [from]
 * @property {TweenPropValue} [to]
 * @property {TweenPropValue} [fromTo]
 */

/**
 * @typedef {TweenParamsOptions & TweenValues} TweenKeyValue
 */

/**
 * @typedef {Array.<TweenKeyValue|TweenPropValue>} ArraySyntaxValue
 */

/**
 * @typedef {TweenParamValue|ArraySyntaxValue|TweenKeyValue} TweenOptions
 */

/**
 * @typedef {Partial<{to: TweenParamValue|Array.<TweenParamValue>; from: TweenParamValue|Array.<TweenParamValue>; fromTo: TweenParamValue|Array.<TweenParamValue>;}>} TweenObjectValue
 */

/**
 * @typedef {Object} PercentageKeyframeOptions
 * @property {EasingParam} [ease]
 */

/**
 * @typedef {Record<String, TweenParamValue>} PercentageKeyframeParams
 */

/**
 * @typedef {Record<String, PercentageKeyframeParams & PercentageKeyframeOptions>} PercentageKeyframes
 */

/**
 * @typedef {Array<Record<String, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>} DurationKeyframes
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {PercentageKeyframes|DurationKeyframes} [keyframes]
 * @property {EasingParam} [playbackEase]
 */

// TODO: Currently setting TweenModifier to the intersected Record<> makes the FunctionValue type target param any if only one parameter is set
/**
 * @typedef {Record<String, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | DurationKeyframes | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>} AnimationParams
 */

/**
 * @typedef {Object} TimelineOptions
 * @property {DefaultsParams} [defaults]
 * @property {EasingParam} [playbackEase]
 */

/**
 * @typedef {TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>} TimelineParams
 */

/**
 * @callback AnimatablePropertySetter
 * @param  {Number|Array.<Number>} to
 * @param  {Number} [duration]
 * @param  {EasingParam} [ease]
 * @return {AnimatableObject}
 */

/**
 * @callback AnimatablePropertyGetter
 * @return {Number|Array.<Number>}
 */

/**
 * @typedef {AnimatablePropertySetter & AnimatablePropertyGetter} AnimatableProperty
 */

/**
 * @typedef {import('./animatable.js').Animatable & Record<String, AnimatableProperty>} AnimatableObject
 */

/**
 * @typedef {Object} AnimatablePropertyParamsOptions
 * @property {String} [unit]
 * @property {TweenParamValue} [duration]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 */

/**
 * @typedef {Record<String, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions} AnimatableParams
 */



================================================
FILE: src/units.js
================================================
/// <reference path='./types.js' />

import {
  doc,
  valueTypes,
} from './consts.js';

import {
  isUnd,
  PI
} from './helpers.js';

const angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };
const convertedValuesCache = {};

/**
 * @param  {DOMTarget} el
 * @param  {TweenDecomposedValue} decomposedValue
 * @param  {String} unit
 * @param  {Boolean} [force]
 * @return {TweenDecomposedValue}
 */
export const convertValueUnit = (el, decomposedValue, unit, force = false) => {
  const currentUnit = decomposedValue.u;
  const currentNumber = decomposedValue.n;
  if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary
    return decomposedValue;
  }
  const cachedKey = currentNumber + currentUnit + unit;
  const cached = convertedValuesCache[cachedKey];
  if (!isUnd(cached) && !force) {
    decomposedValue.n = cached;
  } else {
    let convertedValue;
    if (currentUnit in angleUnitsMap) {
      convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
    } else {
      const baseline = 100;
      const tempEl = /** @type {DOMTarget} */(el.cloneNode());
      const parentNode = el.parentNode;
      const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;
      parentEl.appendChild(tempEl);
      const elStyle = tempEl.style;
      elStyle.width = baseline + currentUnit;
      const currentUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
      elStyle.width = baseline + unit;
      const newUnitWidth = /** @type {HTMLElement} */(tempEl).offsetWidth || baseline;
      const factor = currentUnitWidth / newUnitWidth;
      parentEl.removeChild(tempEl);
      convertedValue = factor * currentNumber;
    }
    decomposedValue.n = convertedValue;
    convertedValuesCache[cachedKey] = convertedValue;
  }
  decomposedValue.t === valueTypes.UNIT;
  decomposedValue.u = unit;
  return decomposedValue;
}



================================================
FILE: src/utils.js
================================================
/// <reference path='./types.js' />

import {
  globals,
} from './globals.js';

import {
  noop,
  minValue,
  compositionTypes,
  valueTypes,
  K,
  tweenTypes,
} from './consts.js';

import {
  isUnd,
  floor,
  PI,
  snap,
  clamp,
  round,
  interpolate,
  removeChild,
  forEachChildren,
} from './helpers.js';

import {
  engine,
} from './engine.js';

import {
  Timer,
} from './timer.js';

import {
  JSAnimation,
  cleanInlineStyles,
} from './animation.js';

import {
  removeWAAPIAnimation,
} from './waapi.js';

import {
  parseTargets,
  registerTargets,
} from './targets.js';

import {
  sanitizePropertyName,
} from './properties.js';

import {
  setValue,
  getTweenType,
  getOriginalAnimatableValue,
  decomposeRawValue,
  decomposedOriginalValue,
} from './values.js';

import {
  convertValueUnit,
} from './units.js';

import {
  removeTweenSliblings,
} from './compositions.js';

/**
 * @param  {Callback<Timer>} [callback]
 * @return {Timer}
 */
export const sync = (callback = noop) => {
  return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();
}

/**
 * @overload
 * @param  {DOMTargetSelector} targetSelector
 * @param  {String}            propName
 * @return {String}
 *
 * @overload
 * @param  {JSTargetsParam} targetSelector
 * @param  {String}         propName
 * @return {Number|String}
 *
 * @overload
 * @param  {DOMTargetsParam} targetSelector
 * @param  {String}          propName
 * @param  {String}          unit
 * @return {String}
 *
 * @overload
 * @param  {TargetsParam} targetSelector
 * @param  {String}       propName
 * @param  {Boolean}      unit
 * @return {Number}
 *
 * @param  {TargetsParam}   targetSelector
 * @param  {String}         propName
 * @param  {String|Boolean} [unit]
 */
export function getTargetValue(targetSelector, propName, unit) {
  const targets = registerTargets(targetSelector);
  if (!targets.length) return;
  const [ target ] = targets;
  const tweenType = getTweenType(target, propName);
  const normalizePropName = sanitizePropertyName(propName, target, tweenType);
  let originalValue = getOriginalAnimatableValue(target, normalizePropName);
  if (isUnd(unit)) {
    return originalValue;
  } else {
    decomposeRawValue(originalValue, decomposedOriginalValue);
    if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {
      if (unit === false) {
        return decomposedOriginalValue.n;
      } else {
        const convertedValue = convertValueUnit(/** @type {DOMTarget} */(target), decomposedOriginalValue, /** @type {String} */(unit), false);
        return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;
      }
    }
  }
}

/**
 * @param  {TargetsParam}    targets
 * @param  {AnimationParams} parameters
 * @return {JSAnimation}
 */
export const setTargetValues = (targets, parameters) => {
  if (isUnd(parameters)) return;
  parameters.duration = minValue;
  // Do not overrides currently active tweens by default
  parameters.composition = setValue(parameters.composition, compositionTypes.none);
  // Skip init() and force rendering by playing the animation
  return new JSAnimation(targets, parameters, null, 0, true).resume();
}

/**
 * @param  {TargetsArray} targetsArray
 * @param  {JSAnimation}    animation
 * @param  {String}       [propertyName]
 * @return {Boolean}
 */
const removeTargetsFromAnimation = (targetsArray, animation, propertyName) => {
  let tweensMatchesTargets = false;
  forEachChildren(animation, (/**@type {Tween} */tween) => {
    const tweenTarget = tween.target;
    if (targetsArray.includes(tweenTarget)) {
      const tweenName = tween.property;
      const tweenType = tween._tweenType;
      const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);
      if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
        // Make sure to flag the previous CSS transform tween to renderTransform
        if (tween.parent._tail === tween &&
            tween._tweenType === tweenTypes.TRANSFORM &&
            tween._prev &&
            tween._prev._tweenType === tweenTypes.TRANSFORM
        ) {
          tween._prev._renderTransforms = 1;
        }
        // Removes the tween from the selected animation
        removeChild(animation, tween);
        // Detach the tween from its siblings to make sure blended tweens are correctlly removed
        removeTweenSliblings(tween);
        tweensMatchesTargets = true;
      }
    }
  }, true);
  return tweensMatchesTargets;
}

/**
 * @param  {TargetsParam} targets
 * @param  {Renderable|WAAPIAnimation} [renderable]
 * @param  {String}                    [propertyName]
 * @return {TargetsArray}
 */
export const remove = (targets, renderable, propertyName) => {
  const targetsArray = parseTargets(targets);
  const parent = /** @type {Renderable|typeof engine} **/(renderable ? renderable : engine);
  const waapiAnimation = renderable && /** @type {WAAPIAnimation} */(renderable).controlAnimation && /** @type {WAAPIAnimation} */(renderable);
  for (let i = 0, l = targetsArray.length; i < l; i++) {
    const $el = /** @type {DOMTarget}  */(targetsArray[i]);
    removeWAAPIAnimation($el, propertyName, waapiAnimation);
  }
  let removeMatches;
  if (parent._hasChildren) {
    let iterationDuration = 0;
    forEachChildren(parent, (/** @type {Renderable} */child) => {
      if (!child._hasChildren) {
        removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */(child), propertyName);
        // Remove the child from its parent if no tweens and no children left after the removal
        if (removeMatches && !child._head) {
          child.cancel();
          removeChild(parent, child);
        } else {
          // Calculate the new iterationDuration value to handle onComplete with last child in render()
          const childTLOffset = child._offset + child._delay;
          const childDur = childTLOffset + child.duration;
          if (childDur > iterationDuration) {
            iterationDuration = childDur;
          }
        }
      }
      // Make sure to also remove engine's children targets
      // NOTE: Avoid recursion?
      if (child._head) {
        remove(targets, child, propertyName);
      } else {
        child._hasChildren = false;
      }
    }, true);
    // Update iterationDuration value to handle onComplete with last child in render()
    if (!isUnd(/** @type {Renderable} */(parent).iterationDuration)) {
      /** @type {Renderable} */(parent).iterationDuration = iterationDuration;
    }
  } else {
    removeMatches = removeTargetsFromAnimation(
      targetsArray,
      /** @type {JSAnimation} */(parent),
      propertyName
    );
  }

  if (removeMatches && !parent._head) {
    parent._hasChildren = false;
    // Cancel the parent if there are no tweens and no children left after the removal
    // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself
    if (/** @type {Renderable} */(parent).cancel) /** @type {Renderable} */(parent).cancel();
  }

  return targetsArray;
}

/**
 * @param  {Number} min
 * @param  {Number} max
 * @param  {Number} [decimalLength]
 * @return {Number}
 */
const random = (min, max, decimalLength) => { const m = 10 ** (decimalLength || 0); return floor((Math.random() * (max - min + (1 / m)) + min) * m) / m };

/**
 * @param  {String|Array} items
 * @return {any}
 */
const randomPick = items => items[random(0, items.length - 1)];

/**
 * Adapted from https://bost.ocks.org/mike/shuffle/
 * @param  {Array} items
 * @return {Array}
 */
const shuffle = items => {
  let m = items.length, t, i;
  while (m) { i = random(0, --m); t = items[m]; items[m] = items[i]; items[i] = t; }
  return items;
}

/**
 * @param  {Number|String} v
 * @param  {Number} decimalLength
 * @return {String}
 */
const roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);

/**
 * @param  {Number} v
 * @param  {Number} totalLength
 * @param  {String} padString
 * @return {String}
 */
const padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);

/**
 * @param  {Number} v
 * @param  {Number} totalLength
 * @param  {String} padString
 * @return {String}
 */
const padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);

/**
 * @param  {Number} v
 * @param  {Number} min
 * @param  {Number} max
 * @return {Number}
 */
const wrap = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;

/**
 * @param  {Number} value
 * @param  {Number} inLow
 * @param  {Number} inHigh
 * @param  {Number} outLow
 * @param  {Number} outHigh
 * @return {Number}
 */
export const mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);

/**
 * @param  {Number} degrees
 * @return {Number}
 */
const degToRad = degrees => degrees * PI / 180;

/**
 * @param  {Number} radians
 * @return {Number}
 */
const radToDeg = radians => radians * 180 / PI;

/**
 * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
 * @param  {Number} start
 * @param  {Number} end
 * @param  {Number} amount
 * @param  {Renderable|Boolean} [renderable]
 * @return {Number}
 */
export const lerp = (start, end, amount, renderable) => {
  let dt = K / globals.defaults.frameRate;
  if (renderable !== false) {
    const ticker = /** @type Renderable */
                   (renderable) ||
                   (engine._hasChildren && engine);
    if (ticker && ticker.deltaTime) {
      dt = ticker.deltaTime;
    }
  }
  const t = 1 - Math.exp(-amount * dt * .1);
  return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;
}

// Chain-able utilities

/**
 * @callback UtilityFunction
 * @param {...*} args
 * @return {Number|String}
 *
 * @param {UtilityFunction} fn
 * @param {Number} [last=0]
 * @return {function(...(Number|String)): function(Number|String): (Number|String)}
 */
const curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);

/**
 * @param {Function} fn
 * @return {function(...(Number|String))}
 */
const chain = fn => {
   return (...args) => {
    const result = fn(...args);
    return new Proxy(noop, {
      apply: (_, __, [v]) => result(v),
      get: (_, prop) => chain(/**@param {...Number|String} nextArgs */(...nextArgs) => {
        const nextResult = utils[prop](...nextArgs);
        return (/**@type {Number|String} */v) => nextResult(result(v));
      })
    });
  }
}

/**
 * @param {UtilityFunction} fn
 * @param {Number} [right]
 * @return {function(...(Number|String)): UtilityFunction}
 */
const makeChainable = (fn, right = 0) => (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);

/**
 * @callback ChainedUtilsResult
 * @param {Number} value
 * @return {Number}
 *
 * @typedef {Object} ChainableUtils
 * @property {ChainedClamp} clamp
 * @property {ChainedRound} round
 * @property {ChainedSnap} snap
 * @property {ChainedWrap} wrap
 * @property {ChainedInterpolate} interpolate
 * @property {ChainedMapRange} mapRange
 * @property {ChainedRoundPad} roundPad
 * @property {ChainedPadStart} padStart
 * @property {ChainedPadEnd} padEnd
 * @property {ChainedDegToRad} degToRad
 * @property {ChainedRadToDeg} radToDeg
 *
 * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil
 *
 * @callback ChainedClamp
 * @param {Number} min
 * @param {Number} max
 * @return {ChainableUtil}
 *
 * @callback ChainedRound
 * @param {Number} decimalLength
 * @return {ChainableUtil}
 *
 * @callback ChainedSnap
 * @param {Number} increment
 * @return {ChainableUtil}
 *
 * @callback ChainedWrap
 * @param {Number} min
 * @param {Number} max
 * @return {ChainableUtil}
 *
 * @callback ChainedInterpolate
 * @param {Number} start
 * @param {Number} end
 * @return {ChainableUtil}
 *
 * @callback ChainedMapRange
 * @param {Number} inLow
 * @param {Number} inHigh
 * @param {Number} outLow
 * @param {Number} outHigh
 * @return {ChainableUtil}
 *
 * @callback ChainedRoundPad
 * @param {Number} decimalLength
 * @return {ChainableUtil}
 *
 * @callback ChainedPadStart
 * @param {Number} totalLength
 * @param {String} padString
 * @return {ChainableUtil}
 *
 * @callback ChainedPadEnd
 * @param {Number} totalLength
 * @param {String} padString
 * @return {ChainableUtil}
 *
 * @callback ChainedDegToRad
 * @return {ChainableUtil}
 *
 * @callback ChainedRadToDeg
 * @return {ChainableUtil}
 */

export const utils = {
  $: registerTargets,
  get: getTargetValue,
  set: setTargetValues,
  remove,
  cleanInlineStyles,
  random,
  randomPick,
  shuffle,
  lerp,
  sync,
  clamp: /** @type {typeof clamp & ChainedClamp} */(makeChainable(clamp)),
  round: /** @type {typeof round & ChainedRound} */(makeChainable(round)),
  snap: /** @type {typeof snap & ChainedSnap} */(makeChainable(snap)),
  wrap: /** @type {typeof wrap & ChainedWrap} */(makeChainable(wrap)),
  interpolate: /** @type {typeof interpolate & ChainedInterpolate} */(makeChainable(interpolate, 1)),
  mapRange: /** @type {typeof mapRange & ChainedMapRange} */(makeChainable(mapRange)),
  roundPad: /** @type {typeof roundPad & ChainedRoundPad} */(makeChainable(roundPad)),
  padStart: /** @type {typeof padStart & ChainedPadStart} */(makeChainable(padStart)),
  padEnd: /** @type {typeof padEnd & ChainedPadEnd} */(makeChainable(padEnd)),
  degToRad: /** @type {typeof degToRad & ChainedDegToRad} */(makeChainable(degToRad)),
  radToDeg: /** @type {typeof radToDeg & ChainedRadToDeg} */(makeChainable(radToDeg)),
}



================================================
FILE: src/values.js
================================================
/// <reference path='./types.js' />

import {
  shortTransforms,
  validTransforms,
  tweenTypes,
  valueTypes,
  digitWithExponentRgx,
  unitsExecRgx,
  isDomSymbol,
  isSvgSymbol,
  proxyTargetSymbol,
} from './consts.js';

import {
  stringStartsWith,
  cloneArray,
  isFnc,
  isUnd,
  isCol,
} from './helpers.js';

import {
  parseInlineTransforms,
} from './transforms.js';

import {
  isValidSVGAttribute,
} from './svg.js';

import {
  convertColorStringValuesToRgbaArray
} from './colors.js';

/**
 * @template T, D
 * @param {T|undefined} targetValue
 * @param {D} defaultValue
 * @return {T|D}
 */
export const setValue = (targetValue, defaultValue) => {
  return isUnd(targetValue) ? defaultValue : targetValue;
}

/**
 * @param  {TweenPropValue} value
 * @param  {Target} target
 * @param  {Number} index
 * @param  {Number} total
 * @param  {Object} [store]
 * @return {any}
 */
export const getFunctionValue = (value, target, index, total, store) => {
  if (isFnc(value)) {
    const func = () => {
      const computed = /** @type {Function} */(value)(target, index, total);
      // Fallback to 0 if the function returns undefined / NaN / null / false / 0
      return !isNaN(+computed) ? +computed : computed || 0;
    }
    if (store) {
      store.func = func;
    }
    return func();
  } else {
    return value;
  }
}

/**
 * @param  {Target} target
 * @param  {String} prop
 * @return {tweenTypes}
 */
export const getTweenType = (target, prop) => {
  return !target[isDomSymbol] ? tweenTypes.OBJECT :
    // Handle SVG attributes
    target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :
    // Handle CSS Transform properties differently than CSS to allow individual animations
    validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :
    // CSS variables
    stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :
    // All other CSS properties
    prop in /** @type {DOMTarget} */(target).style ? tweenTypes.CSS :
    // Handle other DOM Attributes
    prop in target ? tweenTypes.OBJECT :
    tweenTypes.ATTRIBUTE;
}

/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
const getCSSValue = (target, propName, animationInlineStyles) => {
  const inlineStyles = target.style[propName];
  if (inlineStyles && animationInlineStyles) {
    animationInlineStyles[propName] = inlineStyles;
  }
  const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);
  return value === 'auto' ? '0' : value;
}

/**
 * @param {Target} target
 * @param {String} propName
 * @param {tweenTypes} [tweenType]
 * @param {Object|void} [animationInlineStyles]
 * @return {String|Number}
 */
export const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
  const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);
  return type === tweenTypes.OBJECT ? target[propName] || 0 :
         type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */(target).getAttribute(propName) :
         type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */(target), propName, animationInlineStyles) :
         type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles).trimStart() :
         getCSSValue(/** @type {DOMTarget} */(target), propName, animationInlineStyles);
}

/**
 * @param  {Number} x
 * @param  {Number} y
 * @param  {String} operator
 * @return {Number}
 */
export const getRelativeValue = (x, y, operator) => {
  return operator === '-' ? x - y :
         operator === '+' ? x + y :
         x * y;
}

/** @return {TweenDecomposedValue} */
export const createDecomposedValueTargetObject = () => {
  return {
    /** @type {valueTypes} */
    t: valueTypes.NUMBER,
    n: 0,
    u: null,
    o: null,
    d: null,
    s: null,
  }
}

/**
 * @param  {String|Number} rawValue
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
export const decomposeRawValue = (rawValue, targetObject) => {
  /** @type {valueTypes} */
  targetObject.t = valueTypes.NUMBER;
  targetObject.n = 0;
  targetObject.u = null;
  targetObject.o = null;
  targetObject.d = null;
  targetObject.s = null;
  if (!rawValue) return targetObject;
  const num = +rawValue;
  if (!isNaN(num)) {
    // It's a number
    targetObject.n = num;
    return targetObject;
  } else {
    // let str = /** @type {String} */(rawValue).trim();
    let str = /** @type {String} */(rawValue);
    // Parsing operators (+=, -=, *=) manually is much faster than using regex here
    if (str[1] === '=') {
      targetObject.o = str[0];
      str = str.slice(2);
    }
    // Skip exec regex if the value type is complex or color to avoid long regex backtracking
    const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);
    if (unitMatch) {
      // Has a number and a unit
      targetObject.t = valueTypes.UNIT;
      targetObject.n = +unitMatch[1];
      targetObject.u = unitMatch[2];
      return targetObject;
    } else if (targetObject.o) {
      // Has an operator (+=, -=, *=)
      targetObject.n = +str;
      return targetObject;
    } else if (isCol(str)) {
      // Is a color
      targetObject.t = valueTypes.COLOR;
      targetObject.d = convertColorStringValuesToRgbaArray(str);
      return targetObject;
    } else {
      // Is a more complex string (generally svg coords, calc() or filters CSS values)
      const matchedNumbers = str.match(digitWithExponentRgx);
      targetObject.t = valueTypes.COMPLEX;
      targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
      targetObject.s = str.split(digitWithExponentRgx) || [];
      return targetObject;
    }
  }
}

/**
 * @param  {Tween} tween
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
export const decomposeTweenValue = (tween, targetObject) => {
  targetObject.t = tween._valueType;
  targetObject.n = tween._toNumber;
  targetObject.u = tween._unit;
  targetObject.o = null;
  targetObject.d = cloneArray(tween._toNumbers);
  targetObject.s = cloneArray(tween._strings);
  return targetObject;
}

export const decomposedOriginalValue = createDecomposedValueTargetObject();



================================================
FILE: src/waapi.js
================================================
/// <reference path='./types.js' />

import {
  isArr,
  isKey,
  isNum,
  isObj,
  isStr,
  isUnd,
  isFnc,
  addChild,
  removeChild,
  stringStartsWith,
  toLowerCase,
} from './helpers.js';

import {
  globals,
} from './globals.js';

import {
  registerTargets,
} from './targets.js';

import {
  getFunctionValue,
  setValue,
} from './values.js';

import {
  none,
  easeTypes,
  easeInPower,
  parseEaseString,
} from './eases.js';

import {
  isBrowser,
  K,
  noop,
  emptyString,
  shortTransforms,
  transformsFragmentStrings,
  transformsSymbol,
  validTransforms,
} from './consts.js';

/**
 * Converts an easing function into a valid CSS linear() timing function string
 * @param {EasingFunction} fn
 * @param {number} [samples=100]
 * @returns {string} CSS linear() timing function
 */
const easingToLinear = (fn, samples = 100) => {
  const points = [];
  for (let i = 0; i <= samples; i++) points.push(fn(i / samples));
  return `linear(${points.join(', ')})`;
}

const WAAPIEasesLookups = {
  in: 'ease-in',
  out: 'ease-out',
  inOut: 'ease-in-out',
}

const WAAPIeases = /*#__PURE__*/(() => {
  const list = {};
  for (let type in easeTypes) list[type] = a => easeTypes[type](easeInPower(a));
  return /** @type {Record<String, EasingFunction>} */(list);
})();

/**
 * @param  {EasingParam} ease
 * @return {String}
 */
const parseWAAPIEasing = (ease) => {
  let parsedEase = WAAPIEasesLookups[ease];
  if (parsedEase) return parsedEase;
  parsedEase = 'linear';
  if (isStr(ease)) {
    if (
      stringStartsWith(ease, 'linear') ||
      stringStartsWith(ease, 'cubic-') ||
      stringStartsWith(ease, 'steps') ||
      stringStartsWith(ease, 'ease')
    ) {
      parsedEase = ease;
    } else if (stringStartsWith(ease, 'cubicB')) {
      parsedEase = toLowerCase(ease);
    } else {
      const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);
      if (isFnc(parsed)) parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);
    }
  } else if (isFnc(ease)) {
    const easing = easingToLinear(ease);
    if (easing) parsedEase = easing;
  } else if (/** @type {Spring} */(ease).ease) {
    parsedEase = easingToLinear(/** @type {Spring} */(ease).ease);
  }
  return WAAPIEasesLookups[ease] = parsedEase;
}

/**
 * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue
 */

/**
 * @callback WAAPIFunctionvalue
 * @param {DOMTarget} target - The animated target
 * @param {Number} index - The target index
 * @param {Number} length - The total number of animated targets
 * @return {WAAPITweenValue}
 */

/**
 * @typedef {WAAPITweenValue|WAAPIFunctionvalue|Array<String|Number|WAAPIFunctionvalue>} WAAPIKeyframeValue
 */

/**
 * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback
 */

/**
 * @typedef {Object} WAAPITweenOptions
 * @property {WAAPIKeyframeValue} [to]
 * @property {WAAPIKeyframeValue} [from]
 * @property {Number|WAAPIFunctionvalue} [duration]
 * @property {Number|WAAPIFunctionvalue} [delay]
 * @property {EasingParam} [ease]
 * @property {CompositeOperation} [composition]
 */

/**
 * @typedef {Object} WAAPIAnimationOptions
 * @property {Number|Boolean} [loop]
 * @property {Boolean} [Reversed]
 * @property {Boolean} [Alternate]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number} [playbackRate]
 * @property {Number|WAAPIFunctionvalue} [duration]
 * @property {Number|WAAPIFunctionvalue} [delay]
 * @property {EasingParam} [ease]
 * @property {CompositeOperation} [composition]
 * @property {WAAPICallback} [onComplete]
 */

/**
 * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams
 */

const transformsShorthands = ['x', 'y', 'z'];
const commonDefaultPXProperties = [
  'perspective',
  'width',
  'height',
  'margin',
  'padding',
  'top',
  'right',
  'bottom',
  'left',
  'borderWidth',
  'fontSize',
  'borderRadius',
  ...transformsShorthands
]

const validIndividualTransforms = [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))];

// Setting it to true in case CSS.registerProperty is not supported will automatically skip the registration and fallback to no animation
let transformsPropertiesRegistered = isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'));

const registerTransformsProperties = () => {
  validTransforms.forEach(t => {
    const isSkew = stringStartsWith(t, 'skew');
    const isScale = stringStartsWith(t, 'scale');
    const isRotate = stringStartsWith(t, 'rotate');
    const isTranslate = stringStartsWith(t, 'translate');
    const isAngle = isRotate || isSkew;
    const syntax = isAngle ? '<angle>' : isScale ? "<number>" : isTranslate ? "<length-percentage>" : "*";
    CSS.registerProperty({
      name: '--' + t,
      syntax,
      inherits: false,
      initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',
    });
  });
  transformsPropertiesRegistered = true;
}

const WAAPIAnimationsLookups = {
  _head: null,
  _tail: null,
};

/**
 * @param {DOMTarget} $el
 * @param {String} [property]
 * @param {WAAPIAnimation} [parent]
 */
export const removeWAAPIAnimation = ($el, property, parent) => {
  let nextLookup = WAAPIAnimationsLookups._head;
  while (nextLookup) {
    const next = nextLookup._next;
    const matchTarget = nextLookup.$el === $el;
    const matchProperty = !property || nextLookup.property === property;
    const matchParent = !parent || nextLookup.parent === parent;
    if (matchTarget && matchProperty && matchParent) {
      const anim = nextLookup.animation;
      try { anim.commitStyles(); } catch {};
      anim.cancel();
      removeChild(WAAPIAnimationsLookups, nextLookup);
      const lookupParent = nextLookup.parent;
      if (lookupParent) {
        lookupParent._completed++;
        if (lookupParent.animations.length === lookupParent._completed) {
          lookupParent.completed = true;
          if (!lookupParent.muteCallbacks) {
            lookupParent.paused = true;
            lookupParent.onComplete(lookupParent);
            lookupParent._resolve(lookupParent);
          }
        }
      }
    }
    nextLookup = next;
  }
}

/**
 * @param {WAAPIAnimation} parent
 * @param {DOMTarget} $el
 * @param {String} property
 * @param {PropertyIndexedKeyframes} keyframes
 * @param {KeyframeAnimationOptions} params
 * @retun {Animation}
 */
const addWAAPIAnimation = (parent, $el, property, keyframes, params) => {
  const animation = $el.animate(keyframes, params);
  const animTotalDuration = params.delay + (+params.duration * params.iterations);
  animation.playbackRate = parent._speed;
  if (parent.paused) animation.pause();
  if (parent.duration < animTotalDuration) {
    parent.duration = animTotalDuration;
    parent.controlAnimation = animation;
  }
  parent.animations.push(animation);
  removeWAAPIAnimation($el, property);
  addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });
  const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };
  animation.onremove = handleRemove;
  animation.onfinish = handleRemove;
  return animation;
}

/**
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} value
 * @param  {DOMTarget} $el
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {String}
 */
const normalizeTweenValue = (propName, value, $el, i, targetsLength) => {
  let v = getFunctionValue(/** @type {any} */(value), $el, i, targetsLength);
  if (!isNum(v)) return v;
  if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate')) return `${v}px`;
  if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew')) return `${v}deg`;
  return `${v}`;
}

/**
 * @param  {DOMTarget} $el
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} from
 * @param  {WAAPIKeyframeValue} to
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {WAAPITweenValue}
 */
const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {
  /** @type {WAAPITweenValue} */
  let tweenValue = '0';
  const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];
  if (!isUnd(from)) {
    const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);
    tweenValue = [computedFrom, computedTo];
  } else {
    tweenValue = isArr(to) ? to.map((/** @type {any} */v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;
  }
  return tweenValue;
}

export class WAAPIAnimation {
/**
 * @param {DOMTargetsParam} targets
 * @param {WAAPIAnimationParams} params
 */
  constructor(targets, params) {

    if (globals.scope) globals.scope.revertibles.push(this);

    if (!transformsPropertiesRegistered) registerTransformsProperties();

    const parsedTargets = registerTargets(targets);
    const targetsLength = parsedTargets.length;

    if (!targetsLength) {
      console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
    }

    const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));
    const spring = /** @type {Spring} */(ease).ease && ease;
    const autoplay = setValue(params.autoplay, globals.defaults.autoplay);
    const scroll = autoplay && /** @type {ScrollObserver} */(autoplay).link ? autoplay : false;
    const alternate = params.alternate && /** @type {Boolean} */(params.alternate) === true;
    const reversed = params.reversed && /** @type {Boolean} */(params.reversed) === true;
    const loop = setValue(params.loop, globals.defaults.loop);
    const iterations = /** @type {Number} */((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);
    /** @type {PlaybackDirection} */
    const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';
    /** @type {FillMode} */
    const fill = 'forwards';
    /** @type {String} */
    const easing = parseWAAPIEasing(ease);
    const timeScale = (globals.timeScale === 1 ? 1 : K);

    /** @type {DOMTargetsArray}] */
    this.targets = parsedTargets;
    /** @type {Array<globalThis.Animation>}] */
    this.animations = [];
    /** @type {globalThis.Animation}] */
    this.controlAnimation = null;
    /** @type {Callback<this>} */
    this.onComplete = params.onComplete || noop;
    /** @type {Number} */
    this.duration = 0;
    /** @type {Boolean} */
    this.muteCallbacks = false;
    /** @type {Boolean} */
    this.completed = false;
    /** @type {Boolean} */
    this.paused = !autoplay || scroll !== false;
    /** @type {Boolean} */
    this.reversed = reversed;
    /** @type {Boolean|ScrollObserver} */
    this.autoplay = autoplay;
    /** @type {Number} */
    this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);
    /** @type {Function} */
    this._resolve = noop; // Used by .then()
    /** @type {Number} */
    this._completed = 0;
    /** @type {Array<Object>}] */
    this._inlineStyles = parsedTargets.map($el => $el.getAttribute('style'));

    parsedTargets.forEach(($el, i) => {

      const cachedTransforms = $el[transformsSymbol];

      const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));

      /** @type {Number} */
      const duration = (spring ? /** @type {Spring} */(spring).duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;
      /** @type {Number} */
      const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;
      /** @type {CompositeOperation} */
      const composite = /** @type {CompositeOperation} */(setValue(params.composition, 'replace'));

      for (let name in params) {
        if (!isKey(name)) continue;
        /** @type {PropertyIndexedKeyframes} */
        const keyframes = {};
        /** @type {KeyframeAnimationOptions} */
        const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };
        const propertyValue = params[name];
        const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;
        let parsedPropertyValue;
        if (isObj(propertyValue)) {
          const tweenOptions = /** @type {WAAPITweenOptions} */(propertyValue);
          const tweenOptionsEase = setValue(tweenOptions.ease, ease);
          const tweenOptionsSpring = /** @type {Spring} */(tweenOptionsEase).ease && tweenOptionsEase;
          const to = /** @type {WAAPITweenOptions} */(tweenOptions).to;
          const from = /** @type {WAAPITweenOptions} */(tweenOptions).from;
          /** @type {Number} */
          tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */(tweenOptionsSpring).duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;
          /** @type {Number} */
          tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;
          /** @type {CompositeOperation} */
          tweenParams.composite = /** @type {CompositeOperation} */(setValue(tweenOptions.composition, composite));
          /** @type {String} */
          tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);
          parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
          if (individualTransformProperty) {
            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
            cachedTransforms[individualTransformProperty] = parsedPropertyValue;
          } else {
            keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
          }
          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
          if (!isUnd(from)) {
            if (!individualTransformProperty) {
              $el.style[name] = keyframes[name][0];
            } else {
              const key = `--${individualTransformProperty}`;
              $el.style.setProperty(key, keyframes[key][0]);
            }
          }
        } else {
          parsedPropertyValue = isArr(propertyValue) ?
                                propertyValue.map((/** @type {any} */v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :
                                normalizeTweenValue(name, /** @type {any} */(propertyValue), $el, i, targetsLength);
          if (individualTransformProperty) {
            keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
            cachedTransforms[individualTransformProperty] = parsedPropertyValue;
          } else {
            keyframes[name] = parsedPropertyValue;
          }
          addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
        }
      }
      if (hasIndividualTransforms) {
        let transforms = emptyString;
        for (let t in cachedTransforms) {
          transforms += `${transformsFragmentStrings[t]}var(--${t})) `;
        }
        $el.style.transform = transforms;
      }
    });

    if (scroll) {
      /** @type {ScrollObserver} */(this.autoplay).link(this);
    }
  }

  /**
   * @callback forEachCallback
   * @param {globalThis.Animation} animation
   */

  /**
   * @param  {forEachCallback|String} callback
   * @return {this}
   */
  forEach(callback) {
    const cb = isStr(callback) ? a => a[callback]() : callback;
    this.animations.forEach(cb);
    return this;
  }

  get speed() {
    return this._speed;
  }

  /** @param {Number} speed */
  set speed(speed) {
    this._speed = +speed;
    this.forEach(anim => anim.playbackRate = speed);
  }

  get currentTime() {
    const controlAnimation = this.controlAnimation;
    const timeScale = globals.timeScale;
    return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;
  }

  /** @param {Number} time */
  set currentTime(time) {
    const t = time * (globals.timeScale === 1 ? 1 : K);
    this.forEach(anim => anim.currentTime = t);
  }

  get progress() {
    return this.currentTime / this.duration;
  }

  /** @param {Number} progress */
  set progress(progress) {
    this.forEach(anim => anim.currentTime = progress * this.duration || 0);
  }

  resume() {
    if (!this.paused) return this;
    this.paused = false;
    // TODO: Store the current time, and seek back to the last position
    return this.forEach('play');
  }

  pause() {
    if (this.paused) return this;
    this.paused = true;
    return this.forEach('pause');
  }

  alternate() {
    this.reversed = !this.reversed;
    this.forEach('reverse');
    if (this.paused) this.forEach('pause');
    return this;
  }

  play() {
    if (this.reversed) this.alternate();
    return this.resume();
  }

  reverse() {
    if (!this.reversed) this.alternate();
    return this.resume();
  }

 /**
  * @param {Number} time
  * @param {Boolean} muteCallbacks
  */
  seek(time, muteCallbacks = false) {
    if (muteCallbacks) this.muteCallbacks = true;
    if (time < this.duration) this.completed = false;
    this.currentTime = time;
    this.muteCallbacks = false;
    if (this.paused) this.pause();
    return this;
  }

  restart() {
    this.completed = false;
    return this.seek(0, true).resume();
  }

  commitStyles() {
    return this.forEach('commitStyles');
  }

  complete() {
    return this.seek(this.duration);
  }

  cancel() {
    this.forEach('cancel');
    return this.pause();
  }

  revert() {
    this.cancel();
    this.targets.forEach(($el, i) => $el.setAttribute('style', this._inlineStyles[i]) );
    return this;
  }

  /**
   * @param  {WAAPICallback} [callback]
   * @return {Promise}
   */
  then(callback = noop) {
    const then = this.then;
    const onResolve = () => {
      this.then = null;
      callback(this);
      this.then = then;
      this._resolve = noop;
    }
    return new Promise(r => {
      this._resolve = () => r(onResolve());
      if (this.completed) this._resolve();
      return this;
    });
  }
}

export const waapi = {
/**
 * @param {DOMTargetsParam} targets
 * @param {WAAPIAnimationParams} params
 * @return {WAAPIAnimation}
 */
  animate: (targets, params) => new WAAPIAnimation(targets, params),
  convertEase: easingToLinear
}



================================================
FILE: types/index.d.ts
================================================
/// <reference types="node" />
declare class Engine extends Clock {
    useDefaultMainLoop: boolean;
    pauseOnDocumentHidden: boolean;
    defaults: DefaultsParams;
    paused: boolean;
    reqId: number | NodeJS.Immediate;
    update(): void;
    wake(): this;
    pause(): Engine;
    resume(): this;
    set timeUnit(arg: "ms" | "s");
    get timeUnit(): "ms" | "s";
    set precision(arg: number);
    get precision(): number;
}
declare const engine: Engine;
declare class Clock {
    constructor(initTime?: number);
    deltaTime: number;
    _currentTime: number;
    _elapsedTime: number;
    _startTime: number;
    _lastTime: number;
    _scheduledTime: number;
    _frameDuration: number;
    _fps: number;
    _speed: number;
    _hasChildren: boolean;
    _head: Tickable | Tween;
    _tail: Tickable | Tween;
    set fps(arg: number);
    get fps(): number;
    set speed(arg: number);
    get speed(): number;
    requestTick(time: number): tickModes;
    computeDeltaTime(time: number): number;
}
type tweenTypes = number;
declare namespace tweenTypes {
    let OBJECT: number;
    let ATTRIBUTE: number;
    let CSS: number;
    let TRANSFORM: number;
    let CSS_VAR: number;
}
type valueTypes = number;
declare namespace valueTypes {
    let NUMBER: number;
    let UNIT: number;
    let COLOR: number;
    let COMPLEX: number;
}
type tickModes = number;
declare namespace tickModes {
    let NONE: number;
    let AUTO: number;
    let FORCE: number;
}
type compositionTypes = number;
declare namespace compositionTypes {
    let replace: number;
    let none: number;
    let blend: number;
}
declare function getTargetValue(targetSelector: DOMTargetSelector, propName: string): string;
declare function getTargetValue(targetSelector: JSTargetsParam, propName: string): number | string;
declare function getTargetValue(targetSelector: DOMTargetsParam, propName: string, unit: string): string;
declare function getTargetValue(targetSelector: TargetsParam, propName: string, unit: boolean): number;
declare function sync(callback?: Callback<Timer>): Timer;
declare function setTargetValues(targets: TargetsParam, parameters: AnimationParams): JSAnimation;
declare function remove(targets: TargetsParam, renderable?: Renderable | WAAPIAnimation, propertyName?: string): TargetsArray;
declare function lerp(start: number, end: number, amount: number, renderable?: Renderable | boolean): number;
declare namespace utils {
    export { registerTargets as $ };
    export { getTargetValue as get };
    export { setTargetValues as set };
    export { remove };
    export { cleanInlineStyles };
    export { random };
    export { randomPick };
    export { shuffle };
    export { lerp };
    export { sync };
    export let clamp: ((v: number, min: number, max: number) => number) & ChainedClamp;
    export let round: ((v: number, decimalLength: number) => number) & ChainedRound;
    export let snap: ((v: number, increment: number | number[]) => number) & ChainedSnap;
    export let wrap: ((v: number, min: number, max: number) => number) & ChainedWrap;
    export let interpolate: ((start: number, end: number, progress: number) => number) & ChainedInterpolate;
    export let mapRange: ((value: number, inLow: number, inHigh: number, outLow: number, outHigh: number) => number) & ChainedMapRange;
    export let roundPad: ((v: string | number, decimalLength: number) => string) & ChainedRoundPad;
    export let padStart: ((v: number, totalLength: number, padString: string) => string) & ChainedPadStart;
    export let padEnd: ((v: number, totalLength: number, padString: string) => string) & ChainedPadEnd;
    export let degToRad: ((degrees: number) => number) & ChainedDegToRad;
    export let radToDeg: ((radians: number) => number) & ChainedRadToDeg;
}
type ChainedUtilsResult = (value: number) => number;
type ChainableUtils = {
    clamp: ChainedClamp;
    round: ChainedRound;
    snap: ChainedSnap;
    wrap: ChainedWrap;
    interpolate: ChainedInterpolate;
    mapRange: ChainedMapRange;
    roundPad: ChainedRoundPad;
    padStart: ChainedPadStart;
    padEnd: ChainedPadEnd;
    degToRad: ChainedDegToRad;
    radToDeg: ChainedRadToDeg;
};
type ChainableUtil = ChainableUtils & ChainedUtilsResult;
type ChainedClamp = (min: number, max: number) => ChainableUtil;
type ChainedRound = (decimalLength: number) => ChainableUtil;
type ChainedSnap = (increment: number) => ChainableUtil;
type ChainedWrap = (min: number, max: number) => ChainableUtil;
type ChainedInterpolate = (start: number, end: number) => ChainableUtil;
type ChainedMapRange = (inLow: number, inHigh: number, outLow: number, outHigh: number) => ChainableUtil;
type ChainedRoundPad = (decimalLength: number) => ChainableUtil;
type ChainedPadStart = (totalLength: number, padString: string) => ChainableUtil;
type ChainedPadEnd = (totalLength: number, padString: string) => ChainableUtil;
type ChainedDegToRad = () => ChainableUtil;
type ChainedRadToDeg = () => ChainableUtil;
declare class Timer extends Clock {
    constructor(parameters?: TimerParams, parent?: Timeline, parentPosition?: number);
    id: string | number;
    parent: Timeline;
    duration: number;
    backwards: boolean;
    paused: boolean;
    began: boolean;
    completed: boolean;
    onBegin: Callback<this>;
    onBeforeUpdate: Callback<this>;
    onUpdate: Callback<this>;
    onLoop: Callback<this>;
    onPause: Callback<this>;
    onComplete: Callback<this>;
    iterationDuration: number;
    iterationCount: number;
    _autoplay: boolean | ScrollObserver;
    _offset: number;
    _delay: number;
    _loopDelay: number;
    _iterationTime: number;
    _currentIteration: number;
    _resolve: Function;
    _running: boolean;
    _reversed: number;
    _reverse: number;
    _cancelled: number;
    _alternate: boolean;
    _prev: Renderable;
    _next: Renderable;
    set cancelled(arg: boolean);
    get cancelled(): boolean;
    set currentTime(arg: number);
    get currentTime(): number;
    set iterationCurrentTime(arg: number);
    get iterationCurrentTime(): number;
    set progress(arg: number);
    get progress(): number;
    set iterationProgress(arg: number);
    get iterationProgress(): number;
    set currentIteration(arg: number);
    get currentIteration(): number;
    set reversed(arg: boolean);
    get reversed(): boolean;
    reset(internalRender?: number): this;
    init(internalRender?: number): this;
    resetTime(): this;
    pause(): this;
    resume(): this;
    restart(): this;
    seek(time: number, muteCallbacks?: boolean | number, internalRender?: boolean | number): this;
    alternate(): this;
    play(): this;
    reverse(): this;
    cancel(): this;
    stretch(newDuration: number): this;
    revert(): this;
    complete(): this;
    then(callback?: Callback<this>): Promise<any>;
}
declare function createTimer(parameters?: TimerParams): Timer;
declare function cleanInlineStyles<T extends Renderable>(renderable: T): T;
declare class JSAnimation extends Timer {
    constructor(targets: TargetsParam, parameters: AnimationParams, parent?: Timeline, parentPosition?: number, fastSet?: boolean, index?: number, length?: number);
    targets: TargetsArray;
    onRender: Callback<this>;
    _ease: EasingFunction;
    _inlineStyles: {};
    stretch(newDuration: number): this;
    refresh(): this;
    revert(): this;
    then(callback?: Callback<this>): Promise<any>;
}
declare function animate(targets: TargetsParam, parameters: AnimationParams): JSAnimation;
declare function registerTargets(targets: DOMTargetsParam): DOMTargetsArray;
declare function registerTargets(targets: JSTargetsParam): JSTargetsArray;
declare function registerTargets(targets: TargetsParam): TargetsArray;
declare function random(min: number, max: number, decimalLength?: number): number;
declare function randomPick(items: string | any[]): any;
declare function shuffle(items: any[]): any[];
declare namespace svg {
    export { morphTo };
    export { createMotionPath };
    export { createDrawable };
}
declare function morphTo(path2: TargetsParam, precision?: number): FunctionValue;
declare function createMotionPath(path: TargetsParam): {
    translateX: FunctionValue;
    translateY: FunctionValue;
    rotate: FunctionValue;
};
declare function createDrawable(selector: TargetsParam, start?: number, end?: number): Array<ProxyConstructor>;
declare function stagger(val: number | string | [
    number | string,
    number | string
], params?: StaggerParameters): StaggerFunction;
type StaggerParameters = {
    start?: number | string;
    from?: number | "first" | "center" | "last";
    reversed?: boolean;
    grid?: Array<number>;
    axis?: ("x" | "y");
    ease?: EasingParam;
    modifier?: TweenModifier;
};
type StaggerFunction = (target?: Target, index?: number, length?: number, tl?: Timeline) => number | string;
declare class Timeline extends Timer {
    constructor(parameters?: TimelineParams);
    labels: Record<string, number>;
    defaults: DefaultsParams;
    onRender: Callback<this>;
    _ease: EasingFunction;
    add(a1: TargetsParam, a2: AnimationParams, a3?: TimePosition): this;
    add(a1: TimerParams, a2?: TimePosition): this;
    sync(synced?: Tickable, position?: TimePosition): this;
    sync(synced?: globalThis.Animation, position?: TimePosition): this;
    sync(synced?: WAAPIAnimation, position?: TimePosition): this;
    set(targets: TargetsParam, parameters: AnimationParams, position?: TimePosition): this;
    call(callback: Callback<Timer>, position?: TimePosition): this;
    label(labelName: string, position?: TimePosition): this;
    remove(targets: TargetsParam, propertyName?: string): this;
    stretch(newDuration: number): this;
    refresh(): this;
    revert(): this;
    then(callback?: Callback<this>): Promise<any>;
}
declare function createTimeline(parameters?: TimelineParams): Timeline;
type TimePosition = number | string | Function;
declare namespace eases {
    export let linear: (...args?: (string | number)[]) => EasingFunction;
    export let irregular: (length?: number, randomness?: number) => EasingFunction;
    export let steps: (steps?: number, fromStart?: boolean) => EasingFunction;
    export let cubicBezier: (mX1?: number, mY1?: number, mX2?: number, mY2?: number) => EasingFunction;
    let _in: PowerEasing;
    export { _in as in };
    export let out: PowerEasing;
    export let inOut: PowerEasing;
    export let outIn: PowerEasing;
    export let inQuad: EasingFunction;
    export let outQuad: EasingFunction;
    export let inOutQuad: EasingFunction;
    export let outInQuad: EasingFunction;
    export let inCubic: EasingFunction;
    export let outCubic: EasingFunction;
    export let inOutCubic: EasingFunction;
    export let outInCubic: EasingFunction;
    export let inQuart: EasingFunction;
    export let outQuart: EasingFunction;
    export let inOutQuart: EasingFunction;
    export let outInQuart: EasingFunction;
    export let inQuint: EasingFunction;
    export let outQuint: EasingFunction;
    export let inOutQuint: EasingFunction;
    export let outInQuint: EasingFunction;
    export let inSine: EasingFunction;
    export let outSine: EasingFunction;
    export let inOutSine: EasingFunction;
    export let outInSine: EasingFunction;
    export let inCirc: EasingFunction;
    export let outCirc: EasingFunction;
    export let inOutCirc: EasingFunction;
    export let outInCirc: EasingFunction;
    export let inExpo: EasingFunction;
    export let outExpo: EasingFunction;
    export let inOutExpo: EasingFunction;
    export let outInExpo: EasingFunction;
    export let inBounce: EasingFunction;
    export let outBounce: EasingFunction;
    export let inOutBounce: EasingFunction;
    export let outInBounce: EasingFunction;
    export let inBack: BackEasing;
    export let outBack: BackEasing;
    export let inOutBack: BackEasing;
    export let outInBack: BackEasing;
    export let inElastic: ElasticEasing;
    export let outElastic: ElasticEasing;
    export let inOutElastic: ElasticEasing;
    export let outInElastic: ElasticEasing;
}
type PowerEasing = (power?: number | string) => EasingFunction;
type BackEasing = (overshoot?: number | string) => EasingFunction;
type ElasticEasing = (amplitude?: number | string, period?: number | string) => EasingFunction;
type DefaultsParams = {
    id?: number | string;
    keyframes?: PercentageKeyframes | DurationKeyframes;
    playbackEase?: EasingParam;
    playbackRate?: number;
    frameRate?: number;
    loop?: number | boolean;
    reversed?: boolean;
    alternate?: boolean;
    autoplay?: boolean | ScrollObserver;
    duration?: number | FunctionValue;
    delay?: number | FunctionValue;
    loopDelay?: number;
    ease?: EasingParam;
    composition?: 'none' | 'replace' | 'blend' | compositionTypes;
    modifier?: (v: any) => any;
    onBegin?: (tickable: Tickable) => void;
    onBeforeUpdate?: (tickable: Tickable) => void;
    onUpdate?: (tickable: Tickable) => void;
    onLoop?: (tickable: Tickable) => void;
    onPause?: (tickable: Tickable) => void;
    onComplete?: (tickable: Tickable) => void;
    onRender?: (renderable: Renderable) => void;
};
type Renderable = JSAnimation | Timeline;
type Tickable = Timer | Renderable;
type CallbackArgument = Timer & JSAnimation & Timeline;
declare class Animatable {
    constructor(targets: TargetsParam, parameters: AnimatableParams);
    targets: (HTMLElement | SVGElement | JSTarget)[];
    animations: {};
    revert(): this;
}
declare function createAnimatable(targets: TargetsParam, parameters: AnimatableParams): AnimatableObject;
type Revertible = Animatable | Tickable | Draggable | ScrollObserver | Scope;
type EasingFunction = (time: number) => number;
type EaseStringParamNames = ('linear' | 'linear(x1, x2 25%, x3)' | 'in' | 'out' | 'inOut' | 'inQuad' | 'outQuad' | 'inOutQuad' | 'inCubic' | 'outCubic' | 'inOutCubic' | 'inQuart' | 'outQuart' | 'inOutQuart' | 'inQuint' | 'outQuint' | 'inOutQuint' | 'inSine' | 'outSine' | 'inOutSine' | 'inCirc' | 'outCirc' | 'inOutCirc' | 'inExpo' | 'outExpo' | 'inOutExpo' | 'inBounce' | 'outBounce' | 'inOutBounce' | 'inBack' | 'outBack' | 'inOutBack' | 'inElastic' | 'outElastic' | 'inOutElastic' | 'irregular' | 'cubicBezier' | 'steps' | 'in(p = 1.675)' | 'out(p = 1.675)' | 'inOut(p = 1.675)' | 'inBack(overshoot = 1.70158)' | 'outBack(overshoot = 1.70158)' | 'inOutBack(overshoot = 1.70158)' | 'inElastic(amplitude = 1, period = .3)' | 'outElastic(amplitude = 1, period = .3)' | 'inOutElastic(amplitude = 1, period = .3)' | 'irregular(length = 10, randomness = 1)' | 'cubicBezier(x1, y1, x2, y2)' | 'steps(steps = 10)');
type EasingParam = (string & {}) | EaseStringParamNames | EasingFunction | Spring;
type DOMTarget = HTMLElement | SVGElement;
type JSTarget = Record<string, any>;
type Target = DOMTarget | JSTarget;
type TargetSelector = Target | NodeList | string;
type DOMTargetSelector = DOMTarget | NodeList | string;
type DOMTargetsParam = Array<DOMTargetSelector> | DOMTargetSelector;
type DOMTargetsArray = Array<DOMTarget>;
type JSTargetsParam = Array<JSTarget> | JSTarget;
type JSTargetsArray = Array<JSTarget>;
type TargetsParam = Array<TargetSelector> | TargetSelector;
type TargetsArray = Array<Target>;
type FunctionValue = (target: Target, index: number, length: number) => number | string | TweenObjectValue | Array<number | string | TweenObjectValue>;
type TweenModifier = (value: number) => number | string;
type ColorArray = [number, number, number, number];
type Callback<T> = (self: T, e?: PointerEvent) => any;
type TickableCallbacks<T extends unknown> = {
    onBegin?: Callback<T>;
    onBeforeUpdate?: Callback<T>;
    onUpdate?: Callback<T>;
    onLoop?: Callback<T>;
    onPause?: Callback<T>;
    onComplete?: Callback<T>;
};
type RenderableCallbacks<T extends unknown> = {
    onRender?: Callback<T>;
};
type Tween = {
    id: number;
    parent: JSAnimation;
    property: string;
    target: Target;
    _value: string | number;
    _func: Function | null;
    _ease: EasingFunction;
    _fromNumbers: Array<number>;
    _toNumbers: Array<number>;
    _strings: Array<string>;
    _fromNumber: number;
    _toNumber: number;
    _numbers: Array<number>;
    _number: number;
    _unit: string;
    _modifier: TweenModifier;
    _currentTime: number;
    _delay: number;
    _updateDuration: number;
    _startTime: number;
    _changeDuration: number;
    _absoluteStartTime: number;
    _tweenType: tweenTypes;
    _valueType: valueTypes;
    _composition: number;
    _isOverlapped: number;
    _isOverridden: number;
    _renderTransforms: number;
    _prevRep: Tween;
    _nextRep: Tween;
    _prevAdd: Tween;
    _nextAdd: Tween;
    _prev: Tween;
    _next: Tween;
};
type TweenDecomposedValue = {
    /**
     * - Type
     */
    t: number;
    /**
     * - Single number value
     */
    n: number;
    /**
     * - Value unit
     */
    u: string;
    /**
     * - Value operator
     */
    o: string;
    /**
     * - Array of Numbers (in case of complex value type)
     */
    d: Array<number>;
    /**
     * - Strings (in case of complex value type)
     */
    s: Array<string>;
};
type TweenPropertySiblings = {
    _head: null | Tween;
    _tail: null | Tween;
};
type TweenLookups = Record<string, TweenPropertySiblings>;
type TweenReplaceLookups = WeakMap<Target, TweenLookups>;
type TweenAdditiveLookups = Map<Target, TweenLookups>;
type TimerOptions = {
    id?: number | string;
    duration?: TweenParamValue;
    delay?: TweenParamValue;
    loopDelay?: number;
    reversed?: boolean;
    alternate?: boolean;
    loop?: boolean | number;
    autoplay?: boolean | ScrollObserver;
    frameRate?: number;
    playbackRate?: number;
};
/**
 *
 * /**
 */
type TimerParams = TimerOptions & TickableCallbacks<Timer>;
type TweenParamValue = number | string | FunctionValue;
type TweenPropValue = TweenParamValue | [TweenParamValue, TweenParamValue];
type TweenComposition = (string & {}) | 'none' | 'replace' | 'blend' | compositionTypes;
type TweenParamsOptions = {
    duration?: TweenParamValue;
    delay?: TweenParamValue;
    ease?: EasingParam;
    modifier?: TweenModifier;
    composition?: TweenComposition;
};
type TweenValues = {
    from?: TweenParamValue;
    to?: TweenPropValue;
    fromTo?: TweenPropValue;
};
type TweenKeyValue = TweenParamsOptions & TweenValues;
type ArraySyntaxValue = Array<TweenKeyValue | TweenPropValue>;
type TweenOptions = TweenParamValue | (TweenPropValue | TweenKeyValue)[] | TweenKeyValue;
type TweenObjectValue = Partial<{
    to: TweenParamValue | Array<TweenParamValue>;
    from: TweenParamValue | Array<TweenParamValue>;
    fromTo: TweenParamValue | Array<TweenParamValue>;
}>;
type PercentageKeyframeOptions = {
    ease?: EasingParam;
};
type PercentageKeyframeParams = Record<string, TweenParamValue>;
type PercentageKeyframes = Record<string, PercentageKeyframeParams & PercentageKeyframeOptions>;
type DurationKeyframes = Array<Record<string, TweenOptions | TweenModifier | boolean> & TweenParamsOptions>;
type AnimationOptions = {
    keyframes?: PercentageKeyframes | DurationKeyframes;
    playbackEase?: EasingParam;
};
type AnimationParams = Record<string, TweenOptions | Callback<JSAnimation> | TweenModifier | boolean | PercentageKeyframes | (Record<string, boolean | TweenModifier | TweenOptions> & TweenParamsOptions)[] | ScrollObserver> & TimerOptions & AnimationOptions & TweenParamsOptions & TickableCallbacks<JSAnimation> & RenderableCallbacks<JSAnimation>;
type TimelineOptions = {
    defaults?: DefaultsParams;
    playbackEase?: EasingParam;
};
type TimelineParams = TimerOptions & TimelineOptions & TickableCallbacks<Timeline> & RenderableCallbacks<Timeline>;
type AnimatablePropertySetter = (to: number | Array<number>, duration?: number, ease?: EasingParam) => AnimatableObject;
type AnimatablePropertyGetter = () => number | Array<number>;
type AnimatableProperty = AnimatablePropertySetter & AnimatablePropertyGetter;
type AnimatableObject = Animatable & Record<string, AnimatableProperty>;
type AnimatablePropertyParamsOptions = {
    unit?: string;
    duration?: TweenParamValue;
    ease?: EasingParam;
    modifier?: TweenModifier;
    composition?: TweenComposition;
};
type AnimatableParams = Record<string, TweenParamValue | EasingParam | TweenModifier | TweenComposition | AnimatablePropertyParamsOptions> & AnimatablePropertyParamsOptions;
declare class Draggable {
    constructor(target: TargetsParam, parameters?: DraggableParams);
    containerArray: number[];
    $container: HTMLElement;
    useWin: boolean;
    $scrollContainer: Window | HTMLElement;
    $target: HTMLElement;
    $trigger: HTMLElement;
    fixed: boolean;
    isFinePointer: boolean;
    containerPadding: [
        number,
        number,
        number,
        number
    ];
    containerFriction: number;
    releaseContainerFriction: number;
    snapX: number | Array<number>;
    snapY: number | Array<number>;
    scrollSpeed: number;
    scrollThreshold: number;
    dragSpeed: number;
    maxVelocity: number;
    minVelocity: number;
    velocityMultiplier: number;
    cursor: boolean | DraggableCursorParams;
    releaseXSpring: Spring;
    releaseYSpring: Spring;
    releaseEase: EasingFunction;
    hasReleaseSpring: boolean;
    onGrab: Callback<this>;
    onDrag: Callback<this>;
    onRelease: Callback<this>;
    onUpdate: Callback<this>;
    onSettle: Callback<this>;
    onSnap: Callback<this>;
    onResize: Callback<this>;
    onAfterResize: Callback<this>;
    disabled: [
        number,
        number
    ];
    animate: AnimatableObject;
    xProp: string;
    yProp: string;
    destX: number;
    destY: number;
    deltaX: number;
    deltaY: number;
    scroll: {
        x: number;
        y: number;
    };
    coords: [
        number,
        number,
        number,
        number
    ];
    snapped: [
        number,
        number
    ];
    pointer: [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
    ];
    scrollView: [
        number,
        number
    ];
    dragArea: [
        number,
        number,
        number,
        number
    ];
    containerBounds: [
        number,
        number,
        number,
        number
    ];
    scrollBounds: [
        number,
        number,
        number,
        number
    ];
    targetBounds: [
        number,
        number,
        number,
        number
    ];
    window: [
        number,
        number
    ];
    velocityStack: [
        number,
        number,
        number
    ];
    velocityStackIndex: number;
    velocityTime: number;
    velocity: number;
    angle: number;
    cursorStyles: JSAnimation;
    triggerStyles: JSAnimation;
    bodyStyles: JSAnimation;
    targetStyles: JSAnimation;
    touchActionStyles: JSAnimation;
    transforms: Transforms;
    overshootCoords: {
        x: number;
        y: number;
    };
    overshootXTicker: Timer;
    overshootYTicker: Timer;
    updateTicker: Timer;
    updated: boolean;
    manual: boolean;
    contained: boolean;
    grabbed: boolean;
    dragged: boolean;
    released: boolean;
    canScroll: boolean;
    enabled: boolean;
    initialized: boolean;
    activeProp: string;
    resizeTicker: Timer;
    parameters: DraggableParams;
    resizeObserver: ResizeObserver;
    computeVelocity(dx: number, dy: number): number;
    setX(x: number, muteUpdateCallback?: boolean): this;
    setY(y: number, muteUpdateCallback?: boolean): this;
    set x(arg: number);
    get x(): number;
    set y(arg: number);
    get y(): number;
    set progressX(arg: number);
    get progressX(): number;
    set progressY(arg: number);
    get progressY(): number;
    updateScrollCoords(): void;
    updateBoundingValues(): void;
    isOutOfBounds(bounds: any[], x: number, y: number): number;
    refresh(): void;
    update(): void;
    stop(): this;
    scrollInView(duration?: number, gap?: number, ease?: EasingParam): this;
    handleHover(): void;
    animateInView(duration?: number, gap?: number, ease?: EasingParam): this;
    handleDown(e: MouseEvent | TouchEvent): void;
    handleMove(e: MouseEvent | TouchEvent): void;
    handleUp(): void;
    reset(): this;
    enable(): this;
    disable(): this;
    revert(): this;
    handleEvent(e: Event): void;
}
declare function createDraggable(target: TargetsParam, parameters?: DraggableParams): Draggable;
type DraggableCursorParams = {
    onHover?: string;
    onGrab?: string;
};
type DraggableAxisParam = {
    mapTo?: string;
    modifier?: TweenModifier;
    composition?: TweenComposition;
    snap?: number | number[] | ((draggable: Draggable) => number | Array<number>);
};
type DraggableParams = {
    trigger?: DOMTargetSelector;
    container?: number[] | DOMTargetSelector | ((draggable: Draggable) => DOMTargetSelector | Array<number>);
    x?: boolean | DraggableAxisParam;
    y?: boolean | DraggableAxisParam;
    modifier?: TweenModifier;
    snap?: number | number[] | ((draggable: Draggable) => number | Array<number>);
    containerPadding?: number | number[] | ((draggable: Draggable) => number | Array<number>);
    containerFriction?: number | ((draggable: Draggable) => number);
    releaseContainerFriction?: number | ((draggable: Draggable) => number);
    dragSpeed?: number | ((draggable: Draggable) => number);
    scrollSpeed?: number | ((draggable: Draggable) => number);
    scrollThreshold?: number | ((draggable: Draggable) => number);
    minVelocity?: number | ((draggable: Draggable) => number);
    maxVelocity?: number | ((draggable: Draggable) => number);
    velocityMultiplier?: number | ((draggable: Draggable) => number);
    releaseMass?: number;
    releaseStiffness?: number;
    releaseDamping?: number;
    releaseEase?: EasingParam;
    cursor?: boolean | DraggableCursorParams | ((draggable: Draggable) => boolean | DraggableCursorParams);
    onGrab?: Callback<Draggable>;
    onDrag?: Callback<Draggable>;
    onRelease?: Callback<Draggable>;
    onUpdate?: Callback<Draggable>;
    onSettle?: Callback<Draggable>;
    onSnap?: Callback<Draggable>;
    onResize?: Callback<Draggable>;
    onAfterResize?: Callback<Draggable>;
};
declare class Transforms {
    constructor($el: DOMTarget | DOMProxy);
    $el: DOMTarget | DOMProxy;
    inlineTransforms: any[];
    point: DOMPoint;
    inversedMatrix: DOMMatrix;
    normalizePoint(x: number, y: number): DOMPoint;
    traverseUp(cb: ($el: DOMTarget, i: number) => any): void;
    getMatrix(): DOMMatrix;
    remove(): void;
    revert(): void;
}
declare class DOMProxy {
    constructor(el: any);
    el: any;
    zIndex: number;
    parentElement: any;
    classList: {
        add: () => void;
        remove: () => void;
    };
    set x(arg: any);
    get x(): any;
    set y(arg: any);
    get y(): any;
    set width(arg: any);
    get width(): any;
    set height(arg: any);
    get height(): any;
    getBoundingClientRect(): {
        top: any;
        right: any;
        bottom: any;
        left: any;
    };
}
declare class Scope {
    constructor(parameters?: ScopeParams);
    defaults: DefaultsParams;
    root: Document | DOMTarget;
    constructors: Array<ScopeConstructor>;
    revertConstructors: Array<Function>;
    revertibles: Array<Revertible>;
    methods: Record<string, Function>;
    matches: Record<string, boolean>;
    mediaQueryLists: Record<string, MediaQueryList>;
    data: Record<string, any>;
    execute(cb: (scope: this) => any): this;
    refresh(): this;
    add(a1: string, a2: ScopeMethod): this;
    add(a1: (self: this) => any): this;
    handleEvent(e: Event): void;
    revert(): void;
}
declare function createScope(params?: ScopeParams): Scope;
type ReactRef = {
    current?: HTMLElement | SVGElement | null;
};
type AngularRef = {
    nativeElement?: HTMLElement | SVGElement;
};
type ScopeParams = {
    root?: DOMTargetSelector | ReactRef | AngularRef;
    defaults?: DefaultsParams;
    mediaQueries?: Record<string, string>;
};
type ScopeCleanup = (scope?: Scope) => any;
type ScopeConstructor = (scope?: Scope) => ScopeCleanup | void;
type ScopeMethod = (...args: any[]) => ScopeCleanup | void;
declare const scrollContainers: Map<any, any>;
declare class ScrollObserver {
    constructor(parameters?: ScrollObserverParams);
    index: number;
    id: string | number;
    container: ScrollContainer;
    target: HTMLElement;
    linked: Tickable | WAAPIAnimation;
    repeat: boolean;
    horizontal: boolean;
    enter: ScrollThresholdParam | ScrollThresholdValue | ScrollThresholdCallback;
    leave: ScrollThresholdParam | ScrollThresholdValue | ScrollThresholdCallback;
    sync: boolean;
    syncEase: EasingFunction;
    syncSmooth: number;
    onSyncEnter: Callback<ScrollObserver>;
    onSyncLeave: Callback<ScrollObserver>;
    onSyncEnterForward: Callback<ScrollObserver>;
    onSyncLeaveForward: Callback<ScrollObserver>;
    onSyncEnterBackward: Callback<ScrollObserver>;
    onSyncLeaveBackward: Callback<ScrollObserver>;
    onEnter: Callback<ScrollObserver>;
    onLeave: Callback<ScrollObserver>;
    onEnterForward: Callback<ScrollObserver>;
    onLeaveForward: Callback<ScrollObserver>;
    onEnterBackward: Callback<ScrollObserver>;
    onLeaveBackward: Callback<ScrollObserver>;
    onUpdate: Callback<ScrollObserver>;
    onSyncComplete: Callback<ScrollObserver>;
    reverted: boolean;
    completed: boolean;
    began: boolean;
    isInView: boolean;
    forceEnter: boolean;
    hasEntered: boolean;
    offsets: Array<number>;
    offset: number;
    offsetStart: number;
    offsetEnd: number;
    distance: number;
    prevProgress: number;
    thresholds: any[];
    coords: [
        number,
        number,
        number,
        number
    ];
    debugStyles: JSAnimation;
    $debug: HTMLElement;
    _params: ScrollObserverParams;
    _debug: boolean;
    _next: ScrollObserver;
    _prev: ScrollObserver;
    link(linked: Tickable | WAAPIAnimation): this;
    get velocity(): number;
    get backward(): boolean;
    get scroll(): number;
    get progress(): number;
    refresh(): this;
    removeDebug(): this;
    debug(): void;
    updateBounds(): void;
    handleScroll(): void;
    revert(): this;
}
declare function onScroll(parameters?: ScrollObserverParams): ScrollObserver;
type ScrollThresholdValue = string | number;
type ScrollThresholdParam = {
    target?: ScrollThresholdValue;
    container?: ScrollThresholdValue;
};
type ScrollObserverAxisCallback = (self: ScrollObserver) => "x" | "y";
type ScrollThresholdCallback = (self: ScrollObserver) => ScrollThresholdValue | ScrollThresholdParam;
type ScrollObserverParams = {
    id?: number | string;
    sync?: boolean | number | string | EasingParam;
    container?: TargetsParam;
    target?: TargetsParam;
    axis?: "x" | "y" | ScrollObserverAxisCallback | ((observer: ScrollObserver) => "x" | "y" | ScrollObserverAxisCallback);
    enter?: ScrollThresholdParam | ScrollThresholdValue | ScrollThresholdCallback | ((observer: ScrollObserver) => ScrollThresholdValue | ScrollThresholdParam | ScrollThresholdCallback);
    leave?: ScrollThresholdParam | ScrollThresholdValue | ScrollThresholdCallback | ((observer: ScrollObserver) => ScrollThresholdValue | ScrollThresholdParam | ScrollThresholdCallback);
    repeat?: boolean | ((observer: ScrollObserver) => boolean);
    debug?: boolean;
    onEnter?: Callback<ScrollObserver>;
    onLeave?: Callback<ScrollObserver>;
    onEnterForward?: Callback<ScrollObserver>;
    onLeaveForward?: Callback<ScrollObserver>;
    onEnterBackward?: Callback<ScrollObserver>;
    onLeaveBackward?: Callback<ScrollObserver>;
    onUpdate?: Callback<ScrollObserver>;
    onSyncComplete?: Callback<ScrollObserver>;
};
declare class ScrollContainer {
    constructor($el: HTMLElement);
    element: HTMLElement;
    useWin: boolean;
    winWidth: number;
    winHeight: number;
    width: number;
    height: number;
    left: number;
    top: number;
    zIndex: number;
    scrollX: number;
    scrollY: number;
    prevScrollX: number;
    prevScrollY: number;
    scrollWidth: number;
    scrollHeight: number;
    velocity: number;
    backwardX: boolean;
    backwardY: boolean;
    scrollTicker: Timer;
    dataTimer: Timer;
    resizeTicker: Timer;
    wakeTicker: Timer;
    _head: ScrollObserver;
    _tail: ScrollObserver;
    resizeObserver: ResizeObserver;
    updateScrollCoords(): void;
    updateWindowBounds(): void;
    updateBounds(): void;
    refreshScrollObservers(): void;
    refresh(): void;
    handleScroll(): void;
    handleEvent(e: Event): void;
    revert(): void;
}
declare class Spring {
    constructor(parameters?: SpringParams);
    timeStep: number;
    restThreshold: number;
    restDuration: number;
    maxDuration: number;
    maxRestSteps: number;
    maxIterations: number;
    m: number;
    s: number;
    d: number;
    v: number;
    w0: number;
    zeta: number;
    wd: number;
    b: number;
    solverDuration: number;
    duration: number;
    ease: EasingFunction;
    solve(time: number): number;
    compute(): void;
    set mass(arg: number);
    get mass(): number;
    set stiffness(arg: number);
    get stiffness(): number;
    set damping(arg: number);
    get damping(): number;
    set velocity(arg: number);
    get velocity(): number;
}
declare function createSpring(parameters?: SpringParams): Spring;
type SpringParams = {
    mass?: number;
    stiffness?: number;
    damping?: number;
    velocity?: number;
};
declare class WAAPIAnimation {
    constructor(targets: DOMTargetsParam, params: WAAPIAnimationParams);
    targets: DOMTargetsArray;
    animations: Array<globalThis.Animation>;
    controlAnimation: globalThis.Animation;
    onComplete: Callback<this>;
    duration: number;
    muteCallbacks: boolean;
    completed: boolean;
    paused: boolean;
    reversed: boolean;
    autoplay: boolean | ScrollObserver;
    _speed: number;
    _resolve: Function;
    _completed: number;
    _inlineStyles: Array<any>;
    forEach(callback: string | ((animation: globalThis.Animation) => any)): this;
    set speed(arg: number);
    get speed(): number;
    set currentTime(arg: number);
    get currentTime(): number;
    set progress(arg: number);
    get progress(): number;
    resume(): this;
    pause(): this;
    alternate(): this;
    play(): this;
    reverse(): this;
    seek(time: number, muteCallbacks?: boolean): this;
    restart(): this;
    commitStyles(): this;
    complete(): this;
    cancel(): this;
    revert(): this;
    then(callback?: WAAPICallback): Promise<any>;
}
declare namespace waapi {
    export function animate(targets: DOMTargetsParam, params: WAAPIAnimationParams): WAAPIAnimation;
    export { easingToLinear as convertEase };
}
type WAAPITweenValue = string | number | Array<string> | Array<number>;
type WAAPIFunctionvalue = (target: DOMTarget, index: number, length: number) => WAAPITweenValue;
type WAAPIKeyframeValue = WAAPITweenValue | WAAPIFunctionvalue | Array<string | number | WAAPIFunctionvalue>;
type WAAPICallback = (animation: WAAPIAnimation) => void;
type WAAPITweenOptions = {
    to?: WAAPIKeyframeValue;
    from?: WAAPIKeyframeValue;
    duration?: number | WAAPIFunctionvalue;
    delay?: number | WAAPIFunctionvalue;
    ease?: EasingParam;
    composition?: CompositeOperation;
};
type WAAPIAnimationOptions = {
    loop?: number | boolean;
    Reversed?: boolean;
    Alternate?: boolean;
    autoplay?: boolean | ScrollObserver;
    playbackRate?: number;
    duration?: number | WAAPIFunctionvalue;
    delay?: number | WAAPIFunctionvalue;
    ease?: EasingParam;
    composition?: CompositeOperation;
    onComplete?: WAAPICallback;
};
type WAAPIAnimationParams = Record<string, WAAPIKeyframeValue | WAAPIAnimationOptions | boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions;
declare function easingToLinear(fn: EasingFunction, samples?: number): string;
export { engine, utils, svg, stagger, eases, DefaultsParams, Renderable, Tickable, CallbackArgument, Revertible, EasingFunction, EaseStringParamNames, EasingParam, DOMTarget, JSTarget, Target, TargetSelector, DOMTargetSelector, DOMTargetsParam, DOMTargetsArray, JSTargetsParam, JSTargetsArray, TargetsParam, TargetsArray, FunctionValue, TweenModifier, ColorArray, Callback, TickableCallbacks, RenderableCallbacks, Tween, TweenDecomposedValue, TweenPropertySiblings, TweenLookups, TweenReplaceLookups, TweenAdditiveLookups, TimerOptions, TimerParams, TweenParamValue, TweenPropValue, TweenComposition, TweenParamsOptions, TweenValues, TweenKeyValue, ArraySyntaxValue, TweenOptions, TweenObjectValue, PercentageKeyframeOptions, PercentageKeyframeParams, PercentageKeyframes, DurationKeyframes, AnimationOptions, AnimationParams, TimelineOptions, TimelineParams, AnimatablePropertySetter, AnimatablePropertyGetter, AnimatableProperty, AnimatableObject, AnimatablePropertyParamsOptions, AnimatableParams, createTimer, Timer, animate, JSAnimation, createTimeline, Timeline, createAnimatable, Animatable, createDraggable, Draggable, createScope, Scope, onScroll, ScrollObserver, scrollContainers, createSpring, Spring, waapi, WAAPIAnimation };



================================================
FILE: types/index.js
================================================
/**
 * anime.js - ESM
 * @version v4.0.1
 * @author Julian Garnier
 * @license MIT
 * @copyright (c) 2025 Julian Garnier
 * @see https://animejs.com
 */

// Environments
// TODO: Do we need to check if we're running inside a worker ?
const isBrowser = typeof window !== 'undefined';
/** @type {Object|Null} */
const win = isBrowser ? window : null;
/** @type {Document} */
const doc = isBrowser ? document : null;
// Enums
/** @enum {Number} */
const tweenTypes = {
    OBJECT: 0,
    ATTRIBUTE: 1,
    CSS: 2,
    TRANSFORM: 3,
    CSS_VAR: 4,
};
/** @enum {Number} */
const valueTypes = {
    NUMBER: 0,
    UNIT: 1,
    COLOR: 2,
    COMPLEX: 3,
};
/** @enum {Number} */
const tickModes = {
    NONE: 0,
    AUTO: 1,
    FORCE: 2,
};
/** @enum {Number} */
const compositionTypes = {
    replace: 0,
    none: 1,
    blend: 2,
};
// Cache symbols
const isRegisteredTargetSymbol = Symbol();
const isDomSymbol = Symbol();
const isSvgSymbol = Symbol();
const transformsSymbol = Symbol();
const morphPointsSymbol = Symbol();
const proxyTargetSymbol = Symbol();
// Numbers
const minValue = 1e-11;
const maxValue = 1e12;
const K = 1e3;
const maxFps = 120;
// Strings
const emptyString = '';
const shortTransforms = new Map();
shortTransforms.set('x', 'translateX');
shortTransforms.set('y', 'translateY');
shortTransforms.set('z', 'translateZ');
const validTransforms = [
    'translateX',
    'translateY',
    'translateZ',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'scale',
    'scaleX',
    'scaleY',
    'scaleZ',
    'skew',
    'skewX',
    'skewY',
    'perspective',
    'matrix',
    'matrix3d',
];
const transformsFragmentStrings = validTransforms.reduce((a, v) => ({ ...a, [v]: v + '(' }), {});
// Functions
/** @return {void} */
const noop = () => { };
// Regex
const hexTestRgx = /(^#([\da-f]{3}){1,2}$)|(^#([\da-f]{4}){1,2}$)/i;
const rgbExecRgx = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i;
const rgbaExecRgx = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
const hslExecRgx = /hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)/i;
const hslaExecRgx = /hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)/i;
// export const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g;
const digitWithExponentRgx = /[-+]?\d*\.?\d+(?:e[-+]?\d)?/gi;
// export const unitsExecRgx = /^([-+]?\d*\.?\d+(?:[eE][-+]?\d+)?)+([a-z]+|%)$/i;
const unitsExecRgx = /^([-+]?\d*\.?\d+(?:e[-+]?\d+)?)([a-z]+|%)$/i;
const lowerCaseRgx = /([a-z])([A-Z])/g;
const transformsExecRgx = /(\w+)(\([^)]+\)+)/g; // Match inline transforms with cacl() values, returns the value wrapped in ()
const relativeValuesExecRgx = /(\*=|\+=|-=)/;


/** @type {DefaultsParams} */
const defaults = {
    id: null,
    keyframes: null,
    playbackEase: null,
    playbackRate: 1,
    frameRate: maxFps,
    loop: 0,
    reversed: false,
    alternate: false,
    autoplay: true,
    duration: K,
    delay: 0,
    loopDelay: 0,
    ease: 'out(2)',
    composition: compositionTypes.replace,
    modifier: v => v,
    onBegin: noop,
    onBeforeUpdate: noop,
    onUpdate: noop,
    onLoop: noop,
    onPause: noop,
    onComplete: noop,
    onRender: noop,
};
const globals = {
    /** @type {DefaultsParams} */
    defaults,
    /** @type {Document|DOMTarget} */
    root: doc,
    /** @type {Scope} */
    scope: null,
    /** @type {Number} */
    precision: 4,
    /** @type {Number} */
    timeScale: 1,
    /** @type {Number} */
    tickThreshold: 200,
};
const globalVersions = { version: '4.0.1', engine: null };
if (isBrowser) {
    if (!win.AnimeJS)
        win.AnimeJS = [];
    win.AnimeJS.push(globalVersions);
}

// Strings
/**
 * @param  {String} str
 * @return {String}
 */
const toLowerCase = str => str.replace(lowerCaseRgx, '$1-$2').toLowerCase();
/**
 * Prioritize this method instead of regex when possible
 * @param  {String} str
 * @param  {String} sub
 * @return {Boolean}
 */
const stringStartsWith = (str, sub) => str.indexOf(sub) === 0;
// Time
// Note: Date.now is used instead of performance.now since it is precise enough for timings calculations, performs slightly faster and works in Node.js environement.
const now = Date.now;
// Types checkers
const isArr = Array.isArray;
/**@param {any} a @return {a is Record<String, any>} */
const isObj = a => a && a.constructor === Object;
/**@param {any} a @return {a is Number} */
const isNum = a => typeof a === 'number' && !isNaN(a);
/**@param {any} a @return {a is String} */
const isStr = a => typeof a === 'string';
/**@param {any} a @return {a is Function} */
const isFnc = a => typeof a === 'function';
/**@param {any} a @return {a is undefined} */
const isUnd = a => typeof a === 'undefined';
/**@param {any} a @return {a is null | undefined} */
const isNil = a => isUnd(a) || a === null;
/**@param {any} a @return {a is SVGElement} */
const isSvg = a => isBrowser && a instanceof SVGElement;
/**@param {any} a @return {Boolean} */
const isHex = a => hexTestRgx.test(a);
/**@param {any} a @return {Boolean} */
const isRgb = a => stringStartsWith(a, 'rgb');
/**@param {any} a @return {Boolean} */
const isHsl = a => stringStartsWith(a, 'hsl');
/**@param {any} a @return {Boolean} */
const isCol = a => isHex(a) || isRgb(a) || isHsl(a);
/**@param {any} a @return {Boolean} */
const isKey = a => !globals.defaults.hasOwnProperty(a);
// Number
/**
 * @param  {Number|String} str
 * @return {Number}
 */
const parseNumber = str => isStr(str) ?
    parseFloat(/** @type {String} */ (str)) :
    /** @type {Number} */ (str);
// Math
const pow = Math.pow;
const sqrt = Math.sqrt;
const sin = Math.sin;
const cos = Math.cos;
const abs = Math.abs;
const exp = Math.exp;
const ceil = Math.ceil;
const floor = Math.floor;
const asin = Math.asin;
const max = Math.max;
const atan2 = Math.atan2;
const PI = Math.PI;
const _round = Math.round;
/**
 * @param  {Number} v
 * @param  {Number} min
 * @param  {Number} max
 * @return {Number}
 */
const clamp = (v, min, max) => v < min ? min : v > max ? max : v;
const powCache = {};
/**
 * @param  {Number} v
 * @param  {Number} decimalLength
 * @return {Number}
 */
const round = (v, decimalLength) => {
    if (decimalLength < 0)
        return v;
    if (!decimalLength)
        return _round(v);
    let p = powCache[decimalLength];
    if (!p)
        p = powCache[decimalLength] = 10 ** decimalLength;
    return _round(v * p) / p;
};
/**
 * @param  {Number} v
 * @param  {Number|Array<Number>} increment
 * @return {Number}
 */
const snap = (v, increment) => isArr(increment) ? increment.reduce((closest, cv) => (abs(cv - v) < abs(closest - v) ? cv : closest)) : increment ? _round(v / increment) * increment : v;
/**
 * @param  {Number} start
 * @param  {Number} end
 * @param  {Number} progress
 * @return {Number}
 */
const interpolate = (start, end, progress) => start + (end - start) * progress;
/**
 * @param  {Number} v
 * @return {Number}
 */
const clampInfinity = v => v === Infinity ? maxValue : v === -Infinity ? -1e12 : v;
/**
 * @param  {Number} v
 * @return {Number}
 */
const clampZero = v => v < minValue ? minValue : v;
// Arrays
/**
 * @template T
 * @param {T[]} a
 * @return {T[]}
 */
const cloneArray = a => isArr(a) ? [...a] : a;
// Objects
/**
 * @template T
 * @template U
 * @param {T} o1
 * @param {U} o2
 * @return {T & U}
 */
const mergeObjects = (o1, o2) => {
    const merged = /** @type {T & U} */ ({ ...o1 });
    for (let p in o2) {
        const o1p = /** @type {T & U} */ (o1)[p];
        merged[p] = isUnd(o1p) ? /** @type {T & U} */ (o2)[p] : o1p;
    }
    return merged;
};
// Linked lists
/**
 * @param {Object} parent
 * @param {Function} callback
 * @param {Boolean} [reverse]
 * @param {String} [prevProp]
 * @param {String} [nextProp]
 * @return {void}
 */
const forEachChildren = (parent, callback, reverse, prevProp = '_prev', nextProp = '_next') => {
    let next = parent._head;
    let adjustedNextProp = nextProp;
    if (reverse) {
        next = parent._tail;
        adjustedNextProp = prevProp;
    }
    while (next) {
        const currentNext = next[adjustedNextProp];
        callback(next);
        next = currentNext;
    }
};
/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {String} [prevProp]
 * @param  {String} [nextProp]
 * @return {void}
 */
const removeChild = (parent, child, prevProp = '_prev', nextProp = '_next') => {
    const prev = child[prevProp];
    const next = child[nextProp];
    prev ? prev[nextProp] = next : parent._head = next;
    next ? next[prevProp] = prev : parent._tail = prev;
    child[prevProp] = null;
    child[nextProp] = null;
};
/**
 * @param  {Object} parent
 * @param  {Object} child
 * @param  {Function} [sortMethod]
 * @param  {String} prevProp
 * @param  {String} nextProp
 * @return {void}
 */
const addChild = (parent, child, sortMethod, prevProp = '_prev', nextProp = '_next') => {
    let prev = parent._tail;
    while (prev && sortMethod && sortMethod(prev, child))
        prev = prev[prevProp];
    const next = prev ? prev[nextProp] : parent._head;
    prev ? prev[nextProp] = child : parent._head = child;
    next ? next[prevProp] = child : parent._tail = child;
    child[prevProp] = prev;
    child[nextProp] = next;
};

/*
 * Base class to control framerate and playback rate.
 * Inherited by Engine, Timer, Animation and Timeline.
 */
class Clock {
    /** @param {Number} [initTime] */
    constructor(initTime = 0) {
        /** @type {Number} */
        this.deltaTime = 0;
        /** @type {Number} */
        this._currentTime = initTime;
        /** @type {Number} */
        this._elapsedTime = initTime;
        /** @type {Number} */
        this._startTime = initTime;
        /** @type {Number} */
        this._lastTime = initTime;
        /** @type {Number} */
        this._scheduledTime = 0;
        /** @type {Number} */
        this._frameDuration = round(K / maxFps, 0);
        /** @type {Number} */
        this._fps = maxFps;
        /** @type {Number} */
        this._speed = 1;
        /** @type {Boolean} */
        this._hasChildren = false;
        /** @type {Tickable|Tween} */
        this._head = null;
        /** @type {Tickable|Tween} */
        this._tail = null;
    }
    get fps() {
        return this._fps;
    }
    set fps(frameRate) {
        const previousFrameDuration = this._frameDuration;
        const fr = +frameRate;
        const fps = fr < minValue ? minValue : fr;
        const frameDuration = round(K / fps, 0);
        this._fps = fps;
        this._frameDuration = frameDuration;
        this._scheduledTime += frameDuration - previousFrameDuration;
    }
    get speed() {
        return this._speed;
    }
    set speed(playbackRate) {
        const pbr = +playbackRate;
        this._speed = pbr < minValue ? minValue : pbr;
    }
    /**
     * @param  {Number} time
     * @return {tickModes}
     */
    requestTick(time) {
        const scheduledTime = this._scheduledTime;
        const elapsedTime = this._elapsedTime;
        this._elapsedTime += (time - elapsedTime);
        // If the elapsed time is lower than the scheduled time
        // this means not enough time has passed to hit one frameDuration
        // so skip that frame
        if (elapsedTime < scheduledTime)
            return tickModes.NONE;
        const frameDuration = this._frameDuration;
        const frameDelta = elapsedTime - scheduledTime;
        // Ensures that _scheduledTime progresses in steps of at least 1 frameDuration.
        // Skips ahead if the actual elapsed time is higher.
        this._scheduledTime += frameDelta < frameDuration ? frameDuration : frameDelta;
        return tickModes.AUTO;
    }
    /**
     * @param  {Number} time
     * @return {Number}
     */
    computeDeltaTime(time) {
        const delta = time - this._lastTime;
        this.deltaTime = delta;
        this._lastTime = time;
        return delta;
    }
}


/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {tickModes} tickMode
 * @return {Number}
 */
const render = (tickable, time, muteCallbacks, internalRender, tickMode) => {
    const parent = tickable.parent;
    const duration = tickable.duration;
    const completed = tickable.completed;
    const iterationDuration = tickable.iterationDuration;
    const iterationCount = tickable.iterationCount;
    const _currentIteration = tickable._currentIteration;
    const _loopDelay = tickable._loopDelay;
    const _reversed = tickable._reversed;
    const _alternate = tickable._alternate;
    const _hasChildren = tickable._hasChildren;
    const tickableDelay = tickable._delay;
    const tickablePrevAbsoluteTime = tickable._currentTime; // TODO: rename ._currentTime to ._absoluteCurrentTime
    const tickableEndTime = tickableDelay + iterationDuration;
    const tickableAbsoluteTime = time - tickableDelay;
    const tickablePrevTime = clamp(tickablePrevAbsoluteTime, -tickableDelay, duration);
    const tickableCurrentTime = clamp(tickableAbsoluteTime, -tickableDelay, duration);
    const deltaTime = tickableAbsoluteTime - tickablePrevAbsoluteTime;
    const isCurrentTimeAboveZero = tickableCurrentTime > 0;
    const isCurrentTimeEqualOrAboveDuration = tickableCurrentTime >= duration;
    const isSetter = duration <= minValue;
    const forcedTick = tickMode === tickModes.FORCE;
    let isOdd = 0;
    let iterationElapsedTime = tickableAbsoluteTime;
    // Render checks
    // Used to also check if the children have rendered in order to trigger the onRender callback on the parent timer
    let hasRendered = 0;
    // Execute the "expensive" iterations calculations only when necessary
    if (iterationCount > 1) {
        // bitwise NOT operator seems to be generally faster than Math.floor() across browsers
        const currentIteration = ~~(tickableCurrentTime / (iterationDuration + (isCurrentTimeEqualOrAboveDuration ? 0 : _loopDelay)));
        tickable._currentIteration = clamp(currentIteration, 0, iterationCount);
        // Prevent the iteration count to go above the max iterations when reaching the end of the animation
        if (isCurrentTimeEqualOrAboveDuration)
            tickable._currentIteration--;
        isOdd = tickable._currentIteration % 2;
        iterationElapsedTime = tickableCurrentTime % (iterationDuration + _loopDelay) || 0;
    }
    // Checks if exactly one of _reversed and (_alternate && isOdd) is true
    const isReversed = _reversed ^ (_alternate && isOdd);
    const _ease = /** @type {Renderable} */ (tickable)._ease;
    let iterationTime = isCurrentTimeEqualOrAboveDuration ? isReversed ? 0 : duration : isReversed ? iterationDuration - iterationElapsedTime : iterationElapsedTime;
    if (_ease)
        iterationTime = iterationDuration * _ease(iterationTime / iterationDuration) || 0;
    const isRunningBackwards = (parent ? parent.backwards : tickableAbsoluteTime < tickablePrevAbsoluteTime) ? !isReversed : !!isReversed;
    tickable._currentTime = tickableAbsoluteTime;
    tickable._iterationTime = iterationTime;
    tickable.backwards = isRunningBackwards;
    if (isCurrentTimeAboveZero && !tickable.began) {
        tickable.began = true;
        if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
            tickable.onBegin(/** @type {CallbackArgument} */ (tickable));
        }
    }
    else if (tickableAbsoluteTime <= 0) {
        tickable.began = false;
    }
    // Only triggers onLoop for tickable without children, otherwise call the the onLoop callback in the tick function
    // Make sure to trigger the onLoop before rendering to allow .refresh() to pickup the current values
    if (!muteCallbacks && !_hasChildren && isCurrentTimeAboveZero && tickable._currentIteration !== _currentIteration) {
        tickable.onLoop(/** @type {CallbackArgument} */ (tickable));
    }
    if (forcedTick ||
        tickMode === tickModes.AUTO && (time >= tickableDelay && time <= tickableEndTime || // Normal render
            time <= tickableDelay && tickablePrevTime > tickableDelay || // Playhead is before the animation start time so make sure the animation is at its initial state
            time >= tickableEndTime && tickablePrevTime !== duration // Playhead is after the animation end time so make sure the animation is at its end state
        ) ||
        iterationTime >= tickableEndTime && tickablePrevTime !== duration ||
        iterationTime <= tickableDelay && tickablePrevTime > 0 ||
        time <= tickablePrevTime && tickablePrevTime === duration && completed || // Force a render if a seek occurs on an completed animation
        isCurrentTimeEqualOrAboveDuration && !completed && isSetter // This prevents 0 duration tickables to be skipped
    ) {
        if (isCurrentTimeAboveZero) {
            // Trigger onUpdate callback before rendering
            tickable.computeDeltaTime(tickablePrevTime);
            if (!muteCallbacks)
                tickable.onBeforeUpdate(/** @type {CallbackArgument} */ (tickable));
        }
        // Start tweens rendering
        if (!_hasChildren) {
            // Time has jumped more than globals.tickThreshold so consider this tick manual
            const forcedRender = forcedTick || (isRunningBackwards ? deltaTime * -1 : deltaTime) >= globals.tickThreshold;
            const absoluteTime = tickable._offset + (parent ? parent._offset : 0) + tickableDelay + iterationTime;
            // Only Animation can have tweens, Timer returns undefined
            let tween = /** @type {Tween} */ ( /** @type {JSAnimation} */(tickable)._head);
            let tweenTarget;
            let tweenStyle;
            let tweenTargetTransforms;
            let tweenTargetTransformsProperties;
            let tweenTransformsNeedUpdate = 0;
            while (tween) {
                const tweenComposition = tween._composition;
                const tweenCurrentTime = tween._currentTime;
                const tweenChangeDuration = tween._changeDuration;
                const tweenAbsEndTime = tween._absoluteStartTime + tween._changeDuration;
                const tweenNextRep = tween._nextRep;
                const tweenPrevRep = tween._prevRep;
                const tweenHasComposition = tweenComposition !== compositionTypes.none;
                if ((forcedRender || ((tweenCurrentTime !== tweenChangeDuration || absoluteTime <= tweenAbsEndTime + (tweenNextRep ? tweenNextRep._delay : 0)) &&
                    (tweenCurrentTime !== 0 || absoluteTime >= tween._absoluteStartTime))) && (!tweenHasComposition || (!tween._isOverridden &&
                    (!tween._isOverlapped || absoluteTime <= tweenAbsEndTime) &&
                    (!tweenNextRep || (tweenNextRep._isOverridden || absoluteTime <= tweenNextRep._absoluteStartTime)) &&
                    (!tweenPrevRep || (tweenPrevRep._isOverridden || (absoluteTime >= (tweenPrevRep._absoluteStartTime + tweenPrevRep._changeDuration) + tween._delay)))))) {
                    const tweenNewTime = tween._currentTime = clamp(iterationTime - tween._startTime, 0, tweenChangeDuration);
                    const tweenProgress = tween._ease(tweenNewTime / tween._updateDuration);
                    const tweenModifier = tween._modifier;
                    const tweenValueType = tween._valueType;
                    const tweenType = tween._tweenType;
                    const tweenIsObject = tweenType === tweenTypes.OBJECT;
                    const tweenIsNumber = tweenValueType === valueTypes.NUMBER;
                    // Only round the in-between frames values if the final value is a string
                    const tweenPrecision = (tweenIsNumber && tweenIsObject) || tweenProgress === 0 || tweenProgress === 1 ? -1 : globals.precision;
                    // Recompose tween value
                    /** @type {String|Number} */
                    let value;
                    /** @type {Number} */
                    let number;
                    if (tweenIsNumber) {
                        value = number = /** @type {Number} */ (tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision)));
                    }
                    else if (tweenValueType === valueTypes.UNIT) {
                        // Rounding the values speed up string composition
                        number = /** @type {Number} */ (tweenModifier(round(interpolate(tween._fromNumber, tween._toNumber, tweenProgress), tweenPrecision)));
                        value = `${number}${tween._unit}`;
                    }
                    else if (tweenValueType === valueTypes.COLOR) {
                        const fn = tween._fromNumbers;
                        const tn = tween._toNumbers;
                        const r = round(clamp(/** @type {Number} */ (tweenModifier(interpolate(fn[0], tn[0], tweenProgress))), 0, 255), 0);
                        const g = round(clamp(/** @type {Number} */ (tweenModifier(interpolate(fn[1], tn[1], tweenProgress))), 0, 255), 0);
                        const b = round(clamp(/** @type {Number} */ (tweenModifier(interpolate(fn[2], tn[2], tweenProgress))), 0, 255), 0);
                        const a = clamp(/** @type {Number} */ (tweenModifier(round(interpolate(fn[3], tn[3], tweenProgress), tweenPrecision))), 0, 1);
                        value = `rgba(${r},${g},${b},${a})`;
                        if (tweenHasComposition) {
                            const ns = tween._numbers;
                            ns[0] = r;
                            ns[1] = g;
                            ns[2] = b;
                            ns[3] = a;
                        }
                    }
                    else if (tweenValueType === valueTypes.COMPLEX) {
                        value = tween._strings[0];
                        for (let j = 0, l = tween._toNumbers.length; j < l; j++) {
                            const n = /** @type {Number} */ (tweenModifier(round(interpolate(tween._fromNumbers[j], tween._toNumbers[j], tweenProgress), tweenPrecision)));
                            const s = tween._strings[j + 1];
                            value += `${s ? n + s : n}`;
                            if (tweenHasComposition) {
                                tween._numbers[j] = n;
                            }
                        }
                    }
                    // For additive tweens and Animatables
                    if (tweenHasComposition) {
                        tween._number = number;
                    }
                    if (!internalRender && tweenComposition !== compositionTypes.blend) {
                        const tweenProperty = tween.property;
                        tweenTarget = tween.target;
                        if (tweenIsObject) {
                            tweenTarget[tweenProperty] = value;
                        }
                        else if (tweenType === tweenTypes.ATTRIBUTE) {
                            /** @type {DOMTarget} */ (tweenTarget).setAttribute(tweenProperty, /** @type {String} */ (value));
                        }
                        else {
                            tweenStyle = /** @type {DOMTarget} */ (tweenTarget).style;
                            if (tweenType === tweenTypes.TRANSFORM) {
                                if (tweenTarget !== tweenTargetTransforms) {
                                    tweenTargetTransforms = tweenTarget;
                                    // NOTE: Referencing the cachedTransforms in the tween property directly can be a little bit faster but appears to increase memory usage.
                                    tweenTargetTransformsProperties = tweenTarget[transformsSymbol];
                                }
                                tweenTargetTransformsProperties[tweenProperty] = value;
                                tweenTransformsNeedUpdate = 1;
                            }
                            else if (tweenType === tweenTypes.CSS) {
                                tweenStyle[tweenProperty] = value;
                            }
                            else if (tweenType === tweenTypes.CSS_VAR) {
                                tweenStyle.setProperty(tweenProperty, /** @type {String} */ (value));
                            }
                        }
                        if (isCurrentTimeAboveZero)
                            hasRendered = 1;
                    }
                    else {
                        // Used for composing timeline tweens without having to do a real render
                        tween._value = value;
                    }
                }
                // NOTE: Possible improvement: Use translate(x,y) / translate3d(x,y,z) syntax
                // to reduce memory usage on string composition
                if (tweenTransformsNeedUpdate && tween._renderTransforms) {
                    let str = emptyString;
                    for (let key in tweenTargetTransformsProperties) {
                        str += `${transformsFragmentStrings[key]}${tweenTargetTransformsProperties[key]}) `;
                    }
                    tweenStyle.transform = str;
                    tweenTransformsNeedUpdate = 0;
                }
                tween = tween._next;
            }
            if (!muteCallbacks && hasRendered) {
                /** @type {JSAnimation} */ (tickable).onRender(/** @type {JSAnimation} */ (tickable));
            }
        }
        if (!muteCallbacks && isCurrentTimeAboveZero) {
            tickable.onUpdate(/** @type {CallbackArgument} */ (tickable));
        }
    }
    // End tweens rendering
    // Handle setters on timeline differently and allow re-trigering the onComplete callback when seeking backwards
    if (parent && isSetter) {
        if (!muteCallbacks && ((parent.began && !isRunningBackwards && tickableAbsoluteTime >= duration && !completed) ||
            (isRunningBackwards && tickableAbsoluteTime <= minValue && completed))) {
            tickable.onComplete(/** @type {CallbackArgument} */ (tickable));
            tickable.completed = !isRunningBackwards;
        }
        // If currentTime is both above 0 and at least equals to duration, handles normal onComplete or infinite loops
    }
    else if (isCurrentTimeAboveZero && isCurrentTimeEqualOrAboveDuration) {
        if (iterationCount === Infinity) {
            // Offset the tickable _startTime with its duration to reset _currentTime to 0 and continue the infinite timer
            tickable._startTime += tickable.duration;
        }
        else if (tickable._currentIteration >= iterationCount - 1) {
            // By setting paused to true, we tell the engine loop to not render this tickable and removes it from the list on the next tick
            tickable.paused = true;
            if (!completed && !_hasChildren) {
                // If the tickable has children, triggers onComplete() only when all children have completed in the tick function
                tickable.completed = true;
                if (!muteCallbacks && !(parent && (isRunningBackwards || !parent.began))) {
                    tickable.onComplete(/** @type {CallbackArgument} */ (tickable));
                    tickable._resolve(/** @type {CallbackArgument} */ (tickable));
                }
            }
        }
        // Otherwise set the completed flag to false
    }
    else {
        tickable.completed = false;
    }
    // NOTE: hasRendered * direction (negative for backwards) this way we can remove the tickable.backwards property completly ?
    return hasRendered;
};
/**
 * @param  {Tickable} tickable
 * @param  {Number} time
 * @param  {Number} muteCallbacks
 * @param  {Number} internalRender
 * @param  {Number} tickMode
 * @return {void}
 */
const tick = (tickable, time, muteCallbacks, internalRender, tickMode) => {
    const _currentIteration = tickable._currentIteration;
    render(tickable, time, muteCallbacks, internalRender, tickMode);
    if (tickable._hasChildren) {
        const tl = /** @type {Timeline} */ (tickable);
        const tlIsRunningBackwards = tl.backwards;
        const tlChildrenTime = internalRender ? time : tl._iterationTime;
        const tlCildrenTickTime = now();
        let tlChildrenHasRendered = 0;
        let tlChildrenHaveCompleted = true;
        // If the timeline has looped forward, we need to manually triggers children skipped callbacks
        if (!internalRender && tl._currentIteration !== _currentIteration) {
            const tlIterationDuration = tl.iterationDuration;
            forEachChildren(tl, (/** @type {JSAnimation} */ child) => {
                if (!tlIsRunningBackwards) {
                    // Force an internal render to trigger the callbacks if the child has not completed on loop
                    if (!child.completed && !child.backwards && child._currentTime < child.iterationDuration) {
                        render(child, tlIterationDuration, muteCallbacks, 1, tickModes.FORCE);
                    }
                    // Reset their began and completed flags to allow retrigering callbacks on the next iteration
                    child.began = false;
                    child.completed = false;
                }
                else {
                    const childDuration = child.duration;
                    const childStartTime = child._offset + child._delay;
                    const childEndTime = childStartTime + childDuration;
                    // Triggers the onComplete callback on reverse for children on the edges of the timeline
                    if (!muteCallbacks && childDuration <= minValue && (!childStartTime || childEndTime === tlIterationDuration)) {
                        child.onComplete(child);
                    }
                }
            });
            if (!muteCallbacks)
                tl.onLoop(/** @type {CallbackArgument} */ (tl));
        }
        forEachChildren(tl, (/** @type {JSAnimation} */ child) => {
            const childTime = round((tlChildrenTime - child._offset) * child._speed, 12); // Rounding is needed when using seconds
            const childTickMode = child._fps < tl._fps ? child.requestTick(tlCildrenTickTime) : tickMode;
            tlChildrenHasRendered += render(child, childTime, muteCallbacks, internalRender, childTickMode);
            if (!child.completed && tlChildrenHaveCompleted)
                tlChildrenHaveCompleted = false;
        }, tlIsRunningBackwards);
        // Renders on timeline are triggered by its children so it needs to be set after rendering the children
        if (!muteCallbacks && tlChildrenHasRendered)
            tl.onRender(/** @type {CallbackArgument} */ (tl));
        // Triggers the timeline onComplete() once all chindren all completed and the current time has reached the end
        if (tlChildrenHaveCompleted && tl._currentTime >= tl.duration) {
            // Make sure the paused flag is false in case it has been skipped in the render function
            tl.paused = true;
            if (!tl.completed) {
                tl.completed = true;
                if (!muteCallbacks) {
                    tl.onComplete(/** @type {CallbackArgument} */ (tl));
                    tl._resolve(/** @type {CallbackArgument} */ (tl));
                }
            }
        }
    }
};


const additive = {
    animation: null,
    update: noop,
};
/**
 * @typedef AdditiveAnimation
 * @property {Number} duration
 * @property {Number} _offset
 * @property {Number} _delay
 * @property {Tween} _head
 * @property {Tween} _tail
 */
/**
 * @param  {TweenAdditiveLookups} lookups
 * @return {AdditiveAnimation}
 */
const addAdditiveAnimation = lookups => {
    let animation = additive.animation;
    if (!animation) {
        animation = {
            duration: minValue,
            computeDeltaTime: noop,
            _offset: 0,
            _delay: 0,
            _head: null,
            _tail: null,
        };
        additive.animation = animation;
        additive.update = () => {
            lookups.forEach(propertyAnimation => {
                for (let propertyName in propertyAnimation) {
                    const tweens = propertyAnimation[propertyName];
                    const lookupTween = tweens._head;
                    if (lookupTween) {
                        const valueType = lookupTween._valueType;
                        const additiveValues = valueType === valueTypes.COMPLEX || valueType === valueTypes.COLOR ? cloneArray(lookupTween._fromNumbers) : null;
                        let additiveValue = lookupTween._fromNumber;
                        let tween = tweens._tail;
                        while (tween && tween !== lookupTween) {
                            if (additiveValues) {
                                for (let i = 0, l = tween._numbers.length; i < l; i++)
                                    additiveValues[i] += tween._numbers[i];
                            }
                            else {
                                additiveValue += tween._number;
                            }
                            tween = tween._prevAdd;
                        }
                        lookupTween._toNumber = additiveValue;
                        lookupTween._toNumbers = additiveValues;
                    }
                }
            });
            // TODO: Avoid polymorphism here, idealy the additive animation should be a regular animation with a higher priority in the render loop
            render(animation, 1, 1, 0, tickModes.FORCE);
        };
    }
    return animation;
};

const engineTickMethod = isBrowser ? requestAnimationFrame : setImmediate;
const engineCancelMethod = isBrowser ? cancelAnimationFrame : clearImmediate;
class Engine extends Clock {
    /** @param {Number} [initTime] */
    constructor(initTime) {
        super(initTime);
        this.useDefaultMainLoop = true;
        this.pauseOnDocumentHidden = true;
        /** @type {DefaultsParams} */
        this.defaults = defaults;
        this.paused = isBrowser && doc.hidden ? true : false;
        /** @type {Number|NodeJS.Immediate} */
        this.reqId = null;
    }
    update() {
        const time = this._currentTime = now();
        if (this.requestTick(time)) {
            this.computeDeltaTime(time);
            const engineSpeed = this._speed;
            const engineFps = this._fps;
            let activeTickable = /** @type {Tickable} */ (this._head);
            while (activeTickable) {
                const nextTickable = activeTickable._next;
                if (!activeTickable.paused) {
                    tick(activeTickable, (time - activeTickable._startTime) * activeTickable._speed * engineSpeed, 0, // !muteCallbacks
                    0, // !internalRender
                    activeTickable._fps < engineFps ? activeTickable.requestTick(time) : tickModes.AUTO);
                }
                else {
                    removeChild(this, activeTickable);
                    this._hasChildren = !!this._tail;
                    activeTickable._running = false;
                    if (activeTickable.completed && !activeTickable._cancelled) {
                        activeTickable.cancel();
                    }
                }
                activeTickable = nextTickable;
            }
            additive.update();
        }
    }
    wake() {
        if (this.useDefaultMainLoop && !this.reqId && !this.paused) {
            this.reqId = engineTickMethod(tickEngine);
        }
        return this;
    }
    pause() {
        this.paused = true;
        return killEngine();
    }
    resume() {
        if (!this.paused)
            return;
        this.paused = false;
        forEachChildren(this, (/** @type {Tickable} */ child) => child.resetTime());
        return this.wake();
    }
    // Getter and setter for speed
    get speed() {
        return this._speed * (globals.timeScale === 1 ? 1 : K);
    }
    set speed(playbackRate) {
        this._speed = playbackRate * globals.timeScale;
        forEachChildren(this, (/** @type {Tickable} */ child) => child.speed = child._speed);
    }
    // Getter and setter for timeUnit
    get timeUnit() {
        return globals.timeScale === 1 ? 'ms' : 's';
    }
    ;
    set timeUnit(unit) {
        const secondsScale = 0.001;
        const isSecond = unit === 's';
        const newScale = isSecond ? secondsScale : 1;
        if (globals.timeScale !== newScale) {
            globals.timeScale = newScale;
            globals.tickThreshold = 200 * newScale;
            const scaleFactor = isSecond ? secondsScale : K;
            /** @type {Number} */
            (this.defaults.duration) *= scaleFactor;
            this._speed *= scaleFactor;
        }
    }
    // Getter and setter for precision
    get precision() {
        return globals.precision;
    }
    set precision(precision) {
        globals.precision = precision;
    }
}
const engine = /*#__PURE__*/ (() => {
    const engine = new Engine(now());
    if (isBrowser) {
        globalVersions.engine = engine;
        doc.addEventListener('visibilitychange', () => {
            if (!engine.pauseOnDocumentHidden)
                return;
            doc.hidden ? engine.pause() : engine.resume();
        });
    }
    return engine;
})();
const tickEngine = () => {
    if (engine._head) {
        engine.reqId = engineTickMethod(tickEngine);
        engine.update();
    }
    else {
        engine.reqId = 0;
    }
};
const killEngine = () => {
    engineCancelMethod(/** @type {NodeJS.Immediate & Number} */ (engine.reqId));
    engine.reqId = 0;
    return engine;
};


/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
const parseInlineTransforms = (target, propName, animationInlineStyles) => {
    const inlineTransforms = target.style.transform;
    let inlinedStylesPropertyValue;
    if (inlineTransforms) {
        const cachedTransforms = target[transformsSymbol];
        let t;
        while (t = transformsExecRgx.exec(inlineTransforms)) {
            const inlinePropertyName = t[1];
            // const inlinePropertyValue = t[2];
            const inlinePropertyValue = t[2].slice(1, -1);
            cachedTransforms[inlinePropertyName] = inlinePropertyValue;
            if (inlinePropertyName === propName) {
                inlinedStylesPropertyValue = inlinePropertyValue;
                // Store the new parsed inline styles if animationInlineStyles is provided
                if (animationInlineStyles) {
                    animationInlineStyles[propName] = inlinePropertyValue;
                }
            }
        }
    }
    return inlineTransforms && !isUnd(inlinedStylesPropertyValue) ? inlinedStylesPropertyValue :
        stringStartsWith(propName, 'scale') ? '1' :
            stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew') ? '0deg' : '0px';
};


/**
 * @param  {DOMTargetsParam|TargetsParam} v
 * @return {NodeList|HTMLCollection}
 */
function getNodeList(v) {
    const n = isStr(v) ? globals.root.querySelectorAll(v) : v;
    if (n instanceof NodeList || n instanceof HTMLCollection)
        return n;
}
/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
function parseTargets(targets) {
    if (isNil(targets))
        return /** @type {TargetsArray} */ ([]);
    if (isArr(targets)) {
        const flattened = targets.flat(Infinity);
        /** @type {TargetsArray} */
        const parsed = [];
        for (let i = 0, l = flattened.length; i < l; i++) {
            const item = flattened[i];
            if (!isNil(item)) {
                const nodeList = getNodeList(item);
                if (nodeList) {
                    for (let j = 0, jl = nodeList.length; j < jl; j++) {
                        const subItem = nodeList[j];
                        if (!isNil(subItem)) {
                            let isDuplicate = false;
                            for (let k = 0, kl = parsed.length; k < kl; k++) {
                                if (parsed[k] === subItem) {
                                    isDuplicate = true;
                                    break;
                                }
                            }
                            if (!isDuplicate) {
                                parsed.push(subItem);
                            }
                        }
                    }
                }
                else {
                    let isDuplicate = false;
                    for (let j = 0, jl = parsed.length; j < jl; j++) {
                        if (parsed[j] === item) {
                            isDuplicate = true;
                            break;
                        }
                    }
                    if (!isDuplicate) {
                        parsed.push(item);
                    }
                }
            }
        }
        return parsed;
    }
    if (!isBrowser)
        return /** @type {JSTargetsArray} */ ([targets]);
    const nodeList = getNodeList(targets);
    if (nodeList)
        return /** @type {DOMTargetsArray} */ (Array.from(nodeList));
    return /** @type {TargetsArray} */ ([targets]);
}
/**
 * @overload
 * @param  {DOMTargetsParam} targets
 * @return {DOMTargetsArray}
 *
 * @overload
 * @param  {JSTargetsParam} targets
 * @return {JSTargetsArray}
 *
 * @overload
 * @param  {TargetsParam} targets
 * @return {TargetsArray}
 *
 * @param  {DOMTargetsParam|JSTargetsParam|TargetsParam} targets
 */
function registerTargets(targets) {
    const parsedTargetsArray = parseTargets(targets);
    const parsedTargetsLength = parsedTargetsArray.length;
    if (parsedTargetsLength) {
        for (let i = 0; i < parsedTargetsLength; i++) {
            const target = parsedTargetsArray[i];
            if (!target[isRegisteredTargetSymbol]) {
                target[isRegisteredTargetSymbol] = true;
                const isSvgType = isSvg(target);
                const isDom = /** @type {DOMTarget} */ (target).nodeType || isSvgType;
                if (isDom) {
                    target[isDomSymbol] = true;
                    target[isSvgSymbol] = isSvgType;
                    target[transformsSymbol] = {};
                }
            }
        }
    }
    return parsedTargetsArray;
}


/**
 * @param  {TargetsParam} path
 * @return {SVGGeometryElement|undefined}
 */
const getPath = path => {
    const parsedTargets = parseTargets(path);
    const $parsedSvg = /** @type {SVGGeometryElement} */ (parsedTargets[0]);
    if (!$parsedSvg || !isSvg($parsedSvg))
        return;
    return $parsedSvg;
};
/**
 * @param  {TargetsParam} path2
 * @param  {Number} [precision]
 * @return {FunctionValue}
 */
const morphTo = (path2, precision = .33) => ($path1) => {
    const $path2 = /** @type {SVGGeometryElement} */ (getPath(path2));
    if (!$path2)
        return;
    const isPath = $path1.tagName === 'path';
    const separator = isPath ? ' ' : ',';
    const previousPoints = $path1[morphPointsSymbol];
    if (previousPoints)
        $path1.setAttribute(isPath ? 'd' : 'points', previousPoints);
    let v1 = '', v2 = '';
    if (!precision) {
        v1 = $path1.getAttribute(isPath ? 'd' : 'points');
        v2 = $path2.getAttribute(isPath ? 'd' : 'points');
    }
    else {
        const length1 = /** @type {SVGGeometryElement} */ ($path1).getTotalLength();
        const length2 = $path2.getTotalLength();
        const maxPoints = Math.max(Math.ceil(length1 * precision), Math.ceil(length2 * precision));
        for (let i = 0; i < maxPoints; i++) {
            const t = i / (maxPoints - 1);
            const pointOnPath1 = /** @type {SVGGeometryElement} */ ($path1).getPointAtLength(length1 * t);
            const pointOnPath2 = $path2.getPointAtLength(length2 * t);
            const prefix = isPath ? (i === 0 ? 'M' : 'L') : '';
            v1 += prefix + round(pointOnPath1.x, 3) + separator + pointOnPath1.y + ' ';
            v2 += prefix + round(pointOnPath2.x, 3) + separator + pointOnPath2.y + ' ';
        }
    }
    $path1[morphPointsSymbol] = v2;
    return [v1, v2];
};
/**
 * @param {SVGGeometryElement} $el
 * @param {Number} start
 * @param {Number} end
 * @return {Proxy}
 */
function createDrawableProxy($el, start, end) {
    const strokeLineCap = getComputedStyle($el).strokeLinecap;
    const pathLength = K;
    let currentCap = strokeLineCap;
    const proxy = new Proxy($el, {
        get(target, property) {
            const value = target[property];
            if (property === proxyTargetSymbol)
                return target;
            if (property === 'setAttribute') {
                /** @param {any[]} args */
                return (...args) => {
                    if (args[0] === 'draw') {
                        const value = args[1];
                        const values = value.split(' ');
                        const v1 = +values[0];
                        const v2 = +values[1];
                        // TOTO: Benchmark if performing two slices is more performant than one split
                        // const spaceIndex = value.indexOf(' ');
                        // const v1 = round(+value.slice(0, spaceIndex), precision);
                        // const v2 = round(+value.slice(spaceIndex + 1), precision);
                        const os = v1 * -1e3;
                        const d1 = (v2 * pathLength) + os;
                        // Prevents linecap to smear by offsetting the dasharray length by 0.01% when v2 is not at max
                        const d2 = (pathLength + ((v1 === 0 && v2 === 1) || (v1 === 1 && v2 === 0) ? 0 : 10) - d1);
                        // Handle cases where the cap is still visible when the line is completly hidden
                        if (strokeLineCap !== 'butt') {
                            const newCap = v1 === v2 ? 'butt' : strokeLineCap;
                            if (currentCap !== newCap) {
                                target.setAttribute('stroke-linecap', `${newCap}`);
                                currentCap = newCap;
                            }
                        }
                        target.setAttribute('stroke-dashoffset', `${os}`);
                        target.setAttribute('stroke-dasharray', `${d1} ${d2}`);
                    }
                    return Reflect.apply(value, target, args);
                };
            }
            if (isFnc(value)) {
                /** @param {any[]} args */
                return (...args) => Reflect.apply(value, target, args);
            }
            else {
                return value;
            }
        }
    });
    if ($el.getAttribute('pathLength') !== `${pathLength}`) {
        $el.setAttribute('pathLength', `${pathLength}`);
        proxy.setAttribute('draw', `${start} ${end}`);
    }
    return /** @type {typeof Proxy} */ ( /** @type {unknown} */(proxy));
}
/**
 * @param {TargetsParam} selector
 * @param {Number} [start=0]
 * @param {Number} [end=0]
 * @return {Array.<Proxy>}
 */
const createDrawable = (selector, start = 0, end = 0) => {
    const els = /** @type {Array.<Proxy>} */ (( /** @type {unknown} */(parseTargets(selector))));
    els.forEach(($el, i) => els[i] = createDrawableProxy(/** @type {SVGGeometryElement} */ ( /** @type {unknown} */($el)), start, end));
    return els;
};
// Motion path animation
/**
 * @param {SVGGeometryElement} $path
 * @param {Number} progress
 * @param {Number}lookup
 * @return {DOMPoint}
 */
const getPathPoint = ($path, progress, lookup = 0) => {
    return $path.getPointAtLength(progress + lookup >= 1 ? progress + lookup : 0);
};
/**
 * @param {SVGGeometryElement} $path
 * @param {String} pathProperty
 * @return {FunctionValue}
 */
const getPathProgess = ($path, pathProperty) => {
    return $el => {
        const totalLength = +($path.getTotalLength());
        const inSvg = $el[isSvgSymbol];
        const ctm = $path.getCTM();
        /** @type {TweenObjectValue} */
        return {
            from: 0,
            to: totalLength,
            /** @type {TweenModifier} */
            modifier: progress => {
                if (pathProperty === 'a') {
                    const p0 = getPathPoint($path, progress, -1);
                    const p1 = getPathPoint($path, progress, 1);
                    return atan2(p1.y - p0.y, p1.x - p0.x) * 180 / PI;
                }
                else {
                    const p = getPathPoint($path, progress, 0);
                    return pathProperty === 'x' ?
                        inSvg || !ctm ? p.x : p.x * ctm.a + p.y * ctm.c + ctm.e :
                        inSvg || !ctm ? p.y : p.x * ctm.b + p.y * ctm.d + ctm.f;
                }
            }
        };
    };
};
/**
 * @param {TargetsParam} path
 */
const createMotionPath = path => {
    const $path = getPath(path);
    if (!$path)
        return;
    return {
        translateX: getPathProgess($path, 'x'),
        translateY: getPathProgess($path, 'y'),
        rotate: getPathProgess($path, 'a'),
    };
};
// Check for valid SVG attribute
const cssReservedProperties = ['opacity', 'rotate', 'overflow', 'color'];
/**
 * @param  {Target} el
 * @param  {String} propertyName
 * @return {Boolean}
 */
const isValidSVGAttribute = (el, propertyName) => {
    // Return early and use CSS opacity animation instead (already better default values (opacity: 1 instead of 0)) and rotate should be considered a transform
    if (cssReservedProperties.includes(propertyName))
        return false;
    if (el.getAttribute(propertyName) || propertyName in el) {
        if (propertyName === 'scale') { // Scale
            const elParentNode = /** @type {SVGGeometryElement} */ ( /** @type {DOMTarget} */(el).parentNode);
            // Only consider scale as a valid SVG attribute on filter element
            return elParentNode && elParentNode.tagName === 'filter';
        }
        return true;
    }
};
const svg = {
    morphTo,
    createMotionPath,
    createDrawable,
};


/**
 * RGB / RGBA Color value string -> RGBA values array
 * @param  {String} rgbValue
 * @return {ColorArray}
 */
const rgbToRgba = rgbValue => {
    const rgba = rgbExecRgx.exec(rgbValue) || rgbaExecRgx.exec(rgbValue);
    const a = !isUnd(rgba[4]) ? +rgba[4] : 1;
    return [
        +rgba[1],
        +rgba[2],
        +rgba[3],
        a
    ];
};
/**
 * HEX3 / HEX3A / HEX6 / HEX6A Color value string -> RGBA values array
 * @param  {String} hexValue
 * @return {ColorArray}
 */
const hexToRgba = hexValue => {
    const hexLength = hexValue.length;
    const isShort = hexLength === 4 || hexLength === 5;
    return [
        +('0x' + hexValue[1] + hexValue[isShort ? 1 : 2]),
        +('0x' + hexValue[isShort ? 2 : 3] + hexValue[isShort ? 2 : 4]),
        +('0x' + hexValue[isShort ? 3 : 5] + hexValue[isShort ? 3 : 6]),
        ((hexLength === 5 || hexLength === 9) ? +(+('0x' + hexValue[isShort ? 4 : 7] + hexValue[isShort ? 4 : 8]) / 255).toFixed(3) : 1)
    ];
};
/**
 * @param  {Number} p
 * @param  {Number} q
 * @param  {Number} t
 * @return {Number}
 */
const hue2rgb = (p, q, t) => {
    if (t < 0)
        t += 1;
    if (t > 1)
        t -= 1;
    return t < 1 / 6 ? p + (q - p) * 6 * t :
        t < 1 / 2 ? q :
            t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 :
                p;
};
/**
 * HSL / HSLA Color value string -> RGBA values array
 * @param  {String} hslValue
 * @return {ColorArray}
 */
const hslToRgba = hslValue => {
    const hsla = hslExecRgx.exec(hslValue) || hslaExecRgx.exec(hslValue);
    const h = +hsla[1] / 360;
    const s = +hsla[2] / 100;
    const l = +hsla[3] / 100;
    const a = !isUnd(hsla[4]) ? +hsla[4] : 1;
    let r, g, b;
    if (s === 0) {
        r = g = b = l;
    }
    else {
        const q = l < .5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = round(hue2rgb(p, q, h + 1 / 3) * 255, 0);
        g = round(hue2rgb(p, q, h) * 255, 0);
        b = round(hue2rgb(p, q, h - 1 / 3) * 255, 0);
    }
    return [r, g, b, a];
};
/**
 * All in one color converter that converts a color string value into an array of RGBA values
 * @param  {String} colorString
 * @return {ColorArray}
 */
const convertColorStringValuesToRgbaArray = colorString => {
    return isRgb(colorString) ? rgbToRgba(colorString) :
        isHex(colorString) ? hexToRgba(colorString) :
            isHsl(colorString) ? hslToRgba(colorString) :
                [0, 0, 0, 1];
};


/**
 * @template T, D
 * @param {T|undefined} targetValue
 * @param {D} defaultValue
 * @return {T|D}
 */
const setValue = (targetValue, defaultValue) => {
    return isUnd(targetValue) ? defaultValue : targetValue;
};
/**
 * @param  {TweenPropValue} value
 * @param  {Target} target
 * @param  {Number} index
 * @param  {Number} total
 * @param  {Object} [store]
 * @return {any}
 */
const getFunctionValue = (value, target, index, total, store) => {
    if (isFnc(value)) {
        const func = () => {
            const computed = /** @type {Function} */ (value)(target, index, total);
            // Fallback to 0 if the function returns undefined / NaN / null / false / 0
            return !isNaN(+computed) ? +computed : computed || 0;
        };
        if (store) {
            store.func = func;
        }
        return func();
    }
    else {
        return value;
    }
};
/**
 * @param  {Target} target
 * @param  {String} prop
 * @return {tweenTypes}
 */
const getTweenType = (target, prop) => {
    return !target[isDomSymbol] ? tweenTypes.OBJECT :
        // Handle SVG attributes
        target[isSvgSymbol] && isValidSVGAttribute(target, prop) ? tweenTypes.ATTRIBUTE :
            // Handle CSS Transform properties differently than CSS to allow individual animations
            validTransforms.includes(prop) || shortTransforms.get(prop) ? tweenTypes.TRANSFORM :
                // CSS variables
                stringStartsWith(prop, '--') ? tweenTypes.CSS_VAR :
                    // All other CSS properties
                    prop in /** @type {DOMTarget} */ (target).style ? tweenTypes.CSS :
                        // Handle other DOM Attributes
                        prop in target ? tweenTypes.OBJECT :
                            tweenTypes.ATTRIBUTE;
};
/**
 * @param  {DOMTarget} target
 * @param  {String} propName
 * @param  {Object} animationInlineStyles
 * @return {String}
 */
const getCSSValue = (target, propName, animationInlineStyles) => {
    const inlineStyles = target.style[propName];
    if (inlineStyles && animationInlineStyles) {
        animationInlineStyles[propName] = inlineStyles;
    }
    const value = inlineStyles || getComputedStyle(target[proxyTargetSymbol] || target).getPropertyValue(propName);
    return value === 'auto' ? '0' : value;
};
/**
 * @param {Target} target
 * @param {String} propName
 * @param {tweenTypes} [tweenType]
 * @param {Object|void} [animationInlineStyles]
 * @return {String|Number}
 */
const getOriginalAnimatableValue = (target, propName, tweenType, animationInlineStyles) => {
    const type = !isUnd(tweenType) ? tweenType : getTweenType(target, propName);
    return type === tweenTypes.OBJECT ? target[propName] || 0 :
        type === tweenTypes.ATTRIBUTE ? /** @type {DOMTarget} */ (target).getAttribute(propName) :
            type === tweenTypes.TRANSFORM ? parseInlineTransforms(/** @type {DOMTarget} */ (target), propName, animationInlineStyles) :
                type === tweenTypes.CSS_VAR ? getCSSValue(/** @type {DOMTarget} */ (target), propName, animationInlineStyles).trimStart() :
                    getCSSValue(/** @type {DOMTarget} */ (target), propName, animationInlineStyles);
};
/**
 * @param  {Number} x
 * @param  {Number} y
 * @param  {String} operator
 * @return {Number}
 */
const getRelativeValue = (x, y, operator) => {
    return operator === '-' ? x - y :
        operator === '+' ? x + y :
            x * y;
};
/** @return {TweenDecomposedValue} */
const createDecomposedValueTargetObject = () => {
    return {
        /** @type {valueTypes} */
        t: valueTypes.NUMBER,
        n: 0,
        u: null,
        o: null,
        d: null,
        s: null,
    };
};
/**
 * @param  {String|Number} rawValue
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
const decomposeRawValue = (rawValue, targetObject) => {
    /** @type {valueTypes} */
    targetObject.t = valueTypes.NUMBER;
    targetObject.n = 0;
    targetObject.u = null;
    targetObject.o = null;
    targetObject.d = null;
    targetObject.s = null;
    if (!rawValue)
        return targetObject;
    const num = +rawValue;
    if (!isNaN(num)) {
        // It's a number
        targetObject.n = num;
        return targetObject;
    }
    else {
        // let str = /** @type {String} */(rawValue).trim();
        let str = /** @type {String} */ (rawValue);
        // Parsing operators (+=, -=, *=) manually is much faster than using regex here
        if (str[1] === '=') {
            targetObject.o = str[0];
            str = str.slice(2);
        }
        // Skip exec regex if the value type is complex or color to avoid long regex backtracking
        const unitMatch = str.includes(' ') ? false : unitsExecRgx.exec(str);
        if (unitMatch) {
            // Has a number and a unit
            targetObject.t = valueTypes.UNIT;
            targetObject.n = +unitMatch[1];
            targetObject.u = unitMatch[2];
            return targetObject;
        }
        else if (targetObject.o) {
            // Has an operator (+=, -=, *=)
            targetObject.n = +str;
            return targetObject;
        }
        else if (isCol(str)) {
            // Is a color
            targetObject.t = valueTypes.COLOR;
            targetObject.d = convertColorStringValuesToRgbaArray(str);
            return targetObject;
        }
        else {
            // Is a more complex string (generally svg coords, calc() or filters CSS values)
            const matchedNumbers = str.match(digitWithExponentRgx);
            targetObject.t = valueTypes.COMPLEX;
            targetObject.d = matchedNumbers ? matchedNumbers.map(Number) : [];
            targetObject.s = str.split(digitWithExponentRgx) || [];
            return targetObject;
        }
    }
};
/**
 * @param  {Tween} tween
 * @param  {TweenDecomposedValue} targetObject
 * @return {TweenDecomposedValue}
 */
const decomposeTweenValue = (tween, targetObject) => {
    targetObject.t = tween._valueType;
    targetObject.n = tween._toNumber;
    targetObject.u = tween._unit;
    targetObject.o = null;
    targetObject.d = cloneArray(tween._toNumbers);
    targetObject.s = cloneArray(tween._strings);
    return targetObject;
};
const decomposedOriginalValue = createDecomposedValueTargetObject();


const lookups = {
    /** @type {TweenReplaceLookups} */
    _rep: new WeakMap(),
    /** @type {TweenAdditiveLookups} */
    _add: new Map(),
};
/**
 * @param  {Target} target
 * @param  {String} property
 * @param  {String} lookup
 * @return {TweenPropertySiblings}
 */
const getTweenSiblings = (target, property, lookup = '_rep') => {
    const lookupMap = lookups[lookup];
    let targetLookup = lookupMap.get(target);
    if (!targetLookup) {
        targetLookup = {};
        lookupMap.set(target, targetLookup);
    }
    return targetLookup[property] ? targetLookup[property] : targetLookup[property] = {
        _head: null,
        _tail: null,
    };
};
/**
 * @param  {Tween} p
 * @param  {Tween} c
 * @return {Number|Boolean}
 */
const addTweenSortMethod = (p, c) => {
    return p._isOverridden || p._absoluteStartTime > c._absoluteStartTime;
};
/**
 * @param {Tween} tween
 */
const overrideTween = tween => {
    tween._isOverlapped = 1;
    tween._isOverridden = 1;
    tween._changeDuration = minValue;
    tween._currentTime = minValue;
};
/**
 * @param  {Tween} tween
 * @param  {TweenPropertySiblings} siblings
 * @return {Tween}
 */
const composeTween = (tween, siblings) => {
    const tweenCompositionType = tween._composition;
    // Handle replaced tweens
    if (tweenCompositionType === compositionTypes.replace) {
        const tweenAbsStartTime = tween._absoluteStartTime;
        addChild(siblings, tween, addTweenSortMethod, '_prevRep', '_nextRep');
        const prevSibling = tween._prevRep;
        // Update the previous siblings for composition replace tweens
        if (prevSibling) {
            const prevParent = prevSibling.parent;
            const prevAbsEndTime = prevSibling._absoluteStartTime + prevSibling._changeDuration;
            // Handle looped animations tween
            if (
            // Check if the previous tween is from a different animation
            tween.parent.id !== prevParent.id &&
                // Check if the animation has loops
                prevParent.iterationCount > 1 &&
                // Check if _absoluteChangeEndTime of last loop overlaps the current tween
                prevAbsEndTime + (prevParent.duration - prevParent.iterationDuration) > tweenAbsStartTime) {
                // TODO: Find a way to only override the iterations overlapping with the tween
                overrideTween(prevSibling);
                let prevPrevSibling = prevSibling._prevRep;
                // If the tween was part of a set of keyframes, override its siblings
                while (prevPrevSibling && prevPrevSibling.parent.id === prevParent.id) {
                    overrideTween(prevPrevSibling);
                    prevPrevSibling = prevPrevSibling._prevRep;
                }
            }
            const absoluteUpdateStartTime = tweenAbsStartTime - tween._delay;
            if (prevAbsEndTime > absoluteUpdateStartTime) {
                const prevChangeStartTime = prevSibling._startTime;
                const prevTLOffset = prevAbsEndTime - (prevChangeStartTime + prevSibling._updateDuration);
                prevSibling._changeDuration = absoluteUpdateStartTime - prevTLOffset - prevChangeStartTime;
                prevSibling._currentTime = prevSibling._changeDuration;
                prevSibling._isOverlapped = 1;
                if (prevSibling._changeDuration < minValue) {
                    overrideTween(prevSibling);
                }
            }
            // Pause (and cancel) the parent if it only contains overlapped tweens
            let pausePrevParentAnimation = true;
            forEachChildren(prevParent, (/** @type Tween */ t) => {
                if (!t._isOverlapped)
                    pausePrevParentAnimation = false;
            });
            if (pausePrevParentAnimation) {
                const prevParentTL = prevParent.parent;
                if (prevParentTL) {
                    let pausePrevParentTL = true;
                    forEachChildren(prevParentTL, (/** @type JSAnimation */ a) => {
                        if (a !== prevParent) {
                            forEachChildren(a, (/** @type Tween */ t) => {
                                if (!t._isOverlapped)
                                    pausePrevParentTL = false;
                            });
                        }
                    });
                    if (pausePrevParentTL) {
                        prevParentTL.cancel();
                    }
                }
                else {
                    prevParent.cancel();
                    // Previously, calling .cancel() on a timeline child would affect the render order of other children
                    // Worked around this by marking it as .completed and using .pause() for safe removal in the engine loop
                    // This is no longer needed since timeline tween composition is now handled separatly
                    // Keeping this here for reference
                    // prevParent.completed = true;
                    // prevParent.pause();
                }
            }
        }
        // let nextSibling = tween._nextRep;
        // // All the next siblings are automatically overridden
        // if (nextSibling && nextSibling._absoluteStartTime >= tweenAbsStartTime) {
        //   while (nextSibling) {
        //     overrideTween(nextSibling);
        //     nextSibling = nextSibling._nextRep;
        //   }
        // }
        // if (nextSibling && nextSibling._absoluteStartTime < tweenAbsStartTime) {
        //   while (nextSibling) {
        //     overrideTween(nextSibling);
        //     console.log(tween.id, nextSibling.id);
        //     nextSibling = nextSibling._nextRep;
        //   }
        // }
        // Handle additive tweens composition
    }
    else if (tweenCompositionType === compositionTypes.blend) {
        const additiveTweenSiblings = getTweenSiblings(tween.target, tween.property, '_add');
        const additiveAnimation = addAdditiveAnimation(lookups._add);
        let lookupTween = additiveTweenSiblings._head;
        if (!lookupTween) {
            lookupTween = { ...tween };
            lookupTween._composition = compositionTypes.replace;
            lookupTween._updateDuration = minValue;
            lookupTween._startTime = 0;
            lookupTween._numbers = cloneArray(tween._fromNumbers);
            lookupTween._number = 0;
            lookupTween._next = null;
            lookupTween._prev = null;
            addChild(additiveTweenSiblings, lookupTween);
            addChild(additiveAnimation, lookupTween);
        }
        // Convert the values of TO to FROM and set TO to 0
        const toNumber = tween._toNumber;
        tween._fromNumber = lookupTween._fromNumber - toNumber;
        tween._toNumber = 0;
        tween._numbers = cloneArray(tween._fromNumbers);
        tween._number = 0;
        lookupTween._fromNumber = toNumber;
        if (tween._toNumbers) {
            const toNumbers = cloneArray(tween._toNumbers);
            if (toNumbers) {
                toNumbers.forEach((value, i) => {
                    tween._fromNumbers[i] = lookupTween._fromNumbers[i] - value;
                    tween._toNumbers[i] = 0;
                });
            }
            lookupTween._fromNumbers = toNumbers;
        }
        addChild(additiveTweenSiblings, tween, null, '_prevAdd', '_nextAdd');
    }
    return tween;
};
/**
 * @param  {Tween} tween
 * @return {Tween}
 */
const removeTweenSliblings = tween => {
    const tweenComposition = tween._composition;
    if (tweenComposition !== compositionTypes.none) {
        const tweenTarget = tween.target;
        const tweenProperty = tween.property;
        const replaceTweensLookup = lookups._rep;
        const replaceTargetProps = replaceTweensLookup.get(tweenTarget);
        const tweenReplaceSiblings = replaceTargetProps[tweenProperty];
        removeChild(tweenReplaceSiblings, tween, '_prevRep', '_nextRep');
        if (tweenComposition === compositionTypes.blend) {
            const addTweensLookup = lookups._add;
            const addTargetProps = addTweensLookup.get(tweenTarget);
            if (!addTargetProps)
                return;
            const additiveTweenSiblings = addTargetProps[tweenProperty];
            const additiveAnimation = additive.animation;
            removeChild(additiveTweenSiblings, tween, '_prevAdd', '_nextAdd');
            // If only one tween is left in the additive lookup, it's the tween lookup
            const lookupTween = additiveTweenSiblings._head;
            if (lookupTween && lookupTween === additiveTweenSiblings._tail) {
                removeChild(additiveTweenSiblings, lookupTween, '_prevAdd', '_nextAdd');
                removeChild(additiveAnimation, lookupTween);
                let shouldClean = true;
                for (let prop in addTargetProps) {
                    if (addTargetProps[prop]._head) {
                        shouldClean = false;
                        break;
                    }
                }
                if (shouldClean) {
                    addTweensLookup.delete(tweenTarget);
                }
            }
        }
    }
    return tween;
};


/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const resetTimerProperties = timer => {
    timer.paused = true;
    timer.began = false;
    timer.completed = false;
    return timer;
};
/**
 * @param  {Timer} timer
 * @return {Timer}
 */
const reviveTimer = timer => {
    if (!timer._cancelled)
        return timer;
    if (timer._hasChildren) {
        forEachChildren(timer, reviveTimer);
    }
    else {
        forEachChildren(timer, (/** @type {Tween} tween*/ tween) => {
            if (tween._composition !== compositionTypes.none) {
                composeTween(tween, getTweenSiblings(tween.target, tween.property));
            }
        });
    }
    timer._cancelled = 0;
    return timer;
};
let timerId = 0;
/**
 * Base class used to create Timers, Animations and Timelines
 */
class Timer extends Clock {
    /**
     * @param {TimerParams} [parameters]
     * @param {Timeline} [parent]
     * @param {Number} [parentPosition]
     */
    constructor(parameters = {}, parent = null, parentPosition = 0) {
        super(0);
        const { id, delay, duration, reversed, alternate, loop, loopDelay, autoplay, frameRate, playbackRate, onComplete, onLoop, onPause, onBegin, onBeforeUpdate, onUpdate, } = parameters;
        if (globals.scope)
            globals.scope.revertibles.push(this);
        const timerInitTime = parent ? 0 : engine._elapsedTime;
        const timerDefaults = parent ? parent.defaults : globals.defaults;
        const timerDelay = /** @type {Number} */ (isFnc(delay) || isUnd(delay) ? timerDefaults.delay : +delay);
        const timerDuration = isFnc(duration) || isUnd(duration) ? Infinity : +duration;
        const timerLoop = setValue(loop, timerDefaults.loop);
        const timerLoopDelay = setValue(loopDelay, timerDefaults.loopDelay);
        const timerIterationCount = timerLoop === true ||
            timerLoop === Infinity ||
            /** @type {Number} */ (timerLoop) < 0 ? Infinity :
            /** @type {Number} */ (timerLoop) + 1;
        let offsetPosition = 0;
        if (parent) {
            offsetPosition = parentPosition;
        }
        else {
            let startTime = now();
            // Make sure to tick the engine once if suspended to avoid big gaps with the following offsetPosition calculation
            if (engine.paused) {
                engine.requestTick(startTime);
                startTime = engine._elapsedTime;
            }
            offsetPosition = startTime - engine._startTime;
        }
        // Timer's parameters
        this.id = !isUnd(id) ? id : ++timerId;
        /** @type {Timeline} */
        this.parent = parent;
        // Total duration of the timer
        this.duration = clampInfinity(((timerDuration + timerLoopDelay) * timerIterationCount) - timerLoopDelay) || minValue;
        /** @type {Boolean} */
        this.backwards = false;
        /** @type {Boolean} */
        this.paused = true;
        /** @type {Boolean} */
        this.began = false;
        /** @type {Boolean} */
        this.completed = false;
        /** @type {Callback<this>} */
        this.onBegin = onBegin || timerDefaults.onBegin;
        /** @type {Callback<this>} */
        this.onBeforeUpdate = onBeforeUpdate || timerDefaults.onBeforeUpdate;
        /** @type {Callback<this>} */
        this.onUpdate = onUpdate || timerDefaults.onUpdate;
        /** @type {Callback<this>} */
        this.onLoop = onLoop || timerDefaults.onLoop;
        /** @type {Callback<this>} */
        this.onPause = onPause || timerDefaults.onPause;
        /** @type {Callback<this>} */
        this.onComplete = onComplete || timerDefaults.onComplete;
        /** @type {Number} */
        this.iterationDuration = timerDuration; // Duration of one loop
        /** @type {Number} */
        this.iterationCount = timerIterationCount; // Number of loops
        /** @type {Boolean|ScrollObserver} */
        this._autoplay = parent ? false : setValue(autoplay, timerDefaults.autoplay);
        /** @type {Number} */
        this._offset = offsetPosition;
        /** @type {Number} */
        this._delay = timerDelay;
        /** @type {Number} */
        this._loopDelay = timerLoopDelay;
        /** @type {Number} */
        this._iterationTime = 0;
        /** @type {Number} */
        this._currentIteration = 0; // Current loop index
        /** @type {Function} */
        this._resolve = noop; // Used by .then()
        /** @type {Boolean} */
        this._running = false;
        /** @type {Number} */
        this._reversed = +setValue(reversed, timerDefaults.reversed);
        /** @type {Number} */
        this._reverse = this._reversed;
        /** @type {Number} */
        this._cancelled = 0;
        /** @type {Boolean} */
        this._alternate = setValue(alternate, timerDefaults.alternate);
        /** @type {Renderable} */
        this._prev = null;
        /** @type {Renderable} */
        this._next = null;
        // Clock's parameters
        /** @type {Number} */
        this._elapsedTime = timerInitTime;
        /** @type {Number} */
        this._startTime = timerInitTime;
        /** @type {Number} */
        this._lastTime = timerInitTime;
        /** @type {Number} */
        this._fps = setValue(frameRate, timerDefaults.frameRate);
        /** @type {Number} */
        this._speed = setValue(playbackRate, timerDefaults.playbackRate);
    }
    get cancelled() {
        return !!this._cancelled;
    }
    /** @param {Boolean} cancelled  */
    set cancelled(cancelled) {
        cancelled ? this.cancel() : this.reset(1).play();
    }
    get currentTime() {
        return clamp(round(this._currentTime, globals.precision), -this._delay, this.duration);
    }
    /** @param {Number} time  */
    set currentTime(time) {
        const paused = this.paused;
        // Pausing the timer is necessary to avoid time jumps on a running instance
        this.pause().seek(+time);
        if (!paused)
            this.resume();
    }
    get iterationCurrentTime() {
        return round(this._iterationTime, globals.precision);
    }
    /** @param {Number} time  */
    set iterationCurrentTime(time) {
        this.currentTime = (this.iterationDuration * this._currentIteration) + time;
    }
    get progress() {
        return clamp(round(this._currentTime / this.duration, 5), 0, 1);
    }
    /** @param {Number} progress  */
    set progress(progress) {
        this.currentTime = this.duration * progress;
    }
    get iterationProgress() {
        return clamp(round(this._iterationTime / this.iterationDuration, 5), 0, 1);
    }
    /** @param {Number} progress  */
    set iterationProgress(progress) {
        const iterationDuration = this.iterationDuration;
        this.currentTime = (iterationDuration * this._currentIteration) + (iterationDuration * progress);
    }
    get currentIteration() {
        return this._currentIteration;
    }
    /** @param {Number} iterationCount  */
    set currentIteration(iterationCount) {
        this.currentTime = (this.iterationDuration * clamp(+iterationCount, 0, this.iterationCount - 1));
    }
    get reversed() {
        return !!this._reversed;
    }
    /** @param {Boolean} reverse  */
    set reversed(reverse) {
        reverse ? this.reverse() : this.play();
    }
    get speed() {
        return super.speed;
    }
    /** @param {Number} playbackRate  */
    set speed(playbackRate) {
        super.speed = playbackRate;
        this.resetTime();
    }
    /**
     * @param  {Number} internalRender
     * @return {this}
     */
    reset(internalRender = 0) {
        // If cancelled, revive the timer before rendering in order to have propertly composed tweens siblings
        reviveTimer(this);
        if (this._reversed && !this._reverse)
            this.reversed = false;
        // Rendering before updating the completed flag to prevent skips and to make sure the properties are not overridden
        // Setting the iterationTime at the end to force the rendering to happend backwards, otherwise calling .reset() on Timelines might not render children in the right order
        // NOTE: This is only required for Timelines and might be better to move to the Timeline class?
        this._iterationTime = this.iterationDuration;
        // Set tickMode to tickModes.FORCE to force rendering
        tick(this, 0, 1, internalRender, tickModes.FORCE);
        // Reset timer properties after revive / render to make sure the props are not updated again
        resetTimerProperties(this);
        // Also reset children properties
        if (this._hasChildren) {
            forEachChildren(this, resetTimerProperties);
        }
        return this;
    }
    /**
     * @param  {Number} internalRender
     * @return {this}
     */
    init(internalRender = 0) {
        this.fps = this._fps;
        this.speed = this._speed;
        // Manually calling .init() on timelines should render all children intial state
        // Forces all children to render once then render to 0 when reseted
        if (!internalRender && this._hasChildren) {
            tick(this, this.duration, 1, internalRender, tickModes.FORCE);
        }
        this.reset(internalRender);
        // Make sure to set autoplay to false to child timers so it doesn't attempt to autoplay / link
        const autoplay = this._autoplay;
        if (autoplay === true) {
            this.resume();
        }
        else if (autoplay && !isUnd(/** @type {ScrollObserver} */ (autoplay).linked)) {
            /** @type {ScrollObserver} */ (autoplay).link(this);
        }
        return this;
    }
    /** @return {this} */
    resetTime() {
        const timeScale = 1 / (this._speed * engine._speed);
        this._startTime = now() - (this._currentTime + this._delay) * timeScale;
        return this;
    }
    /** @return {this} */
    pause() {
        if (this.paused)
            return this;
        this.paused = true;
        this.onPause(this);
        return this;
    }
    /** @return {this} */
    resume() {
        if (!this.paused)
            return this;
        this.paused = false;
        // We can safely imediatly render a timer that has no duration and no children
        if (this.duration <= minValue && !this._hasChildren) {
            tick(this, minValue, 0, 0, tickModes.FORCE);
        }
        else {
            if (!this._running) {
                addChild(engine, this);
                engine._hasChildren = true;
                this._running = true;
            }
            this.resetTime();
            // Forces the timer to advance by at least one frame when the next tick occurs
            this._startTime -= 12;
            engine.wake();
        }
        return this;
    }
    /** @return {this} */
    restart() {
        return this.reset(0).resume();
    }
    /**
     * @param  {Number} time
     * @param  {Boolean|Number} [muteCallbacks]
     * @param  {Boolean|Number} [internalRender]
     * @return {this}
     */
    seek(time, muteCallbacks = 0, internalRender = 0) {
        // Recompose the tween siblings in case the timer has been cancelled
        reviveTimer(this);
        // If you seek a completed animation, otherwise the next play will starts at 0
        this.completed = false;
        const isPaused = this.paused;
        this.paused = true;
        // timer, time, muteCallbacks, internalRender, tickMode
        tick(this, time + this._delay, ~~muteCallbacks, ~~internalRender, tickModes.AUTO);
        return isPaused ? this : this.resume();
    }
    /** @return {this} */
    alternate() {
        const reversed = this._reversed;
        const count = this.iterationCount;
        const duration = this.iterationDuration;
        // Calculate the maximum iterations possible given the iteration duration
        const iterations = count === Infinity ? floor(maxValue / duration) : count;
        this._reversed = +(this._alternate && !(iterations % 2) ? reversed : !reversed);
        if (count === Infinity) {
            // Handle infinite loops to loop on themself
            this.iterationProgress = this._reversed ? 1 - this.iterationProgress : this.iterationProgress;
        }
        else {
            this.seek((duration * iterations) - this._currentTime);
        }
        this.resetTime();
        return this;
    }
    /** @return {this} */
    play() {
        if (this._reversed)
            this.alternate();
        return this.resume();
    }
    /** @return {this} */
    reverse() {
        if (!this._reversed)
            this.alternate();
        return this.resume();
    }
    // TODO: Move all the animation / tweens / children related code to Animation / Timeline
    /** @return {this} */
    cancel() {
        if (this._hasChildren) {
            forEachChildren(this, (/** @type {Renderable} */ child) => child.cancel(), true);
        }
        else {
            forEachChildren(this, removeTweenSliblings);
        }
        this._cancelled = 1;
        // Pausing the timer removes it from the engine
        return this.pause();
    }
    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
        const currentDuration = this.duration;
        if (currentDuration === clampZero(newDuration))
            return this;
        const timeScale = newDuration / currentDuration;
        const isSetter = newDuration <= minValue;
        this.duration = isSetter ? minValue : clampZero(clampInfinity(round(currentDuration * timeScale, 12)));
        this.iterationDuration = isSetter ? minValue : clampZero(clampInfinity(round(this.iterationDuration * timeScale, 12)));
        this._offset *= timeScale;
        this._delay *= timeScale;
        this._loopDelay *= timeScale;
        return this;
    }
    /**
      * Cancels the timer by seeking it back to 0 and reverting the attached scroller if necessary
      * @return {this}
      */
    revert() {
        tick(this, 0, 1, 0, tickModes.AUTO);
        const ap = /** @type {ScrollObserver} */ (this._autoplay);
        if (ap && ap.linked && ap.linked === this)
            ap.revert();
        return this.cancel();
    }
    /**
      * Imediatly completes the timer, cancels it and triggers the onComplete callback
      * @return {this}
      */
    complete() {
        return this.seek(this.duration).cancel();
    }
    /**
     * @param  {Callback<this>} [callback]
     * @return {Promise}
     */
    then(callback = noop) {
        const then = this.then;
        const onResolve = () => {
            // this.then = null prevents infinite recursion if returned by an async function
            // https://github.com/juliangarnierorg/anime-beta/issues/26
            this.then = null;
            callback(this);
            this.then = then;
            this._resolve = noop;
        };
        return new Promise(r => {
            this._resolve = () => r(onResolve());
            // Make sure to resolve imediatly if the timer has already completed
            if (this.completed)
                this._resolve();
            return this;
        });
    }
}
/**
 * @param {TimerParams} [parameters]
 * @return {Timer}
 */
const createTimer = parameters => new Timer(parameters, null, 0).init();


/** @type {EasingFunction} */
const none = t => t;
// Cubic Bezier solver adapted from https://github.com/gre/bezier-ease © Gaëtan Renaudeau
/**
 * @param  {Number} aT
 * @param  {Number} aA1
 * @param  {Number} aA2
 * @return {Number}
 */
const calcBezier = (aT, aA1, aA2) => (((1 - 3 * aA2 + 3 * aA1) * aT + (3 * aA2 - 6 * aA1)) * aT + (3 * aA1)) * aT;
/**
 * @param  {Number} aX
 * @param  {Number} mX1
 * @param  {Number} mX2
 * @return {Number}
 */
const binarySubdivide = (aX, mX1, mX2) => {
    let aA = 0, aB = 1, currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0) {
            aB = currentT;
        }
        else {
            aA = currentT;
        }
    } while (abs(currentX) > .0000001 && ++i < 100);
    return currentT;
};
/**
 * @param  {Number} [mX1]
 * @param  {Number} [mY1]
 * @param  {Number} [mX2]
 * @param  {Number} [mY2]
 * @return {EasingFunction}
 */
const cubicBezier = (mX1 = 0.5, mY1 = 0.0, mX2 = 0.5, mY2 = 1.0) => (mX1 === mY1 && mX2 === mY2) ? none :
    t => t === 0 || t === 1 ? t :
        calcBezier(binarySubdivide(t, mX1, mX2), mY1, mY2);
/**
 * Steps ease implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function
 * Only covers 'end' and 'start' jumpterms
 * @param  {Number} steps
 * @param  {Boolean} [fromStart]
 * @return {EasingFunction}
 */
const steps = (steps = 10, fromStart) => {
    const roundMethod = fromStart ? ceil : floor;
    return t => roundMethod(clamp(t, 0, 1) * steps) * (1 / steps);
};
/**
 * Without parameters, the linear function creates a non-eased transition.
 * Parameters, if used, creates a piecewise linear easing by interpolating linearly between the specified points.
 * @param  {...String|Number} [args] - Points
 * @return {EasingFunction}
 */
const linear = (...args) => {
    const argsLength = args.length;
    if (!argsLength)
        return none;
    const totalPoints = argsLength - 1;
    const firstArg = args[0];
    const lastArg = args[totalPoints];
    const xPoints = [0];
    const yPoints = [parseNumber(firstArg)];
    for (let i = 1; i < totalPoints; i++) {
        const arg = args[i];
        const splitValue = isStr(arg) ?
            /** @type {String} */ (arg).trim().split(' ') :
            [arg];
        const value = splitValue[0];
        const percent = splitValue[1];
        xPoints.push(!isUnd(percent) ? parseNumber(percent) / 100 : i / totalPoints);
        yPoints.push(parseNumber(value));
    }
    yPoints.push(parseNumber(lastArg));
    xPoints.push(1);
    return function easeLinear(t) {
        for (let i = 1, l = xPoints.length; i < l; i++) {
            const currentX = xPoints[i];
            if (t <= currentX) {
                const prevX = xPoints[i - 1];
                const prevY = yPoints[i - 1];
                return prevY + (yPoints[i] - prevY) * (t - prevX) / (currentX - prevX);
            }
        }
        return yPoints[yPoints.length - 1];
    };
};
/**
 * Generate random steps
 * @param  {Number} [length] - The number of steps
 * @param  {Number} [randomness] - How strong the randomness is
 * @return {EasingFunction}
 */
const irregular = (length = 10, randomness = 1) => {
    const values = [0];
    const total = length - 1;
    for (let i = 1; i < total; i++) {
        const previousValue = values[i - 1];
        const spacing = i / total;
        const segmentEnd = (i + 1) / total;
        const randomVariation = spacing + (segmentEnd - spacing) * Math.random();
        // Mix the even spacing and random variation based on the randomness parameter
        const randomValue = spacing * (1 - randomness) + randomVariation * randomness;
        values.push(clamp(randomValue, previousValue, 1));
    }
    values.push(1);
    return linear(...values);
};
// Easing functions adapted from http://www.robertpenner.com/ease © Robert Penner
/**
 * @callback PowerEasing
 * @param {Number|String} [power=1.675]
 * @return {EasingFunction}
 */
/**
 * @callback BackEasing
 * @param {Number|String} [overshoot=1.70158]
 * @return {EasingFunction}
 */
/**
 * @callback ElasticEasing
 * @param {Number|String} [amplitude=1]
 * @param {Number|String} [period=.3]
 * @return {EasingFunction}
 */
/**
 * @callback EaseFactory
 * @param {Number|String} [paramA]
 * @param {Number|String} [paramB]
 * @return {EasingFunction|Number}
 */
/** @typedef {PowerEasing|BackEasing|ElasticEasing} EasesFactory */
const halfPI = PI / 2;
const doublePI = PI * 2;
/** @type {PowerEasing} */
const easeInPower = (p = 1.68) => t => pow(t, +p);
/** @type {Record<String, EasesFactory|EasingFunction>} */
const easeInFunctions = {
    [emptyString]: easeInPower,
    Quad: easeInPower(2),
    Cubic: easeInPower(3),
    Quart: easeInPower(4),
    Quint: easeInPower(5),
    /** @type {EasingFunction} */
    Sine: t => 1 - cos(t * halfPI),
    /** @type {EasingFunction} */
    Circ: t => 1 - sqrt(1 - t * t),
    /** @type {EasingFunction} */
    Expo: t => t ? pow(2, 10 * t - 10) : 0,
    /** @type {EasingFunction} */
    Bounce: t => {
        let pow2, b = 4;
        while (t < ((pow2 = pow(2, --b)) - 1) / 11)
            ;
        return 1 / pow(4, 3 - b) - 7.5625 * pow((pow2 * 3 - 2) / 22 - t, 2);
    },
    /** @type {BackEasing} */
    Back: (overshoot = 1.70158) => t => (+overshoot + 1) * t * t * t - +overshoot * t * t,
    /** @type {ElasticEasing} */
    Elastic: (amplitude = 1, period = .3) => {
        const a = clamp(+amplitude, 1, 10);
        const p = clamp(+period, minValue, 2);
        const s = (p / doublePI) * asin(1 / a);
        const e = doublePI / p;
        return t => t === 0 || t === 1 ? t : -a * pow(2, -10 * (1 - t)) * sin(((1 - t) - s) * e);
    }
};
/**
 * @callback EaseType
 * @param {EasingFunction} Ease
 * @return {EasingFunction}
 */
/** @type {Record<String, EaseType>} */
const easeTypes = {
    in: easeIn => t => easeIn(t),
    out: easeIn => t => 1 - easeIn(1 - t),
    inOut: easeIn => t => t < .5 ? easeIn(t * 2) / 2 : 1 - easeIn(t * -2 + 2) / 2,
    outIn: easeIn => t => t < .5 ? (1 - easeIn(1 - t * 2)) / 2 : (easeIn(t * 2 - 1) + 1) / 2,
};
/**
 * @param  {String} string
 * @param  {Record<String, EasesFactory|EasingFunction>} easesFunctions
 * @param  {Object} easesLookups
 * @return {EasingFunction}
 */
const parseEaseString = (string, easesFunctions, easesLookups) => {
    if (easesLookups[string])
        return easesLookups[string];
    if (string.indexOf('(') <= -1) {
        const hasParams = easeTypes[string] || string.includes('Back') || string.includes('Elastic');
        const parsedFn = /** @type {EasingFunction} */ (hasParams ? /** @type {EasesFactory} */ (easesFunctions[string])() : easesFunctions[string]);
        return parsedFn ? easesLookups[string] = parsedFn : none;
    }
    else {
        const split = string.slice(0, -1).split('(');
        const parsedFn = /** @type {EasesFactory} */ (easesFunctions[split[0]]);
        return parsedFn ? easesLookups[string] = parsedFn(...split[1].split(',')) : none;
    }
};
/**
 * @typedef  {Object} EasesFunctions
 * @property {typeof linear} linear
 * @property {typeof irregular} irregular
 * @property {typeof steps} steps
 * @property {typeof cubicBezier} cubicBezier
 * @property {PowerEasing} in
 * @property {PowerEasing} out
 * @property {PowerEasing} inOut
 * @property {PowerEasing} outIn
 * @property {EasingFunction} inQuad
 * @property {EasingFunction} outQuad
 * @property {EasingFunction} inOutQuad
 * @property {EasingFunction} outInQuad
 * @property {EasingFunction} inCubic
 * @property {EasingFunction} outCubic
 * @property {EasingFunction} inOutCubic
 * @property {EasingFunction} outInCubic
 * @property {EasingFunction} inQuart
 * @property {EasingFunction} outQuart
 * @property {EasingFunction} inOutQuart
 * @property {EasingFunction} outInQuart
 * @property {EasingFunction} inQuint
 * @property {EasingFunction} outQuint
 * @property {EasingFunction} inOutQuint
 * @property {EasingFunction} outInQuint
 * @property {EasingFunction} inSine
 * @property {EasingFunction} outSine
 * @property {EasingFunction} inOutSine
 * @property {EasingFunction} outInSine
 * @property {EasingFunction} inCirc
 * @property {EasingFunction} outCirc
 * @property {EasingFunction} inOutCirc
 * @property {EasingFunction} outInCirc
 * @property {EasingFunction} inExpo
 * @property {EasingFunction} outExpo
 * @property {EasingFunction} inOutExpo
 * @property {EasingFunction} outInExpo
 * @property {EasingFunction} inBounce
 * @property {EasingFunction} outBounce
 * @property {EasingFunction} inOutBounce
 * @property {EasingFunction} outInBounce
 * @property {BackEasing} inBack
 * @property {BackEasing} outBack
 * @property {BackEasing} inOutBack
 * @property {BackEasing} outInBack
 * @property {ElasticEasing} inElastic
 * @property {ElasticEasing} outElastic
 * @property {ElasticEasing} inOutElastic
 * @property {ElasticEasing} outInElastic
 */
const eases = ( /*#__PURE__*/(() => {
    const list = { linear, irregular, steps, cubicBezier };
    for (let type in easeTypes) {
        for (let name in easeInFunctions) {
            const easeIn = easeInFunctions[name];
            const easeType = easeTypes[type];
            list[type + name] = /** @type {EasesFactory|EasingFunction} */ (name === emptyString || name === 'Back' || name === 'Elastic' ?
                (a, b) => easeType(/** @type {EasesFactory} */ (easeIn)(a, b)) :
                easeType(/** @type {EasingFunction} */ (easeIn)));
        }
    }
    return /** @type {EasesFunctions} */ (list);
})());
/** @type {Record<String, EasingFunction>} */
const JSEasesLookups = { linear: none };
/**
 * @param  {EasingParam} ease
 * @return {EasingFunction}
 */
const parseEasings = ease => isFnc(ease) ? ease :
    isStr(ease) ? parseEaseString(/** @type {String} */ (ease), eases, JSEasesLookups) :
        none;


const propertyNamesCache = {};
/**
 * @param  {String} propertyName
 * @param  {Target} target
 * @param  {tweenTypes} tweenType
 * @return {String}
 */
const sanitizePropertyName = (propertyName, target, tweenType) => {
    if (tweenType === tweenTypes.TRANSFORM) {
        const t = shortTransforms.get(propertyName);
        return t ? t : propertyName;
    }
    else if (tweenType === tweenTypes.CSS ||
        // Handle special cases where properties like "strokeDashoffset" needs to be set as "stroke-dashoffset"
        // but properties like "baseFrequency" should stay in lowerCamelCase
        (tweenType === tweenTypes.ATTRIBUTE && (isSvg(target) && propertyName in /** @type {DOMTarget} */ (target).style))) {
        const cachedPropertyName = propertyNamesCache[propertyName];
        if (cachedPropertyName) {
            return cachedPropertyName;
        }
        else {
            const lowerCaseName = propertyName ? toLowerCase(propertyName) : propertyName;
            propertyNamesCache[propertyName] = lowerCaseName;
            return lowerCaseName;
        }
    }
    else {
        return propertyName;
    }
};


const angleUnitsMap = { 'deg': 1, 'rad': 180 / PI, 'turn': 360 };
const convertedValuesCache = {};
/**
 * @param  {DOMTarget} el
 * @param  {TweenDecomposedValue} decomposedValue
 * @param  {String} unit
 * @param  {Boolean} [force]
 * @return {TweenDecomposedValue}
 */
const convertValueUnit = (el, decomposedValue, unit, force = false) => {
    const currentUnit = decomposedValue.u;
    const currentNumber = decomposedValue.n;
    if (decomposedValue.t === valueTypes.UNIT && currentUnit === unit) { // TODO: Check if checking against the same unit string is necessary
        return decomposedValue;
    }
    const cachedKey = currentNumber + currentUnit + unit;
    const cached = convertedValuesCache[cachedKey];
    if (!isUnd(cached) && !force) {
        decomposedValue.n = cached;
    }
    else {
        let convertedValue;
        if (currentUnit in angleUnitsMap) {
            convertedValue = currentNumber * angleUnitsMap[currentUnit] / angleUnitsMap[unit];
        }
        else {
            const baseline = 100;
            const tempEl = /** @type {DOMTarget} */ (el.cloneNode());
            const parentNode = el.parentNode;
            const parentEl = (parentNode && (parentNode !== doc)) ? parentNode : doc.body;
            parentEl.appendChild(tempEl);
            const elStyle = tempEl.style;
            elStyle.width = baseline + currentUnit;
            const currentUnitWidth = /** @type {HTMLElement} */ (tempEl).offsetWidth || baseline;
            elStyle.width = baseline + unit;
            const newUnitWidth = /** @type {HTMLElement} */ (tempEl).offsetWidth || baseline;
            const factor = currentUnitWidth / newUnitWidth;
            parentEl.removeChild(tempEl);
            convertedValue = factor * currentNumber;
        }
        decomposedValue.n = convertedValue;
        convertedValuesCache[cachedKey] = convertedValue;
    }
    decomposedValue.t === valueTypes.UNIT;
    decomposedValue.u = unit;
    return decomposedValue;
};


/**
 * @template {Renderable} T
 * @param {T} renderable
 * @return {T}
 */
const cleanInlineStyles = renderable => {
    // Allow cleanInlineStyles() to be called on timelines
    if (renderable._hasChildren) {
        forEachChildren(renderable, cleanInlineStyles, true);
    }
    else {
        const animation = /** @type {JSAnimation} */ (renderable);
        animation.pause();
        forEachChildren(animation, (/** @type {Tween} */ tween) => {
            const tweenProperty = tween.property;
            const tweenTarget = tween.target;
            if (tweenTarget[isDomSymbol]) {
                const targetStyle = /** @type {DOMTarget} */ (tweenTarget).style;
                const originalInlinedValue = animation._inlineStyles[tweenProperty];
                if (tween._tweenType === tweenTypes.TRANSFORM) {
                    const cachedTransforms = tweenTarget[transformsSymbol];
                    if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
                        delete cachedTransforms[tweenProperty];
                    }
                    else {
                        cachedTransforms[tweenProperty] = originalInlinedValue;
                    }
                    if (tween._renderTransforms) {
                        if (!Object.keys(cachedTransforms).length) {
                            targetStyle.removeProperty('transform');
                        }
                        else {
                            let str = emptyString;
                            for (let key in cachedTransforms) {
                                str += transformsFragmentStrings[key] + cachedTransforms[key] + ') ';
                            }
                            targetStyle.transform = str;
                        }
                    }
                }
                else {
                    if (isUnd(originalInlinedValue) || originalInlinedValue === emptyString) {
                        targetStyle.removeProperty(tweenProperty);
                    }
                    else {
                        targetStyle[tweenProperty] = originalInlinedValue;
                    }
                }
                if (animation._tail === tween) {
                    animation.targets.forEach(t => {
                        if (t.getAttribute && t.getAttribute('style') === emptyString) {
                            t.removeAttribute('style');
                        }
                    });
                }
            }
        });
    }
    return renderable;
};
// Defines decomposed values target objects only once and mutate their properties later to avoid GC
// TODO: Maybe move the objects creation to values.js and use the decompose function to create the base object
const fromTargetObject = createDecomposedValueTargetObject();
const toTargetObject = createDecomposedValueTargetObject();
const toFunctionStore = { func: null };
const keyframesTargetArray = [null];
const fastSetValuesArray = [null, null];
/** @type {TweenKeyValue} */
const keyObjectTarget = { to: null };
let tweenId = 0;
let keyframes;
/** @type {TweenParamsOptions & TweenValues} */
let key;
/**
 * @param {DurationKeyframes | PercentageKeyframes} keyframes
 * @param {AnimationParams} parameters
 * @return {AnimationParams}
 */
const generateKeyframes = (keyframes, parameters) => {
    /** @type {AnimationParams} */
    const properties = {};
    if (isArr(keyframes)) {
        const propertyNames = [].concat(... /** @type {DurationKeyframes} */(keyframes).map(key => Object.keys(key))).filter(isKey);
        for (let i = 0, l = propertyNames.length; i < l; i++) {
            const propName = propertyNames[i];
            const propArray = /** @type {DurationKeyframes} */ (keyframes).map(key => {
                /** @type {TweenKeyValue} */
                const newKey = {};
                for (let p in key) {
                    const keyValue = /** @type {TweenPropValue} */ (key[p]);
                    if (isKey(p)) {
                        if (p === propName) {
                            newKey.to = keyValue;
                        }
                    }
                    else {
                        newKey[p] = keyValue;
                    }
                }
                return newKey;
            });
            properties[propName] = /** @type {ArraySyntaxValue} */ (propArray);
        }
    }
    else {
        const totalDuration = /** @type {Number} */ (setValue(parameters.duration, globals.defaults.duration));
        const keys = Object.keys(keyframes)
            .map(key => { return { o: parseFloat(key) / 100, p: keyframes[key] }; })
            .sort((a, b) => a.o - b.o);
        keys.forEach(key => {
            const offset = key.o;
            const prop = key.p;
            for (let name in prop) {
                if (isKey(name)) {
                    let propArray = /** @type {Array} */ (properties[name]);
                    if (!propArray)
                        propArray = properties[name] = [];
                    const duration = offset * totalDuration;
                    let length = propArray.length;
                    let prevKey = propArray[length - 1];
                    const keyObj = { to: prop[name] };
                    let durProgress = 0;
                    for (let i = 0; i < length; i++) {
                        durProgress += propArray[i].duration;
                    }
                    if (length === 1) {
                        keyObj.from = prevKey.to;
                    }
                    if (prop.ease) {
                        keyObj.ease = prop.ease;
                    }
                    keyObj.duration = duration - (length ? durProgress : 0);
                    propArray.push(keyObj);
                }
            }
            return key;
        });
        for (let name in properties) {
            const propArray = /** @type {Array} */ (properties[name]);
            let prevEase;
            // let durProgress = 0
            for (let i = 0, l = propArray.length; i < l; i++) {
                const prop = propArray[i];
                // Emulate WAPPI easing parameter position
                const currentEase = prop.ease;
                prop.ease = prevEase ? prevEase : undefined;
                prevEase = currentEase;
                // durProgress += prop.duration;
                // if (i === l - 1 && durProgress !== totalDuration) {
                //   propArray.push({ from: prop.to, ease: prop.ease, duration: totalDuration - durProgress })
                // }
            }
            if (!propArray[0].duration) {
                propArray.shift();
            }
        }
    }
    return properties;
};
class JSAnimation extends Timer {
    /**
     * @param {TargetsParam} targets
     * @param {AnimationParams} parameters
     * @param {Timeline} [parent]
     * @param {Number} [parentPosition]
     * @param {Boolean} [fastSet=false]
     * @param {Number} [index=0]
     * @param {Number} [length=0]
     */
    constructor(targets, parameters, parent, parentPosition, fastSet = false, index = 0, length = 0) {
        super(/** @type {TimerParams&AnimationParams} */ (parameters), parent, parentPosition);
        const parsedTargets = registerTargets(targets);
        const targetsLength = parsedTargets.length;
        // If the parameters object contains a "keyframes" property, convert all the keyframes values to regular properties
        const kfParams = /** @type {AnimationParams} */ (parameters).keyframes;
        const params = /** @type {AnimationParams} */ (kfParams ? mergeObjects(generateKeyframes(/** @type {DurationKeyframes} */ (kfParams), parameters), parameters) : parameters);
        const { delay, duration, ease, playbackEase, modifier, composition, onRender, } = params;
        const animDefaults = parent ? parent.defaults : globals.defaults;
        const animaPlaybackEase = setValue(playbackEase, animDefaults.playbackEase);
        const animEase = animaPlaybackEase ? parseEasings(animaPlaybackEase) : null;
        const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ (ease).ease);
        const tEasing = hasSpring ? /** @type {Spring} */ (ease).ease : setValue(ease, animEase ? 'linear' : animDefaults.ease);
        const tDuration = hasSpring ? /** @type {Spring} */ (ease).duration : setValue(duration, animDefaults.duration);
        const tDelay = setValue(delay, animDefaults.delay);
        const tModifier = modifier || animDefaults.modifier;
        // If no composition is defined and the targets length is high (>= 1000) set the composition to 'none' (0) for faster tween creation
        const tComposition = isUnd(composition) && targetsLength >= K ? compositionTypes.none : !isUnd(composition) ? composition : animDefaults.composition;
        // TODO: Do not create an empty object until we know the animation will generate inline styles
        const animInlineStyles = {};
        // const absoluteOffsetTime = this._offset;
        const absoluteOffsetTime = this._offset + (parent ? parent._offset : 0);
        let iterationDuration = NaN;
        let iterationDelay = NaN;
        let animationAnimationLength = 0;
        let shouldTriggerRender = 0;
        for (let targetIndex = 0; targetIndex < targetsLength; targetIndex++) {
            const target = parsedTargets[targetIndex];
            const ti = index || targetIndex;
            const tl = length || targetsLength;
            let lastTransformGroupIndex = NaN;
            let lastTransformGroupLength = NaN;
            for (let p in params) {
                if (isKey(p)) {
                    const tweenType = getTweenType(target, p);
                    const propName = sanitizePropertyName(p, target, tweenType);
                    let propValue = params[p];
                    const isPropValueArray = isArr(propValue);
                    if (fastSet && !isPropValueArray) {
                        fastSetValuesArray[0] = propValue;
                        fastSetValuesArray[1] = propValue;
                        propValue = fastSetValuesArray;
                    }
                    // TODO: Allow nested keyframes inside ObjectValue value (prop: { to: [.5, 1, .75, 2, 3] })
                    // Normalize property values to valid keyframe syntax:
                    // [x, y] to [{to: [x, y]}] or {to: x} to [{to: x}] or keep keys syntax [{}, {}, {}...]
                    // const keyframes = isArr(propValue) ? propValue.length === 2 && !isObj(propValue[0]) ? [{ to: propValue }] : propValue : [propValue];
                    if (isPropValueArray) {
                        const arrayLength = /** @type {Array} */ (propValue).length;
                        const isNotObjectValue = !isObj(propValue[0]);
                        // Convert [x, y] to [{to: [x, y]}]
                        if (arrayLength === 2 && isNotObjectValue) {
                            keyObjectTarget.to = /** @type {TweenParamValue} */ ( /** @type {unknown} */(propValue));
                            keyframesTargetArray[0] = keyObjectTarget;
                            keyframes = keyframesTargetArray;
                            // Convert [x, y, z] to [[x, y], z]
                        }
                        else if (arrayLength > 2 && isNotObjectValue) {
                            keyframes = [];
                            /** @type {Array.<Number>} */ (propValue).forEach((v, i) => {
                                if (!i) {
                                    fastSetValuesArray[0] = v;
                                }
                                else if (i === 1) {
                                    fastSetValuesArray[1] = v;
                                    keyframes.push(fastSetValuesArray);
                                }
                                else {
                                    keyframes.push(v);
                                }
                            });
                        }
                        else {
                            keyframes = /** @type {Array.<TweenKeyValue>} */ (propValue);
                        }
                    }
                    else {
                        keyframesTargetArray[0] = propValue;
                        keyframes = keyframesTargetArray;
                    }
                    let siblings = null;
                    let prevTween = null;
                    let firstTweenChangeStartTime = NaN;
                    let lastTweenChangeEndTime = 0;
                    let tweenIndex = 0;
                    for (let l = keyframes.length; tweenIndex < l; tweenIndex++) {
                        const keyframe = keyframes[tweenIndex];
                        if (isObj(keyframe)) {
                            key = keyframe;
                        }
                        else {
                            keyObjectTarget.to = /** @type {TweenParamValue} */ (keyframe);
                            key = keyObjectTarget;
                        }
                        toFunctionStore.func = null;
                        const computedToValue = getFunctionValue(key.to, target, ti, tl, toFunctionStore);
                        let tweenToValue;
                        // Allows function based values to return an object syntax value ({to: v})
                        if (isObj(computedToValue) && !isUnd(computedToValue.to)) {
                            key = computedToValue;
                            tweenToValue = computedToValue.to;
                        }
                        else {
                            tweenToValue = computedToValue;
                        }
                        const tweenFromValue = getFunctionValue(key.from, target, ti, tl);
                        const keyEasing = key.ease;
                        const hasSpring = !isUnd(keyEasing) && !isUnd(/** @type {Spring} */ (keyEasing).ease);
                        // Easing are treated differently and don't accept function based value to prevent having to pass a function wrapper that returns an other function all the time
                        const tweenEasing = hasSpring ? /** @type {Spring} */ (keyEasing).ease : keyEasing || tEasing;
                        // Calculate default individual keyframe duration by dividing the tl of keyframes
                        const tweenDuration = hasSpring ? /** @type {Spring} */ (keyEasing).duration : getFunctionValue(setValue(key.duration, (l > 1 ? getFunctionValue(tDuration, target, ti, tl) / l : tDuration)), target, ti, tl);
                        // Default delay value should only be applied to the first tween
                        const tweenDelay = getFunctionValue(setValue(key.delay, (!tweenIndex ? tDelay : 0)), target, ti, tl);
                        const computedComposition = getFunctionValue(setValue(key.composition, tComposition), target, ti, tl);
                        const tweenComposition = isNum(computedComposition) ? computedComposition : compositionTypes[computedComposition];
                        // Modifiers are treated differently and don't accept function based value to prevent having to pass a function wrapper
                        const tweenModifier = key.modifier || tModifier;
                        const hasFromvalue = !isUnd(tweenFromValue);
                        const hasToValue = !isUnd(tweenToValue);
                        const isFromToArray = isArr(tweenToValue);
                        const isFromToValue = isFromToArray || (hasFromvalue && hasToValue);
                        const tweenStartTime = prevTween ? lastTweenChangeEndTime + tweenDelay : tweenDelay;
                        const absoluteStartTime = absoluteOffsetTime + tweenStartTime;
                        // Force a onRender callback if the animation contains at least one from value and autoplay is set to false
                        if (!shouldTriggerRender && (hasFromvalue || isFromToArray))
                            shouldTriggerRender = 1;
                        let prevSibling = prevTween;
                        if (tweenComposition !== compositionTypes.none) {
                            if (!siblings)
                                siblings = getTweenSiblings(target, propName);
                            let nextSibling = siblings._head;
                            // Iterate trough all the next siblings until we find a sibling with an equal or inferior start time
                            while (nextSibling && !nextSibling._isOverridden && nextSibling._absoluteStartTime <= absoluteStartTime) {
                                prevSibling = nextSibling;
                                nextSibling = nextSibling._nextRep;
                                // Overrides all the next siblings if the next sibling starts at the same time of after as the new tween start time
                                if (nextSibling && nextSibling._absoluteStartTime >= absoluteStartTime) {
                                    while (nextSibling) {
                                        overrideTween(nextSibling);
                                        // This will ends both the current while loop and the upper one once all the next sibllings have been overriden
                                        nextSibling = nextSibling._nextRep;
                                    }
                                }
                            }
                        }
                        // Decompose values
                        if (isFromToValue) {
                            decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[0], target, ti, tl) : tweenFromValue, fromTargetObject);
                            decomposeRawValue(isFromToArray ? getFunctionValue(tweenToValue[1], target, ti, tl, toFunctionStore) : tweenToValue, toTargetObject);
                            if (fromTargetObject.t === valueTypes.NUMBER) {
                                if (prevSibling) {
                                    if (prevSibling._valueType === valueTypes.UNIT) {
                                        fromTargetObject.t = valueTypes.UNIT;
                                        fromTargetObject.u = prevSibling._unit;
                                    }
                                }
                                else {
                                    decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue);
                                    if (decomposedOriginalValue.t === valueTypes.UNIT) {
                                        fromTargetObject.t = valueTypes.UNIT;
                                        fromTargetObject.u = decomposedOriginalValue.u;
                                    }
                                }
                            }
                        }
                        else {
                            if (hasToValue) {
                                decomposeRawValue(tweenToValue, toTargetObject);
                            }
                            else {
                                if (prevTween) {
                                    decomposeTweenValue(prevTween, toTargetObject);
                                }
                                else {
                                    // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                                        getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), toTargetObject);
                                }
                            }
                            if (hasFromvalue) {
                                decomposeRawValue(tweenFromValue, fromTargetObject);
                            }
                            else {
                                if (prevTween) {
                                    decomposeTweenValue(prevTween, fromTargetObject);
                                }
                                else {
                                    decomposeRawValue(parent && prevSibling && prevSibling.parent.parent === parent ? prevSibling._value :
                                        // No need to get and parse the original value if the tween is part of a timeline and has a previous sibling part of the same timeline
                                        getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), fromTargetObject);
                                }
                            }
                        }
                        // Apply operators
                        if (fromTargetObject.o) {
                            fromTargetObject.n = getRelativeValue(!prevSibling ? decomposeRawValue(getOriginalAnimatableValue(target, propName, tweenType, animInlineStyles), decomposedOriginalValue).n : prevSibling._toNumber, fromTargetObject.n, fromTargetObject.o);
                        }
                        if (toTargetObject.o) {
                            toTargetObject.n = getRelativeValue(fromTargetObject.n, toTargetObject.n, toTargetObject.o);
                        }
                        // Values omogenisation in cases of type difference between "from" and "to"
                        if (fromTargetObject.t !== toTargetObject.t) {
                            if (fromTargetObject.t === valueTypes.COMPLEX || toTargetObject.t === valueTypes.COMPLEX) {
                                const complexValue = fromTargetObject.t === valueTypes.COMPLEX ? fromTargetObject : toTargetObject;
                                const notComplexValue = fromTargetObject.t === valueTypes.COMPLEX ? toTargetObject : fromTargetObject;
                                notComplexValue.t = valueTypes.COMPLEX;
                                notComplexValue.s = cloneArray(complexValue.s);
                                notComplexValue.d = complexValue.d.map(() => notComplexValue.n);
                            }
                            else if (fromTargetObject.t === valueTypes.UNIT || toTargetObject.t === valueTypes.UNIT) {
                                const unitValue = fromTargetObject.t === valueTypes.UNIT ? fromTargetObject : toTargetObject;
                                const notUnitValue = fromTargetObject.t === valueTypes.UNIT ? toTargetObject : fromTargetObject;
                                notUnitValue.t = valueTypes.UNIT;
                                notUnitValue.u = unitValue.u;
                            }
                            else if (fromTargetObject.t === valueTypes.COLOR || toTargetObject.t === valueTypes.COLOR) {
                                const colorValue = fromTargetObject.t === valueTypes.COLOR ? fromTargetObject : toTargetObject;
                                const notColorValue = fromTargetObject.t === valueTypes.COLOR ? toTargetObject : fromTargetObject;
                                notColorValue.t = valueTypes.COLOR;
                                notColorValue.s = colorValue.s;
                                notColorValue.d = [0, 0, 0, 1];
                            }
                        }
                        // Unit conversion
                        if (fromTargetObject.u !== toTargetObject.u) {
                            let valueToConvert = toTargetObject.u ? fromTargetObject : toTargetObject;
                            valueToConvert = convertValueUnit(/** @type {DOMTarget} */ (target), valueToConvert, toTargetObject.u ? toTargetObject.u : fromTargetObject.u, false);
                            // TODO:
                            // convertValueUnit(target, to.u ? from : to, to.u ? to.u : from.u);
                        }
                        // Fill in non existing complex values
                        if (toTargetObject.d && fromTargetObject.d && (toTargetObject.d.length !== fromTargetObject.d.length)) {
                            const longestValue = fromTargetObject.d.length > toTargetObject.d.length ? fromTargetObject : toTargetObject;
                            const shortestValue = longestValue === fromTargetObject ? toTargetObject : fromTargetObject;
                            // TODO: Check if n should be used instead of 0 for default complex values
                            shortestValue.d = longestValue.d.map((_, i) => isUnd(shortestValue.d[i]) ? 0 : shortestValue.d[i]);
                            shortestValue.s = cloneArray(longestValue.s);
                        }
                        // Tween factory
                        // Rounding is necessary here to minimize floating point errors
                        const tweenUpdateDuration = round(+tweenDuration || minValue, 12);
                        /** @type {Tween} */
                        const tween = {
                            parent: this,
                            id: tweenId++,
                            property: propName,
                            target: target,
                            _value: null,
                            _func: toFunctionStore.func,
                            _ease: parseEasings(tweenEasing),
                            _fromNumbers: cloneArray(fromTargetObject.d),
                            _toNumbers: cloneArray(toTargetObject.d),
                            _strings: cloneArray(toTargetObject.s),
                            _fromNumber: fromTargetObject.n,
                            _toNumber: toTargetObject.n,
                            _numbers: cloneArray(fromTargetObject.d),
                            _number: fromTargetObject.n,
                            _unit: toTargetObject.u,
                            _modifier: tweenModifier,
                            _currentTime: 0,
                            _startTime: tweenStartTime,
                            _delay: +tweenDelay,
                            _updateDuration: tweenUpdateDuration,
                            _changeDuration: tweenUpdateDuration,
                            _absoluteStartTime: absoluteStartTime,
                            // NOTE: Investigate bit packing to stores ENUM / BOOL
                            _tweenType: tweenType,
                            _valueType: toTargetObject.t,
                            _composition: tweenComposition,
                            _isOverlapped: 0,
                            _isOverridden: 0,
                            _renderTransforms: 0,
                            _prevRep: null,
                            _nextRep: null,
                            _prevAdd: null,
                            _nextAdd: null,
                            _prev: null,
                            _next: null,
                        };
                        if (tweenComposition !== compositionTypes.none) {
                            composeTween(tween, siblings);
                        }
                        if (isNaN(firstTweenChangeStartTime)) {
                            firstTweenChangeStartTime = tween._startTime;
                        }
                        // Rounding is necessary here to minimize floating point errors
                        lastTweenChangeEndTime = round(tweenStartTime + tweenUpdateDuration, 12);
                        prevTween = tween;
                        animationAnimationLength++;
                        addChild(this, tween);
                    }
                    // Update animation timings with the added tweens properties
                    if (isNaN(iterationDelay) || firstTweenChangeStartTime < iterationDelay) {
                        iterationDelay = firstTweenChangeStartTime;
                    }
                    if (isNaN(iterationDuration) || lastTweenChangeEndTime > iterationDuration) {
                        iterationDuration = lastTweenChangeEndTime;
                    }
                    // TODO: Find a way to inline tween._renderTransforms = 1 here
                    if (tweenType === tweenTypes.TRANSFORM) {
                        lastTransformGroupIndex = animationAnimationLength - tweenIndex;
                        lastTransformGroupLength = animationAnimationLength;
                    }
                }
            }
            // Set _renderTransforms to last transform property to correctly render the transforms list
            if (!isNaN(lastTransformGroupIndex)) {
                let i = 0;
                forEachChildren(this, (/** @type {Tween} */ tween) => {
                    if (i >= lastTransformGroupIndex && i < lastTransformGroupLength) {
                        tween._renderTransforms = 1;
                        if (tween._composition === compositionTypes.blend) {
                            forEachChildren(additive.animation, (/** @type {Tween} */ additiveTween) => {
                                if (additiveTween.id === tween.id) {
                                    additiveTween._renderTransforms = 1;
                                }
                            });
                        }
                    }
                    i++;
                });
            }
        }
        if (!targetsLength) {
            console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
        }
        if (iterationDelay) {
            forEachChildren(this, (/** @type {Tween} */ tween) => {
                // If (startTime - delay) equals 0, this means the tween is at the begining of the animation so we need to trim the delay too
                if (!(tween._startTime - tween._delay)) {
                    tween._delay -= iterationDelay;
                }
                tween._startTime -= iterationDelay;
            });
            iterationDuration -= iterationDelay;
        }
        else {
            iterationDelay = 0;
        }
        // Prevents iterationDuration to be NaN if no valid animatable props have been provided
        // Prevents _iterationCount to be NaN if no valid animatable props have been provided
        if (!iterationDuration) {
            iterationDuration = minValue;
            this.iterationCount = 0;
        }
        /** @type {TargetsArray} */
        this.targets = parsedTargets;
        /** @type {Number} */
        this.duration = iterationDuration === minValue ? minValue : clampInfinity(((iterationDuration + this._loopDelay) * this.iterationCount) - this._loopDelay) || minValue;
        /** @type {Callback<this>} */
        this.onRender = onRender || animDefaults.onRender;
        /** @type {EasingFunction} */
        this._ease = animEase;
        /** @type {Number} */
        this._delay = iterationDelay;
        // NOTE: I'm keeping delay values separated from offsets in timelines because delays can override previous tweens and it could be confusing to debug a timeline with overridden tweens and no associated visible delays.
        // this._delay = parent ? 0 : iterationDelay;
        // this._offset += parent ? iterationDelay : 0;
        /** @type {Number} */
        this.iterationDuration = iterationDuration;
        /** @type {{}} */
        this._inlineStyles = animInlineStyles;
        if (!this._autoplay && shouldTriggerRender)
            this.onRender(this);
    }
    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
        const currentDuration = this.duration;
        if (currentDuration === clampZero(newDuration))
            return this;
        const timeScale = newDuration / currentDuration;
        // NOTE: Find a better way to handle the stretch of an animation after stretch = 0
        forEachChildren(this, (/** @type {Tween} */ tween) => {
            // Rounding is necessary here to minimize floating point errors
            tween._updateDuration = clampZero(round(tween._updateDuration * timeScale, 12));
            tween._changeDuration = clampZero(round(tween._changeDuration * timeScale, 12));
            tween._currentTime *= timeScale;
            tween._startTime *= timeScale;
            tween._absoluteStartTime *= timeScale;
        });
        return super.stretch(newDuration);
    }
    /**
     * @return {this}
     */
    refresh() {
        forEachChildren(this, (/** @type {Tween} */ tween) => {
            const ogValue = getOriginalAnimatableValue(tween.target, tween.property, tween._tweenType);
            decomposeRawValue(ogValue, decomposedOriginalValue);
            tween._fromNumbers = cloneArray(decomposedOriginalValue.d);
            tween._fromNumber = decomposedOriginalValue.n;
            if (tween._func) {
                decomposeRawValue(tween._func(), toTargetObject);
                tween._toNumbers = cloneArray(toTargetObject.d);
                tween._strings = cloneArray(toTargetObject.s);
                tween._toNumber = toTargetObject.n;
            }
        });
        return this;
    }
    /**
     * Cancel the animation and revert all the values affected by this animation to their original state
     * @return {this}
     */
    revert() {
        super.revert();
        return cleanInlineStyles(this);
    }
    /**
     * @param  {Callback<this>} [callback]
     * @return {Promise}
     */
    then(callback) {
        return super.then(callback);
    }
}
/**
 * @param {TargetsParam} targets
 * @param {AnimationParams} parameters
 * @return {JSAnimation}
 */
const animate = (targets, parameters) => new JSAnimation(targets, parameters, null, 0, false).init();


/**
 * Converts an easing function into a valid CSS linear() timing function string
 * @param {EasingFunction} fn
 * @param {number} [samples=100]
 * @returns {string} CSS linear() timing function
 */
const easingToLinear = (fn, samples = 100) => {
    const points = [];
    for (let i = 0; i <= samples; i++)
        points.push(fn(i / samples));
    return `linear(${points.join(', ')})`;
};
const WAAPIEasesLookups = {
    in: 'ease-in',
    out: 'ease-out',
    inOut: 'ease-in-out',
};
const WAAPIeases = /*#__PURE__*/ (() => {
    const list = {};
    for (let type in easeTypes)
        list[type] = a => easeTypes[type](easeInPower(a));
    return /** @type {Record<String, EasingFunction>} */ (list);
})();
/**
 * @param  {EasingParam} ease
 * @return {String}
 */
const parseWAAPIEasing = (ease) => {
    let parsedEase = WAAPIEasesLookups[ease];
    if (parsedEase)
        return parsedEase;
    parsedEase = 'linear';
    if (isStr(ease)) {
        if (stringStartsWith(ease, 'linear') ||
            stringStartsWith(ease, 'cubic-') ||
            stringStartsWith(ease, 'steps') ||
            stringStartsWith(ease, 'ease')) {
            parsedEase = ease;
        }
        else if (stringStartsWith(ease, 'cubicB')) {
            parsedEase = toLowerCase(ease);
        }
        else {
            const parsed = parseEaseString(ease, WAAPIeases, WAAPIEasesLookups);
            if (isFnc(parsed))
                parsedEase = parsed === none ? 'linear' : easingToLinear(parsed);
        }
    }
    else if (isFnc(ease)) {
        const easing = easingToLinear(ease);
        if (easing)
            parsedEase = easing;
    }
    else if ( /** @type {Spring} */(ease).ease) {
        parsedEase = easingToLinear(/** @type {Spring} */ (ease).ease);
    }
    return WAAPIEasesLookups[ease] = parsedEase;
};
/**
 * @typedef {String|Number|Array<String>|Array<Number>} WAAPITweenValue
 */
/**
 * @callback WAAPIFunctionvalue
 * @param {DOMTarget} target - The animated target
 * @param {Number} index - The target index
 * @param {Number} length - The total number of animated targets
 * @return {WAAPITweenValue}
 */
/**
 * @typedef {WAAPITweenValue|WAAPIFunctionvalue|Array<String|Number|WAAPIFunctionvalue>} WAAPIKeyframeValue
 */
/**
 * @typedef {(animation: WAAPIAnimation) => void} WAAPICallback
 */
/**
 * @typedef {Object} WAAPITweenOptions
 * @property {WAAPIKeyframeValue} [to]
 * @property {WAAPIKeyframeValue} [from]
 * @property {Number|WAAPIFunctionvalue} [duration]
 * @property {Number|WAAPIFunctionvalue} [delay]
 * @property {EasingParam} [ease]
 * @property {CompositeOperation} [composition]
 */
/**
 * @typedef {Object} WAAPIAnimationOptions
 * @property {Number|Boolean} [loop]
 * @property {Boolean} [Reversed]
 * @property {Boolean} [Alternate]
 * @property {Boolean|ScrollObserver} [autoplay]
 * @property {Number} [playbackRate]
 * @property {Number|WAAPIFunctionvalue} [duration]
 * @property {Number|WAAPIFunctionvalue} [delay]
 * @property {EasingParam} [ease]
 * @property {CompositeOperation} [composition]
 * @property {WAAPICallback} [onComplete]
 */
/**
 * @typedef {Record<String, WAAPIKeyframeValue | WAAPIAnimationOptions | Boolean | ScrollObserver | WAAPICallback | EasingParam | WAAPITweenOptions> & WAAPIAnimationOptions} WAAPIAnimationParams
 */
const transformsShorthands = ['x', 'y', 'z'];
const commonDefaultPXProperties = [
    'perspective',
    'width',
    'height',
    'margin',
    'padding',
    'top',
    'right',
    'bottom',
    'left',
    'borderWidth',
    'fontSize',
    'borderRadius',
    ...transformsShorthands
];
const validIndividualTransforms = [...transformsShorthands, ...validTransforms.filter(t => ['X', 'Y', 'Z'].some(axis => t.endsWith(axis)))];
// Setting it to true in case CSS.registerProperty is not supported will automatically skip the registration and fallback to no animation
let transformsPropertiesRegistered = isBrowser && (isUnd(CSS) || !Object.hasOwnProperty.call(CSS, 'registerProperty'));
const registerTransformsProperties = () => {
    validTransforms.forEach(t => {
        const isSkew = stringStartsWith(t, 'skew');
        const isScale = stringStartsWith(t, 'scale');
        const isRotate = stringStartsWith(t, 'rotate');
        const isTranslate = stringStartsWith(t, 'translate');
        const isAngle = isRotate || isSkew;
        const syntax = isAngle ? '<angle>' : isScale ? "<number>" : isTranslate ? "<length-percentage>" : "*";
        CSS.registerProperty({
            name: '--' + t,
            syntax,
            inherits: false,
            initialValue: isTranslate ? '0px' : isAngle ? '0deg' : isScale ? '1' : '0',
        });
    });
    transformsPropertiesRegistered = true;
};
const WAAPIAnimationsLookups = {
    _head: null,
    _tail: null,
};
/**
 * @param {DOMTarget} $el
 * @param {String} [property]
 * @param {WAAPIAnimation} [parent]
 */
const removeWAAPIAnimation = ($el, property, parent) => {
    let nextLookup = WAAPIAnimationsLookups._head;
    while (nextLookup) {
        const next = nextLookup._next;
        const matchTarget = nextLookup.$el === $el;
        const matchProperty = !property || nextLookup.property === property;
        const matchParent = !parent || nextLookup.parent === parent;
        if (matchTarget && matchProperty && matchParent) {
            const anim = nextLookup.animation;
            try {
                anim.commitStyles();
            }
            catch { }
            anim.cancel();
            removeChild(WAAPIAnimationsLookups, nextLookup);
            const lookupParent = nextLookup.parent;
            if (lookupParent) {
                lookupParent._completed++;
                if (lookupParent.animations.length === lookupParent._completed) {
                    lookupParent.completed = true;
                    if (!lookupParent.muteCallbacks) {
                        lookupParent.paused = true;
                        lookupParent.onComplete(lookupParent);
                        lookupParent._resolve(lookupParent);
                    }
                }
            }
        }
        nextLookup = next;
    }
};
/**
 * @param {WAAPIAnimation} parent
 * @param {DOMTarget} $el
 * @param {String} property
 * @param {PropertyIndexedKeyframes} keyframes
 * @param {KeyframeAnimationOptions} params
 * @retun {Animation}
 */
const addWAAPIAnimation = (parent, $el, property, keyframes, params) => {
    const animation = $el.animate(keyframes, params);
    const animTotalDuration = params.delay + (+params.duration * params.iterations);
    animation.playbackRate = parent._speed;
    if (parent.paused)
        animation.pause();
    if (parent.duration < animTotalDuration) {
        parent.duration = animTotalDuration;
        parent.controlAnimation = animation;
    }
    parent.animations.push(animation);
    removeWAAPIAnimation($el, property);
    addChild(WAAPIAnimationsLookups, { parent, animation, $el, property, _next: null, _prev: null });
    const handleRemove = () => { removeWAAPIAnimation($el, property, parent); };
    animation.onremove = handleRemove;
    animation.onfinish = handleRemove;
    return animation;
};
/**
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} value
 * @param  {DOMTarget} $el
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {String}
 */
const normalizeTweenValue = (propName, value, $el, i, targetsLength) => {
    let v = getFunctionValue(/** @type {any} */ (value), $el, i, targetsLength);
    if (!isNum(v))
        return v;
    if (commonDefaultPXProperties.includes(propName) || stringStartsWith(propName, 'translate'))
        return `${v}px`;
    if (stringStartsWith(propName, 'rotate') || stringStartsWith(propName, 'skew'))
        return `${v}deg`;
    return `${v}`;
};
/**
 * @param  {DOMTarget} $el
 * @param  {String} propName
 * @param  {WAAPIKeyframeValue} from
 * @param  {WAAPIKeyframeValue} to
 * @param  {Number} i
 * @param  {Number} targetsLength
 * @return {WAAPITweenValue}
 */
const parseIndividualTweenValue = ($el, propName, from, to, i, targetsLength) => {
    /** @type {WAAPITweenValue} */
    let tweenValue = '0';
    const computedTo = !isUnd(to) ? normalizeTweenValue(propName, to, $el, i, targetsLength) : getComputedStyle($el)[propName];
    if (!isUnd(from)) {
        const computedFrom = normalizeTweenValue(propName, from, $el, i, targetsLength);
        tweenValue = [computedFrom, computedTo];
    }
    else {
        tweenValue = isArr(to) ? to.map((/** @type {any} */ v) => normalizeTweenValue(propName, v, $el, i, targetsLength)) : computedTo;
    }
    return tweenValue;
};
class WAAPIAnimation {
    /**
     * @param {DOMTargetsParam} targets
     * @param {WAAPIAnimationParams} params
     */
    constructor(targets, params) {
        if (globals.scope)
            globals.scope.revertibles.push(this);
        if (!transformsPropertiesRegistered)
            registerTransformsProperties();
        const parsedTargets = registerTargets(targets);
        const targetsLength = parsedTargets.length;
        if (!targetsLength) {
            console.warn(`No target found. Make sure the element you're trying to animate is accessible before creating your animation.`);
        }
        const ease = setValue(params.ease, parseWAAPIEasing(globals.defaults.ease));
        const spring = /** @type {Spring} */ (ease).ease && ease;
        const autoplay = setValue(params.autoplay, globals.defaults.autoplay);
        const scroll = autoplay && /** @type {ScrollObserver} */ (autoplay).link ? autoplay : false;
        const alternate = params.alternate && /** @type {Boolean} */ (params.alternate) === true;
        const reversed = params.reversed && /** @type {Boolean} */ (params.reversed) === true;
        const loop = setValue(params.loop, globals.defaults.loop);
        const iterations = /** @type {Number} */ ((loop === true || loop === Infinity) ? Infinity : isNum(loop) ? loop + 1 : 1);
        /** @type {PlaybackDirection} */
        const direction = alternate ? reversed ? 'alternate-reverse' : 'alternate' : reversed ? 'reverse' : 'normal';
        /** @type {FillMode} */
        const fill = 'forwards';
        /** @type {String} */
        const easing = parseWAAPIEasing(ease);
        const timeScale = (globals.timeScale === 1 ? 1 : K);
        /** @type {DOMTargetsArray}] */
        this.targets = parsedTargets;
        /** @type {Array<globalThis.Animation>}] */
        this.animations = [];
        /** @type {globalThis.Animation}] */
        this.controlAnimation = null;
        /** @type {Callback<this>} */
        this.onComplete = params.onComplete || noop;
        /** @type {Number} */
        this.duration = 0;
        /** @type {Boolean} */
        this.muteCallbacks = false;
        /** @type {Boolean} */
        this.completed = false;
        /** @type {Boolean} */
        this.paused = !autoplay || scroll !== false;
        /** @type {Boolean} */
        this.reversed = reversed;
        /** @type {Boolean|ScrollObserver} */
        this.autoplay = autoplay;
        /** @type {Number} */
        this._speed = setValue(params.playbackRate, globals.defaults.playbackRate);
        /** @type {Function} */
        this._resolve = noop; // Used by .then()
        /** @type {Number} */
        this._completed = 0;
        /** @type {Array<Object>}] */
        this._inlineStyles = parsedTargets.map($el => $el.getAttribute('style'));
        parsedTargets.forEach(($el, i) => {
            const cachedTransforms = $el[transformsSymbol];
            const hasIndividualTransforms = validIndividualTransforms.some(t => params.hasOwnProperty(t));
            /** @type {Number} */
            const duration = (spring ? /** @type {Spring} */ (spring).duration : getFunctionValue(setValue(params.duration, globals.defaults.duration), $el, i, targetsLength)) * timeScale;
            /** @type {Number} */
            const delay = getFunctionValue(setValue(params.delay, globals.defaults.delay), $el, i, targetsLength) * timeScale;
            /** @type {CompositeOperation} */
            const composite = /** @type {CompositeOperation} */ (setValue(params.composition, 'replace'));
            for (let name in params) {
                if (!isKey(name))
                    continue;
                /** @type {PropertyIndexedKeyframes} */
                const keyframes = {};
                /** @type {KeyframeAnimationOptions} */
                const tweenParams = { iterations, direction, fill, easing, duration, delay, composite };
                const propertyValue = params[name];
                const individualTransformProperty = hasIndividualTransforms ? validTransforms.includes(name) ? name : shortTransforms.get(name) : false;
                let parsedPropertyValue;
                if (isObj(propertyValue)) {
                    const tweenOptions = /** @type {WAAPITweenOptions} */ (propertyValue);
                    const tweenOptionsEase = setValue(tweenOptions.ease, ease);
                    const tweenOptionsSpring = /** @type {Spring} */ (tweenOptionsEase).ease && tweenOptionsEase;
                    const to = /** @type {WAAPITweenOptions} */ (tweenOptions).to;
                    const from = /** @type {WAAPITweenOptions} */ (tweenOptions).from;
                    /** @type {Number} */
                    tweenParams.duration = (tweenOptionsSpring ? /** @type {Spring} */ (tweenOptionsSpring).duration : getFunctionValue(setValue(tweenOptions.duration, duration), $el, i, targetsLength)) * timeScale;
                    /** @type {Number} */
                    tweenParams.delay = getFunctionValue(setValue(tweenOptions.delay, delay), $el, i, targetsLength) * timeScale;
                    /** @type {CompositeOperation} */
                    tweenParams.composite = /** @type {CompositeOperation} */ (setValue(tweenOptions.composition, composite));
                    /** @type {String} */
                    tweenParams.easing = parseWAAPIEasing(tweenOptionsEase);
                    parsedPropertyValue = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
                    if (individualTransformProperty) {
                        keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
                        cachedTransforms[individualTransformProperty] = parsedPropertyValue;
                    }
                    else {
                        keyframes[name] = parseIndividualTweenValue($el, name, from, to, i, targetsLength);
                    }
                    addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
                    if (!isUnd(from)) {
                        if (!individualTransformProperty) {
                            $el.style[name] = keyframes[name][0];
                        }
                        else {
                            const key = `--${individualTransformProperty}`;
                            $el.style.setProperty(key, keyframes[key][0]);
                        }
                    }
                }
                else {
                    parsedPropertyValue = isArr(propertyValue) ?
                        propertyValue.map((/** @type {any} */ v) => normalizeTweenValue(name, v, $el, i, targetsLength)) :
                        normalizeTweenValue(name, /** @type {any} */ (propertyValue), $el, i, targetsLength);
                    if (individualTransformProperty) {
                        keyframes[`--${individualTransformProperty}`] = parsedPropertyValue;
                        cachedTransforms[individualTransformProperty] = parsedPropertyValue;
                    }
                    else {
                        keyframes[name] = parsedPropertyValue;
                    }
                    addWAAPIAnimation(this, $el, name, keyframes, tweenParams);
                }
            }
            if (hasIndividualTransforms) {
                let transforms = emptyString;
                for (let t in cachedTransforms) {
                    transforms += `${transformsFragmentStrings[t]}var(--${t})) `;
                }
                $el.style.transform = transforms;
            }
        });
        if (scroll) {
            /** @type {ScrollObserver} */ (this.autoplay).link(this);
        }
    }
    /**
     * @callback forEachCallback
     * @param {globalThis.Animation} animation
     */
    /**
     * @param  {forEachCallback|String} callback
     * @return {this}
     */
    forEach(callback) {
        const cb = isStr(callback) ? a => a[callback]() : callback;
        this.animations.forEach(cb);
        return this;
    }
    get speed() {
        return this._speed;
    }
    /** @param {Number} speed */
    set speed(speed) {
        this._speed = +speed;
        this.forEach(anim => anim.playbackRate = speed);
    }
    get currentTime() {
        const controlAnimation = this.controlAnimation;
        const timeScale = globals.timeScale;
        return this.completed ? this.duration : controlAnimation ? +controlAnimation.currentTime * (timeScale === 1 ? 1 : timeScale) : 0;
    }
    /** @param {Number} time */
    set currentTime(time) {
        const t = time * (globals.timeScale === 1 ? 1 : K);
        this.forEach(anim => anim.currentTime = t);
    }
    get progress() {
        return this.currentTime / this.duration;
    }
    /** @param {Number} progress */
    set progress(progress) {
        this.forEach(anim => anim.currentTime = progress * this.duration || 0);
    }
    resume() {
        if (!this.paused)
            return this;
        this.paused = false;
        // TODO: Store the current time, and seek back to the last position
        return this.forEach('play');
    }
    pause() {
        if (this.paused)
            return this;
        this.paused = true;
        return this.forEach('pause');
    }
    alternate() {
        this.reversed = !this.reversed;
        this.forEach('reverse');
        if (this.paused)
            this.forEach('pause');
        return this;
    }
    play() {
        if (this.reversed)
            this.alternate();
        return this.resume();
    }
    reverse() {
        if (!this.reversed)
            this.alternate();
        return this.resume();
    }
    /**
     * @param {Number} time
     * @param {Boolean} muteCallbacks
     */
    seek(time, muteCallbacks = false) {
        if (muteCallbacks)
            this.muteCallbacks = true;
        if (time < this.duration)
            this.completed = false;
        this.currentTime = time;
        this.muteCallbacks = false;
        if (this.paused)
            this.pause();
        return this;
    }
    restart() {
        this.completed = false;
        return this.seek(0, true).resume();
    }
    commitStyles() {
        return this.forEach('commitStyles');
    }
    complete() {
        return this.seek(this.duration);
    }
    cancel() {
        this.forEach('cancel');
        return this.pause();
    }
    revert() {
        this.cancel();
        this.targets.forEach(($el, i) => $el.setAttribute('style', this._inlineStyles[i]));
        return this;
    }
    /**
     * @param  {WAAPICallback} [callback]
     * @return {Promise}
     */
    then(callback = noop) {
        const then = this.then;
        const onResolve = () => {
            this.then = null;
            callback(this);
            this.then = then;
            this._resolve = noop;
        };
        return new Promise(r => {
            this._resolve = () => r(onResolve());
            if (this.completed)
                this._resolve();
            return this;
        });
    }
}
const waapi = {
    /**
     * @param {DOMTargetsParam} targets
     * @param {WAAPIAnimationParams} params
     * @return {WAAPIAnimation}
     */
    animate: (targets, params) => new WAAPIAnimation(targets, params),
    convertEase: easingToLinear
};


/**
 * @param  {Callback<Timer>} [callback]
 * @return {Timer}
 */
const sync = (callback = noop) => {
    return new Timer({ duration: 1 * globals.timeScale, onComplete: callback }, null, 0).resume();
};
/**
 * @overload
 * @param  {DOMTargetSelector} targetSelector
 * @param  {String}            propName
 * @return {String}
 *
 * @overload
 * @param  {JSTargetsParam} targetSelector
 * @param  {String}         propName
 * @return {Number|String}
 *
 * @overload
 * @param  {DOMTargetsParam} targetSelector
 * @param  {String}          propName
 * @param  {String}          unit
 * @return {String}
 *
 * @overload
 * @param  {TargetsParam} targetSelector
 * @param  {String}       propName
 * @param  {Boolean}      unit
 * @return {Number}
 *
 * @param  {TargetsParam}   targetSelector
 * @param  {String}         propName
 * @param  {String|Boolean} [unit]
 */
function getTargetValue(targetSelector, propName, unit) {
    const targets = registerTargets(targetSelector);
    if (!targets.length)
        return;
    const [target] = targets;
    const tweenType = getTweenType(target, propName);
    const normalizePropName = sanitizePropertyName(propName, target, tweenType);
    let originalValue = getOriginalAnimatableValue(target, normalizePropName);
    if (isUnd(unit)) {
        return originalValue;
    }
    else {
        decomposeRawValue(originalValue, decomposedOriginalValue);
        if (decomposedOriginalValue.t === valueTypes.NUMBER || decomposedOriginalValue.t === valueTypes.UNIT) {
            if (unit === false) {
                return decomposedOriginalValue.n;
            }
            else {
                const convertedValue = convertValueUnit(/** @type {DOMTarget} */ (target), decomposedOriginalValue, /** @type {String} */ (unit), false);
                return `${round(convertedValue.n, globals.precision)}${convertedValue.u}`;
            }
        }
    }
}
/**
 * @param  {TargetsParam}    targets
 * @param  {AnimationParams} parameters
 * @return {JSAnimation}
 */
const setTargetValues = (targets, parameters) => {
    if (isUnd(parameters))
        return;
    parameters.duration = minValue;
    // Do not overrides currently active tweens by default
    parameters.composition = setValue(parameters.composition, compositionTypes.none);
    // Skip init() and force rendering by playing the animation
    return new JSAnimation(targets, parameters, null, 0, true).resume();
};
/**
 * @param  {TargetsArray} targetsArray
 * @param  {JSAnimation}    animation
 * @param  {String}       [propertyName]
 * @return {Boolean}
 */
const removeTargetsFromAnimation = (targetsArray, animation, propertyName) => {
    let tweensMatchesTargets = false;
    forEachChildren(animation, (/**@type {Tween} */ tween) => {
        const tweenTarget = tween.target;
        if (targetsArray.includes(tweenTarget)) {
            const tweenName = tween.property;
            const tweenType = tween._tweenType;
            const normalizePropName = sanitizePropertyName(propertyName, tweenTarget, tweenType);
            if (!normalizePropName || normalizePropName && normalizePropName === tweenName) {
                // Make sure to flag the previous CSS transform tween to renderTransform
                if (tween.parent._tail === tween &&
                    tween._tweenType === tweenTypes.TRANSFORM &&
                    tween._prev &&
                    tween._prev._tweenType === tweenTypes.TRANSFORM) {
                    tween._prev._renderTransforms = 1;
                }
                // Removes the tween from the selected animation
                removeChild(animation, tween);
                // Detach the tween from its siblings to make sure blended tweens are correctlly removed
                removeTweenSliblings(tween);
                tweensMatchesTargets = true;
            }
        }
    }, true);
    return tweensMatchesTargets;
};
/**
 * @param  {TargetsParam} targets
 * @param  {Renderable|WAAPIAnimation} [renderable]
 * @param  {String}                    [propertyName]
 * @return {TargetsArray}
 */
const remove = (targets, renderable, propertyName) => {
    const targetsArray = parseTargets(targets);
    const parent = /** @type {Renderable|typeof engine} **/ (renderable ? renderable : engine);
    const waapiAnimation = renderable && /** @type {WAAPIAnimation} */ (renderable).controlAnimation && /** @type {WAAPIAnimation} */ (renderable);
    for (let i = 0, l = targetsArray.length; i < l; i++) {
        const $el = /** @type {DOMTarget}  */ (targetsArray[i]);
        removeWAAPIAnimation($el, propertyName, waapiAnimation);
    }
    let removeMatches;
    if (parent._hasChildren) {
        let iterationDuration = 0;
        forEachChildren(parent, (/** @type {Renderable} */ child) => {
            if (!child._hasChildren) {
                removeMatches = removeTargetsFromAnimation(targetsArray, /** @type {JSAnimation} */ (child), propertyName);
                // Remove the child from its parent if no tweens and no children left after the removal
                if (removeMatches && !child._head) {
                    child.cancel();
                    removeChild(parent, child);
                }
                else {
                    // Calculate the new iterationDuration value to handle onComplete with last child in render()
                    const childTLOffset = child._offset + child._delay;
                    const childDur = childTLOffset + child.duration;
                    if (childDur > iterationDuration) {
                        iterationDuration = childDur;
                    }
                }
            }
            // Make sure to also remove engine's children targets
            // NOTE: Avoid recursion?
            if (child._head) {
                remove(targets, child, propertyName);
            }
            else {
                child._hasChildren = false;
            }
        }, true);
        // Update iterationDuration value to handle onComplete with last child in render()
        if (!isUnd(/** @type {Renderable} */ (parent).iterationDuration)) {
            /** @type {Renderable} */ (parent).iterationDuration = iterationDuration;
        }
    }
    else {
        removeMatches = removeTargetsFromAnimation(targetsArray, 
        /** @type {JSAnimation} */ (parent), propertyName);
    }
    if (removeMatches && !parent._head) {
        parent._hasChildren = false;
        // Cancel the parent if there are no tweens and no children left after the removal
        // We have to check if the .cancel() method exist to handle cases where the parent is the engine itself
        if ( /** @type {Renderable} */(parent).cancel) /** @type {Renderable} */
            (parent).cancel();
    }
    return targetsArray;
};
/**
 * @param  {Number} min
 * @param  {Number} max
 * @param  {Number} [decimalLength]
 * @return {Number}
 */
const random = (min, max, decimalLength) => { const m = 10 ** (decimalLength || 0); return floor((Math.random() * (max - min + (1 / m)) + min) * m) / m; };
/**
 * @param  {String|Array} items
 * @return {any}
 */
const randomPick = items => items[random(0, items.length - 1)];
/**
 * Adapted from https://bost.ocks.org/mike/shuffle/
 * @param  {Array} items
 * @return {Array}
 */
const shuffle = items => {
    let m = items.length, t, i;
    while (m) {
        i = random(0, --m);
        t = items[m];
        items[m] = items[i];
        items[i] = t;
    }
    return items;
};
/**
 * @param  {Number|String} v
 * @param  {Number} decimalLength
 * @return {String}
 */
const roundPad = (v, decimalLength) => (+v).toFixed(decimalLength);
/**
 * @param  {Number} v
 * @param  {Number} totalLength
 * @param  {String} padString
 * @return {String}
 */
const padStart = (v, totalLength, padString) => `${v}`.padStart(totalLength, padString);
/**
 * @param  {Number} v
 * @param  {Number} totalLength
 * @param  {String} padString
 * @return {String}
 */
const padEnd = (v, totalLength, padString) => `${v}`.padEnd(totalLength, padString);
/**
 * @param  {Number} v
 * @param  {Number} min
 * @param  {Number} max
 * @return {Number}
 */
const wrap = (v, min, max) => (((v - min) % (max - min) + (max - min)) % (max - min)) + min;
/**
 * @param  {Number} value
 * @param  {Number} inLow
 * @param  {Number} inHigh
 * @param  {Number} outLow
 * @param  {Number} outHigh
 * @return {Number}
 */
const mapRange = (value, inLow, inHigh, outLow, outHigh) => outLow + ((value - inLow) / (inHigh - inLow)) * (outHigh - outLow);
/**
 * @param  {Number} degrees
 * @return {Number}
 */
const degToRad = degrees => degrees * PI / 180;
/**
 * @param  {Number} radians
 * @return {Number}
 */
const radToDeg = radians => radians * 180 / PI;
/**
 * https://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
 * @param  {Number} start
 * @param  {Number} end
 * @param  {Number} amount
 * @param  {Renderable|Boolean} [renderable]
 * @return {Number}
 */
const lerp = (start, end, amount, renderable) => {
    let dt = K / globals.defaults.frameRate;
    if (renderable !== false) {
        const ticker = /** @type Renderable */ (renderable) ||
            (engine._hasChildren && engine);
        if (ticker && ticker.deltaTime) {
            dt = ticker.deltaTime;
        }
    }
    const t = 1 - Math.exp(-amount * dt * .1);
    return !amount ? start : amount === 1 ? end : (1 - t) * start + t * end;
};
// Chain-able utilities
/**
 * @callback UtilityFunction
 * @param {...*} args
 * @return {Number|String}
 *
 * @param {UtilityFunction} fn
 * @param {Number} [last=0]
 * @return {function(...(Number|String)): function(Number|String): (Number|String)}
 */
const curry = (fn, last = 0) => (...args) => last ? v => fn(...args, v) : v => fn(v, ...args);
/**
 * @param {Function} fn
 * @return {function(...(Number|String))}
 */
const chain = fn => {
    return (...args) => {
        const result = fn(...args);
        return new Proxy(noop, {
            apply: (_, __, [v]) => result(v),
            get: (_, prop) => chain(/**@param {...Number|String} nextArgs */ (...nextArgs) => {
                const nextResult = utils[prop](...nextArgs);
                return (/**@type {Number|String} */ v) => nextResult(result(v));
            })
        });
    };
};
/**
 * @param {UtilityFunction} fn
 * @param {Number} [right]
 * @return {function(...(Number|String)): UtilityFunction}
 */
const makeChainable = (fn, right = 0) => (...args) => (args.length < fn.length ? chain(curry(fn, right)) : fn)(...args);
/**
 * @callback ChainedUtilsResult
 * @param {Number} value
 * @return {Number}
 *
 * @typedef {Object} ChainableUtils
 * @property {ChainedClamp} clamp
 * @property {ChainedRound} round
 * @property {ChainedSnap} snap
 * @property {ChainedWrap} wrap
 * @property {ChainedInterpolate} interpolate
 * @property {ChainedMapRange} mapRange
 * @property {ChainedRoundPad} roundPad
 * @property {ChainedPadStart} padStart
 * @property {ChainedPadEnd} padEnd
 * @property {ChainedDegToRad} degToRad
 * @property {ChainedRadToDeg} radToDeg
 *
 * @typedef {ChainableUtils & ChainedUtilsResult} ChainableUtil
 *
 * @callback ChainedClamp
 * @param {Number} min
 * @param {Number} max
 * @return {ChainableUtil}
 *
 * @callback ChainedRound
 * @param {Number} decimalLength
 * @return {ChainableUtil}
 *
 * @callback ChainedSnap
 * @param {Number} increment
 * @return {ChainableUtil}
 *
 * @callback ChainedWrap
 * @param {Number} min
 * @param {Number} max
 * @return {ChainableUtil}
 *
 * @callback ChainedInterpolate
 * @param {Number} start
 * @param {Number} end
 * @return {ChainableUtil}
 *
 * @callback ChainedMapRange
 * @param {Number} inLow
 * @param {Number} inHigh
 * @param {Number} outLow
 * @param {Number} outHigh
 * @return {ChainableUtil}
 *
 * @callback ChainedRoundPad
 * @param {Number} decimalLength
 * @return {ChainableUtil}
 *
 * @callback ChainedPadStart
 * @param {Number} totalLength
 * @param {String} padString
 * @return {ChainableUtil}
 *
 * @callback ChainedPadEnd
 * @param {Number} totalLength
 * @param {String} padString
 * @return {ChainableUtil}
 *
 * @callback ChainedDegToRad
 * @return {ChainableUtil}
 *
 * @callback ChainedRadToDeg
 * @return {ChainableUtil}
 */
const utils = {
    $: registerTargets,
    get: getTargetValue,
    set: setTargetValues,
    remove,
    cleanInlineStyles,
    random,
    randomPick,
    shuffle,
    lerp,
    sync,
    clamp: /** @type {typeof clamp & ChainedClamp} */ (makeChainable(clamp)),
    round: /** @type {typeof round & ChainedRound} */ (makeChainable(round)),
    snap: /** @type {typeof snap & ChainedSnap} */ (makeChainable(snap)),
    wrap: /** @type {typeof wrap & ChainedWrap} */ (makeChainable(wrap)),
    interpolate: /** @type {typeof interpolate & ChainedInterpolate} */ (makeChainable(interpolate, 1)),
    mapRange: /** @type {typeof mapRange & ChainedMapRange} */ (makeChainable(mapRange)),
    roundPad: /** @type {typeof roundPad & ChainedRoundPad} */ (makeChainable(roundPad)),
    padStart: /** @type {typeof padStart & ChainedPadStart} */ (makeChainable(padStart)),
    padEnd: /** @type {typeof padEnd & ChainedPadEnd} */ (makeChainable(padEnd)),
    degToRad: /** @type {typeof degToRad & ChainedDegToRad} */ (makeChainable(degToRad)),
    radToDeg: /** @type {typeof radToDeg & ChainedRadToDeg} */ (makeChainable(radToDeg)),
};


/**
 * @typedef {Number|String|Function} TimePosition
 */
/**
 * Timeline's children offsets positions parser
 * @param  {Timeline} timeline
 * @param  {String} timePosition
 * @return {Number}
 */
const getPrevChildOffset = (timeline, timePosition) => {
    if (stringStartsWith(timePosition, '<')) {
        const goToPrevAnimationOffset = timePosition[1] === '<';
        const prevAnimation = /** @type {Tickable} */ (timeline._tail);
        const prevOffset = prevAnimation ? prevAnimation._offset + prevAnimation._delay : 0;
        return goToPrevAnimationOffset ? prevOffset : prevOffset + prevAnimation.duration;
    }
};
/**
 * @param  {Timeline} timeline
 * @param  {TimePosition} [timePosition]
 * @return {Number}
 */
const parseTimelinePosition = (timeline, timePosition) => {
    let tlDuration = timeline.iterationDuration;
    if (tlDuration === minValue)
        tlDuration = 0;
    if (isUnd(timePosition))
        return tlDuration;
    if (isNum(+timePosition))
        return +timePosition;
    const timePosStr = /** @type {String} */ (timePosition);
    const tlLabels = timeline ? timeline.labels : null;
    const hasLabels = !isNil(tlLabels);
    const prevOffset = getPrevChildOffset(timeline, timePosStr);
    const hasSibling = !isUnd(prevOffset);
    const matchedRelativeOperator = relativeValuesExecRgx.exec(timePosStr);
    if (matchedRelativeOperator) {
        const fullOperator = matchedRelativeOperator[0];
        const split = timePosStr.split(fullOperator);
        const labelOffset = hasLabels && split[0] ? tlLabels[split[0]] : tlDuration;
        const parsedOffset = hasSibling ? prevOffset : hasLabels ? labelOffset : tlDuration;
        const parsedNumericalOffset = +split[1];
        return getRelativeValue(parsedOffset, parsedNumericalOffset, fullOperator[0]);
    }
    else {
        return hasSibling ? prevOffset :
            hasLabels ? !isUnd(tlLabels[timePosStr]) ? tlLabels[timePosStr] :
                tlDuration : tlDuration;
    }
};
/**
 * @param {Timeline} tl
 * @return {Number}
 */
function getTimelineTotalDuration(tl) {
    return clampInfinity(((tl.iterationDuration + tl._loopDelay) * tl.iterationCount) - tl._loopDelay) || minValue;
}
/**
 * @overload
 * @param  {TimerParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @return {Timeline}
 *
 * @overload
 * @param  {AnimationParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @param  {TargetsParam} targets
 * @param  {Number} [index]
 * @param  {Number} [length]
 * @return {Timeline}
 *
 * @param  {TimerParams|AnimationParams} childParams
 * @param  {Timeline} tl
 * @param  {Number} timePosition
 * @param  {TargetsParam} [targets]
 * @param  {Number} [index]
 * @param  {Number} [length]
 */
function addTlChild(childParams, tl, timePosition, targets, index, length) {
    const isSetter = isNum(childParams.duration) && /** @type {Number} */ (childParams.duration) <= minValue;
    // Offset the tl position with -minValue for 0 duration animations or .set() calls in order to align their end value with the defined position
    const adjustedPosition = isSetter ? timePosition - minValue : timePosition;
    tick(tl, adjustedPosition, 1, 1, tickModes.AUTO);
    const tlChild = targets ?
        new JSAnimation(targets, /** @type {AnimationParams} */ (childParams), tl, adjustedPosition, false, index, length) :
        new Timer(/** @type {TimerParams} */ (childParams), tl, adjustedPosition);
    tlChild.init(1);
    // TODO: Might be better to insert at a position relative to startTime?
    addChild(tl, tlChild);
    forEachChildren(tl, (/** @type {Renderable} */ child) => {
        const childTLOffset = child._offset + child._delay;
        const childDur = childTLOffset + child.duration;
        if (childDur > tl.iterationDuration)
            tl.iterationDuration = childDur;
    });
    tl.duration = getTimelineTotalDuration(tl);
    return tl;
}
class Timeline extends Timer {
    /**
     * @param {TimelineParams} [parameters]
     */
    constructor(parameters = {}) {
        super(/** @type {TimerParams&TimelineParams} */ (parameters), null, 0);
        /** @type {Number} */
        this.duration = 0; // TL duration starts at 0 and grows when adding children
        /** @type {Record<String, Number>} */
        this.labels = {};
        const defaultsParams = parameters.defaults;
        const globalDefaults = globals.defaults;
        /** @type {DefaultsParams} */
        this.defaults = defaultsParams ? mergeObjects(defaultsParams, globalDefaults) : globalDefaults;
        /** @type {Callback<this>} */
        this.onRender = parameters.onRender || globalDefaults.onRender;
        const tlPlaybackEase = setValue(parameters.playbackEase, globalDefaults.playbackEase);
        this._ease = tlPlaybackEase ? parseEasings(tlPlaybackEase) : null;
        /** @type {Number} */
        this.iterationDuration = 0;
    }
    /**
     * @overload
     * @param {TargetsParam} a1
     * @param {AnimationParams} a2
     * @param {TimePosition} [a3]
     * @return {this}
     *
     * @overload
     * @param {TimerParams} a1
     * @param {TimePosition} [a2]
     * @return {this}
     *
     * @param {TargetsParam|TimerParams} a1
     * @param {AnimationParams|TimePosition} a2
     * @param {TimePosition} [a3]
     */
    add(a1, a2, a3) {
        const isAnim = isObj(a2);
        const isTimer = isObj(a1);
        if (isAnim || isTimer) {
            this._hasChildren = true;
            if (isAnim) {
                const childParams = /** @type {AnimationParams} */ (a2);
                // Check for function for children stagger positions
                if (isFnc(a3)) {
                    const staggeredPosition = /** @type {Function} */ (a3);
                    const parsedTargetsArray = parseTargets(/** @type {TargetsParam} */ (a1));
                    // Store initial duration before adding new children that will change the duration
                    const tlDuration = this.duration;
                    // Store initial _iterationDuration before adding new children that will change the duration
                    const tlIterationDuration = this.iterationDuration;
                    // Store the original id in order to add specific indexes to the new animations ids
                    const id = childParams.id;
                    let i = 0;
                    const parsedLength = parsedTargetsArray.length;
                    parsedTargetsArray.forEach((/** @type {Target} */ target) => {
                        // Create a new parameter object for each staggered children
                        const staggeredChildParams = { ...childParams };
                        // Reset the duration of the timeline iteration before each stagger to prevent wrong start value calculation
                        this.duration = tlDuration;
                        this.iterationDuration = tlIterationDuration;
                        if (!isUnd(id))
                            staggeredChildParams.id = id + '-' + i;
                        addTlChild(staggeredChildParams, this, staggeredPosition(target, i, parsedLength, this), target, i, parsedLength);
                        i++;
                    });
                }
                else {
                    addTlChild(childParams, this, parseTimelinePosition(this, a3), 
                    /** @type {TargetsParam} */ (a1));
                }
            }
            else {
                // It's a Timer
                addTlChild(
                /** @type TimerParams */ (a1), this, parseTimelinePosition(this, /** @type TimePosition */ (a2)));
            }
            return this.init(1); // 1 = internalRender
        }
    }
    /**
     * @overload
     * @param {Tickable} [synced]
     * @param {TimePosition} [position]
     * @return {this}
     *
     * @overload
     * @param {globalThis.Animation} [synced]
     * @param {TimePosition} [position]
     * @return {this}
     *
     * @overload
     * @param {WAAPIAnimation} [synced]
     * @param {TimePosition} [position]
     * @return {this}
     *
     * @param {Tickable|WAAPIAnimation|globalThis.Animation} [synced]
     * @param {TimePosition} [position]
     */
    sync(synced, position) {
        if (isUnd(synced) || synced && isUnd(synced.pause))
            return this;
        synced.pause();
        const duration = +( /** @type {globalThis.Animation} */(synced).effect ? /** @type {globalThis.Animation} */ (synced).effect.getTiming().duration : /** @type {Tickable} */ (synced).duration);
        return this.add(synced, { currentTime: [0, duration], duration, ease: 'linear' }, position);
    }
    /**
     * @param  {TargetsParam} targets
     * @param  {AnimationParams} parameters
     * @param  {TimePosition} [position]
     * @return {this}
     */
    set(targets, parameters, position) {
        if (isUnd(parameters))
            return this;
        parameters.duration = minValue;
        parameters.composition = compositionTypes.replace;
        return this.add(targets, parameters, position);
    }
    /**
     * @param {Callback<Timer>} callback
     * @param {TimePosition} [position]
     * @return {this}
     */
    call(callback, position) {
        if (isUnd(callback) || callback && !isFnc(callback))
            return this;
        return this.add({ duration: 0, onComplete: () => callback(this) }, position);
    }
    /**
     * @param {String} labelName
     * @param {TimePosition} [position]
     * @return {this}
     *
     */
    label(labelName, position) {
        if (isUnd(labelName) || labelName && !isStr(labelName))
            return this;
        this.labels[labelName] = parseTimelinePosition(this, /** @type TimePosition */ (position));
        return this;
    }
    /**
     * @param  {TargetsParam} targets
     * @param  {String} [propertyName]
     * @return {this}
     */
    remove(targets, propertyName) {
        remove(targets, this, propertyName);
        return this;
    }
    /**
     * @param  {Number} newDuration
     * @return {this}
     */
    stretch(newDuration) {
        const currentDuration = this.duration;
        if (currentDuration === clampZero(newDuration))
            return this;
        const timeScale = newDuration / currentDuration;
        const labels = this.labels;
        forEachChildren(this, (/** @type {JSAnimation} */ child) => {
            child.stretch(child.duration * timeScale);
        });
        for (let labelName in labels) {
            labels[labelName] *= timeScale;
        }
        return super.stretch(newDuration);
    }
    /**
     * @return {this}
     */
    refresh() {
        forEachChildren(this, (/** @type {JSAnimation} */ child) => {
            if (child.refresh)
                child.refresh();
        });
        return this;
    }
    /**
     * @return {this}
     */
    revert() {
        super.revert();
        forEachChildren(this, (/** @type {JSAnimation} */ child) => child.revert, true);
        return cleanInlineStyles(this);
    }
    /**
     * @param  {Callback<this>} [callback]
     * @return {Promise}
     */
    then(callback) {
        return super.then(callback);
    }
}
/**
 * @param {TimelineParams} [parameters]
 * @return {Timeline}
 */
const createTimeline = parameters => new Timeline(parameters).init();


class Animatable {
    /**
     * @param {TargetsParam} targets
     * @param {AnimatableParams} parameters
     */
    constructor(targets, parameters) {
        if (globals.scope)
            globals.scope.revertibles.push(this);
        /** @type {AnimationParams} */
        const globalParams = {};
        const properties = {};
        this.targets = [];
        this.animations = {};
        if (isUnd(targets) || isUnd(parameters))
            return;
        for (let propName in parameters) {
            const paramValue = parameters[propName];
            if (isKey(propName)) {
                properties[propName] = paramValue;
            }
            else {
                globalParams[propName] = paramValue;
            }
        }
        for (let propName in properties) {
            const propValue = properties[propName];
            const isObjValue = isObj(propValue);
            /** @type {TweenParamsOptions} */
            let propParams = {};
            let to = '+=0';
            if (isObjValue) {
                const unit = propValue.unit;
                if (isStr(unit))
                    to += unit;
            }
            else {
                propParams.duration = propValue;
            }
            propParams[propName] = isObjValue ? mergeObjects({ to }, propValue) : to;
            const animParams = mergeObjects(globalParams, propParams);
            animParams.composition = compositionTypes.replace;
            animParams.autoplay = false;
            const animation = this.animations[propName] = new JSAnimation(targets, animParams, null, 0, false).init();
            if (!this.targets.length)
                this.targets.push(...animation.targets);
            /** @type {AnimatableProperty} */
            this[propName] = (to, duration, ease) => {
                const tween = /** @type {Tween} */ (animation._head);
                if (isUnd(to) && tween) {
                    const numbers = tween._numbers;
                    if (numbers && numbers.length) {
                        return numbers;
                    }
                    else {
                        return tween._modifier(tween._number);
                    }
                }
                else {
                    forEachChildren(animation, (/** @type {Tween} */ tween) => {
                        if (isArr(to)) {
                            for (let i = 0, l = /** @type {Array} */ (to).length; i < l; i++) {
                                if (!isUnd(tween._numbers[i])) {
                                    tween._fromNumbers[i] = /** @type {Number} */ (tween._modifier(tween._numbers[i]));
                                    tween._toNumbers[i] = to[i];
                                }
                            }
                        }
                        else {
                            tween._fromNumber = /** @type {Number} */ (tween._modifier(tween._number));
                            tween._toNumber = /** @type {Number} */ (to);
                        }
                        if (!isUnd(ease))
                            tween._ease = parseEasings(ease);
                        tween._currentTime = 0;
                    });
                    if (!isUnd(duration))
                        animation.stretch(duration);
                    animation.reset(1).resume();
                    return this;
                }
            };
        }
    }
    revert() {
        for (let propName in this.animations) {
            this[propName] = noop;
            this.animations[propName].revert();
        }
        this.animations = {};
        this.targets.length = 0;
        return this;
    }
}
/**
 * @param {TargetsParam} targets
 * @param {AnimatableParams} parameters
 * @return {AnimatableObject}
 */
const createAnimatable = (targets, parameters) => /** @type {AnimatableObject} */ (new Animatable(targets, parameters));


/*
 * Spring ease solver adapted from https://webkit.org/demos/spring/spring.js
 * Webkit Copyright © 2016 Apple Inc
 */
/**
 * @typedef {Object} SpringParams
 * @property {Number} [mass=1] - Mass, default 1
 * @property {Number} [stiffness=100] - Stiffness, default 100
 * @property {Number} [damping=10] - Damping, default 10
 * @property {Number} [velocity=0] - Initial velocity, default 0
 */
class Spring {
    /**
     * @param {SpringParams} [parameters]
     */
    constructor(parameters = {}) {
        this.timeStep = .02; // Interval fed to the solver to calculate duration
        this.restThreshold = .0005; // Values below this threshold are considered resting position
        this.restDuration = 200; // Duration in ms used to check if the spring is resting after reaching restThreshold
        this.maxDuration = 60000; // The maximum allowed spring duration in ms (default 1 min)
        this.maxRestSteps = this.restDuration / this.timeStep / K; // How many steps allowed after reaching restThreshold before stopping the duration calculation
        this.maxIterations = this.maxDuration / this.timeStep / K; // Calculate the maximum iterations allowed based on maxDuration
        this.m = clamp(setValue(parameters.mass, 1), 0, K);
        this.s = clamp(setValue(parameters.stiffness, 100), 1, K);
        this.d = clamp(setValue(parameters.damping, 10), .1, K);
        this.v = clamp(setValue(parameters.velocity, 0), -1e3, K);
        this.w0 = 0;
        this.zeta = 0;
        this.wd = 0;
        this.b = 0;
        this.solverDuration = 0;
        this.duration = 0;
        this.compute();
        /** @type {EasingFunction} */
        this.ease = t => t === 0 || t === 1 ? t : this.solve(t * this.solverDuration);
    }
    /** @type {EasingFunction} */
    solve(time) {
        const { zeta, w0, wd, b } = this;
        let t = time;
        if (zeta < 1) {
            t = exp(-t * zeta * w0) * (1 * cos(wd * t) + b * sin(wd * t));
        }
        else {
            t = (1 + b * t) * exp(-t * w0);
        }
        return 1 - t;
    }
    compute() {
        const { maxRestSteps, maxIterations, restThreshold, timeStep, m, d, s, v } = this;
        const w0 = this.w0 = clamp(sqrt(s / m), minValue, K);
        const zeta = this.zeta = d / (2 * sqrt(s * m));
        const wd = this.wd = zeta < 1 ? w0 * sqrt(1 - zeta * zeta) : 0;
        this.b = zeta < 1 ? (zeta * w0 + -v) / wd : -v + w0;
        let solverTime = 0;
        let restSteps = 0;
        let iterations = 0;
        while (restSteps < maxRestSteps && iterations < maxIterations) {
            if (abs(1 - this.solve(solverTime)) < restThreshold) {
                restSteps++;
            }
            else {
                restSteps = 0;
            }
            this.solverDuration = solverTime;
            solverTime += timeStep;
            iterations++;
        }
        this.duration = round(this.solverDuration * K, 0) * globals.timeScale;
    }
    get mass() {
        return this.m;
    }
    set mass(v) {
        this.m = clamp(setValue(v, 1), 0, K);
        this.compute();
    }
    get stiffness() {
        return this.s;
    }
    set stiffness(v) {
        this.s = clamp(setValue(v, 100), 1, K);
        this.compute();
    }
    get damping() {
        return this.d;
    }
    set damping(v) {
        this.d = clamp(setValue(v, 10), .1, K);
        this.compute();
    }
    get velocity() {
        return this.v;
    }
    set velocity(v) {
        this.v = clamp(setValue(v, 0), -1e3, K);
        this.compute();
    }
}
/**
 * @param {SpringParams} [parameters]
 * @returns {Spring}
 */
const createSpring = (parameters) => new Spring(parameters);


/**
 * @param {Event} e
 */
const preventDefault = e => {
    if (e.cancelable)
        e.preventDefault();
};
class DOMProxy {
    /** @param {Object} el */
    constructor(el) {
        this.el = el;
        this.zIndex = 0;
        this.parentElement = null;
        this.classList = {
            add: noop,
            remove: noop,
        };
    }
    get x() { return this.el.x || 0; }
    ;
    set x(v) { this.el.x = v; }
    ;
    get y() { return this.el.y || 0; }
    ;
    set y(v) { this.el.y = v; }
    ;
    get width() { return this.el.width || 0; }
    ;
    set width(v) { this.el.width = v; }
    ;
    get height() { return this.el.height || 0; }
    ;
    set height(v) { this.el.height = v; }
    ;
    getBoundingClientRect() {
        return {
            top: this.y,
            right: this.x,
            bottom: this.y + this.height,
            left: this.x + this.width,
        };
    }
}
class Transforms {
    /**
     * @param {DOMTarget|DOMProxy} $el
     */
    constructor($el) {
        this.$el = $el;
        this.inlineTransforms = [];
        this.point = new DOMPoint();
        this.inversedMatrix = this.getMatrix().inverse();
    }
    /**
     * @param {Number} x
     * @param {Number} y
     * @return {DOMPoint}
     */
    normalizePoint(x, y) {
        this.point.x = x;
        this.point.y = y;
        return this.point.matrixTransform(this.inversedMatrix);
    }
    /**
     * @callback TraverseParentsCallback
     * @param {DOMTarget} $el
     * @param {Number} i
     */
    /**
     * @param {TraverseParentsCallback} cb
     */
    traverseUp(cb) {
        let $el = /** @type {DOMTarget|Document} */ (this.$el.parentElement), i = 0;
        while ($el && $el !== doc) {
            cb(/** @type {DOMTarget} */ ($el), i);
            $el = /** @type {DOMTarget} */ ($el.parentElement);
            i++;
        }
    }
    getMatrix() {
        const matrix = new DOMMatrix();
        this.traverseUp($el => {
            const transformValue = getComputedStyle($el).transform;
            if (transformValue) {
                const elMatrix = new DOMMatrix(transformValue);
                matrix.preMultiplySelf(elMatrix);
            }
        });
        return matrix;
    }
    remove() {
        this.traverseUp(($el, i) => {
            this.inlineTransforms[i] = $el.style.transform;
            $el.style.transform = 'none';
        });
    }
    revert() {
        this.traverseUp(($el, i) => {
            const ct = this.inlineTransforms[i];
            if (ct === '') {
                $el.style.removeProperty('transform');
            }
            else {
                $el.style.transform = ct;
            }
        });
    }
}
/**
 * @typedef {Object} DraggableCursorParams
 * @property {String} [onHover]
 * @property {String} [onGrab]
 */
/**
 * @template {Array<Number>|DOMTargetSelector|String|Number|Boolean|Function|DraggableCursorParams} T
 * @param {T | ((draggable: Draggable) => T)} value
 * @param {Draggable} draggable
 * @return {T}
 */
const parseDraggableFunctionParameter = (value, draggable) => value && isFnc(value) ? /** @type {Function} */ (value)(draggable) : value;
let zIndex = 0;
/**
 * @typedef {Object} DraggableAxisParam
 * @property {String} [mapTo]
 * @property {TweenModifier} [modifier]
 * @property {TweenComposition} [composition]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 */
/**
 * @typedef {Object} DraggableParams
 * @property {DOMTargetSelector} [trigger]
 * @property {DOMTargetSelector|Array<Number>|((draggable: Draggable) => DOMTargetSelector|Array<Number>)} [container]
 * @property {Boolean|DraggableAxisParam} [x]
 * @property {Boolean|DraggableAxisParam} [y]
 * @property {TweenModifier} [modifier]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [snap]
 * @property {Number|Array<Number>|((draggable: Draggable) => Number|Array<Number>)} [containerPadding]
 * @property {Number|((draggable: Draggable) => Number)} [containerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [releaseContainerFriction]
 * @property {Number|((draggable: Draggable) => Number)} [dragSpeed]
 * @property {Number|((draggable: Draggable) => Number)} [scrollSpeed]
 * @property {Number|((draggable: Draggable) => Number)} [scrollThreshold]
 * @property {Number|((draggable: Draggable) => Number)} [minVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [maxVelocity]
 * @property {Number|((draggable: Draggable) => Number)} [velocityMultiplier]
 * @property {Number} [releaseMass]
 * @property {Number} [releaseStiffness]
 * @property {Number} [releaseDamping]
 * @property {Boolean} [releaseDamping]
 * @property {EasingParam} [releaseEase]
 * @property {Boolean|DraggableCursorParams|((draggable: Draggable) => Boolean|DraggableCursorParams)} [cursor]
 * @property {Callback<Draggable>} [onGrab]
 * @property {Callback<Draggable>} [onDrag]
 * @property {Callback<Draggable>} [onRelease]
 * @property {Callback<Draggable>} [onUpdate]
 * @property {Callback<Draggable>} [onSettle]
 * @property {Callback<Draggable>} [onSnap]
 * @property {Callback<Draggable>} [onResize]
 * @property {Callback<Draggable>} [onAfterResize]
 */
class Draggable {
    /**
     * @param {TargetsParam} target
     * @param {DraggableParams} [parameters]
     */
    constructor(target, parameters = {}) {
        if (!target)
            return;
        if (globals.scope)
            globals.scope.revertibles.push(this);
        const paramX = parameters.x;
        const paramY = parameters.y;
        const trigger = parameters.trigger;
        const modifier = parameters.modifier;
        const ease = parameters.releaseEase;
        const customEase = ease && parseEasings(ease);
        const hasSpring = !isUnd(ease) && !isUnd(/** @type {Spring} */ (ease).ease);
        const xProp = /** @type {String} */ (isObj(paramX) && !isUnd(/** @type {Object} */ (paramX).mapTo) ? /** @type {Object} */ (paramX).mapTo : 'translateX');
        const yProp = /** @type {String} */ (isObj(paramY) && !isUnd(/** @type {Object} */ (paramY).mapTo) ? /** @type {Object} */ (paramY).mapTo : 'translateY');
        const container = parseDraggableFunctionParameter(parameters.container, this);
        this.containerArray = isArr(container) ? container : null;
        this.$container = /** @type {HTMLElement} */ (container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */ (container))[0] : doc.body);
        this.useWin = this.$container === doc.body;
        /** @type {Window | HTMLElement} */
        this.$scrollContainer = this.useWin ? win : this.$container;
        this.$target = /** @type {HTMLElement} */ (isObj(target) ? new DOMProxy(target) : parseTargets(target)[0]);
        this.$trigger = /** @type {HTMLElement} */ (parseTargets(trigger ? trigger : target)[0]);
        this.fixed = getTargetValue(this.$target, 'position') === 'fixed';
        // Refreshable parameters
        this.isFinePointer = true;
        /** @type {[Number, Number, Number, Number]} */
        this.containerPadding = [0, 0, 0, 0];
        /** @type {Number} */
        this.containerFriction = 0;
        /** @type {Number} */
        this.releaseContainerFriction = 0;
        /** @type {Number|Array<Number>} */
        this.snapX = 0;
        /** @type {Number|Array<Number>} */
        this.snapY = 0;
        /** @type {Number} */
        this.scrollSpeed = 0;
        /** @type {Number} */
        this.scrollThreshold = 0;
        /** @type {Number} */
        this.dragSpeed = 0;
        /** @type {Number} */
        this.maxVelocity = 0;
        /** @type {Number} */
        this.minVelocity = 0;
        /** @type {Number} */
        this.velocityMultiplier = 0;
        /** @type {Boolean|DraggableCursorParams} */
        this.cursor = false;
        /** @type {Spring} */
        this.releaseXSpring = hasSpring ? /** @type {Spring} */ (ease) : createSpring({
            mass: setValue(parameters.releaseMass, 1),
            stiffness: setValue(parameters.releaseStiffness, 80),
            damping: setValue(parameters.releaseDamping, 20),
        });
        /** @type {Spring} */
        this.releaseYSpring = hasSpring ? /** @type {Spring} */ (ease) : createSpring({
            mass: setValue(parameters.releaseMass, 1),
            stiffness: setValue(parameters.releaseStiffness, 80),
            damping: setValue(parameters.releaseDamping, 20),
        });
        /** @type {EasingFunction} */
        this.releaseEase = customEase || eases.outQuint;
        /** @type {Boolean} */
        this.hasReleaseSpring = hasSpring;
        /** @type {Callback<this>} */
        this.onGrab = parameters.onGrab || noop;
        /** @type {Callback<this>} */
        this.onDrag = parameters.onDrag || noop;
        /** @type {Callback<this>} */
        this.onRelease = parameters.onRelease || noop;
        /** @type {Callback<this>} */
        this.onUpdate = parameters.onUpdate || noop;
        /** @type {Callback<this>} */
        this.onSettle = parameters.onSettle || noop;
        /** @type {Callback<this>} */
        this.onSnap = parameters.onSnap || noop;
        /** @type {Callback<this>} */
        this.onResize = parameters.onResize || noop;
        /** @type {Callback<this>} */
        this.onAfterResize = parameters.onAfterResize || noop;
        /** @type {[Number, Number]} */
        this.disabled = [0, 0];
        /** @type {AnimatableParams} */
        const animatableParams = {};
        if (modifier)
            animatableParams.modifier = modifier;
        if (isUnd(paramX) || paramX === true) {
            animatableParams[xProp] = 0;
        }
        else if (isObj(paramX)) {
            const paramXObject = /** @type {DraggableAxisParam} */ (paramX);
            const animatableXParams = {};
            if (paramXObject.modifier)
                animatableXParams.modifier = paramXObject.modifier;
            if (paramXObject.composition)
                animatableXParams.composition = paramXObject.composition;
            animatableParams[xProp] = animatableXParams;
        }
        else if (paramX === false) {
            animatableParams[xProp] = 0;
            this.disabled[0] = 1;
        }
        if (isUnd(paramY) || paramY === true) {
            animatableParams[yProp] = 0;
        }
        else if (isObj(paramY)) {
            const paramYObject = /** @type {DraggableAxisParam} */ (paramY);
            const animatableYParams = {};
            if (paramYObject.modifier)
                animatableYParams.modifier = paramYObject.modifier;
            if (paramYObject.composition)
                animatableYParams.composition = paramYObject.composition;
            animatableParams[yProp] = animatableYParams;
        }
        else if (paramY === false) {
            animatableParams[yProp] = 0;
            this.disabled[1] = 1;
        }
        /** @type {AnimatableObject} */
        this.animate = /** @type {AnimatableObject} */ (new Animatable(this.$target, animatableParams));
        // Internal props
        this.xProp = xProp;
        this.yProp = yProp;
        this.destX = 0;
        this.destY = 0;
        this.deltaX = 0;
        this.deltaY = 0;
        this.scroll = { x: 0, y: 0 };
        /** @type {[Number, Number, Number, Number]} */
        this.coords = [this.x, this.y, 0, 0]; // x, y, temp x, temp y
        /** @type {[Number, Number]} */
        this.snapped = [0, 0]; // x, y
        /** @type {[Number, Number, Number, Number, Number, Number, Number, Number]} */
        this.pointer = [0, 0, 0, 0, 0, 0, 0, 0]; // x1, y1, x2, y2, temp x1, temp y1, temp x2, temp y2
        /** @type {[Number, Number]} */
        this.scrollView = [0, 0]; // w, h
        /** @type {[Number, Number, Number, Number]} */
        this.dragArea = [0, 0, 0, 0]; // x, y, w, h
        /** @type {[Number, Number, Number, Number]} */
        this.containerBounds = [-1e12, maxValue, maxValue, -1e12]; // t, r, b, l
        /** @type {[Number, Number, Number, Number]} */
        this.scrollBounds = [0, 0, 0, 0]; // t, r, b, l
        /** @type {[Number, Number, Number, Number]} */
        this.targetBounds = [0, 0, 0, 0]; // t, r, b, l
        /** @type {[Number, Number]} */
        this.window = [0, 0]; // w, h
        /** @type {[Number, Number, Number]} */
        this.velocityStack = [0, 0, 0];
        /** @type {Number} */
        this.velocityStackIndex = 0;
        /** @type {Number} */
        this.velocityTime = now();
        /** @type {Number} */
        this.velocity = 0;
        /** @type {Number} */
        this.angle = 0;
        /** @type {JSAnimation} */
        this.cursorStyles = null;
        /** @type {JSAnimation} */
        this.triggerStyles = null;
        /** @type {JSAnimation} */
        this.bodyStyles = null;
        /** @type {JSAnimation} */
        this.targetStyles = null;
        /** @type {JSAnimation} */
        this.touchActionStyles = null;
        this.transforms = new Transforms(this.$target);
        this.overshootCoords = { x: 0, y: 0 };
        this.overshootXTicker = new Timer({ autoplay: false }, null, 0).init();
        this.overshootYTicker = new Timer({ autoplay: false }, null, 0).init();
        this.updateTicker = new Timer({ autoplay: false }, null, 0).init();
        this.overshootXTicker.onUpdate = () => {
            if (this.disabled[0])
                return;
            this.updated = true;
            this.manual = true;
            this.animate[this.xProp](this.overshootCoords.x, 0);
        };
        this.overshootXTicker.onComplete = () => {
            if (this.disabled[0])
                return;
            this.manual = false;
            this.animate[this.xProp](this.overshootCoords.x, 0);
        };
        this.overshootYTicker.onUpdate = () => {
            if (this.disabled[1])
                return;
            this.updated = true;
            this.manual = true;
            this.animate[this.yProp](this.overshootCoords.y, 0);
        };
        this.overshootYTicker.onComplete = () => {
            if (this.disabled[1])
                return;
            this.manual = false;
            this.animate[this.yProp](this.overshootCoords.y, 0);
        };
        this.updateTicker.onUpdate = () => this.update();
        this.contained = !isUnd(container);
        this.manual = false;
        this.grabbed = false;
        this.dragged = false;
        this.updated = false;
        this.released = false;
        this.canScroll = false;
        this.enabled = false;
        this.initialized = false;
        this.activeProp = this.disabled[0] ? yProp : xProp;
        this.animate.animations[this.activeProp].onRender = () => {
            const hasUpdated = this.updated;
            const hasMoved = this.grabbed && hasUpdated;
            const hasReleased = !hasMoved && this.released;
            const x = this.x;
            const y = this.y;
            const dx = x - this.coords[2];
            const dy = y - this.coords[3];
            this.deltaX = dx;
            this.deltaY = dy;
            this.coords[2] = x;
            this.coords[3] = y;
            if (hasUpdated) {
                this.onUpdate(this);
            }
            if (!hasReleased) {
                this.updated = false;
            }
            else {
                this.computeVelocity(dx, dy);
                this.angle = atan2(dy, dx);
            }
        };
        this.animate.animations[this.activeProp].onComplete = () => {
            if ((!this.grabbed && this.released)) {
                // Set eleased to false before calling onSettle to avoid recursion
                this.released = false;
            }
            if (!this.manual) {
                this.deltaX = 0;
                this.deltaY = 0;
                this.velocity = 0;
                this.velocityStack[0] = 0;
                this.velocityStack[1] = 0;
                this.velocityStack[2] = 0;
                this.velocityStackIndex = 0;
                this.onSettle(this);
            }
        };
        this.resizeTicker = new Timer({
            autoplay: false,
            duration: 150 * globals.timeScale,
            onComplete: () => {
                this.onResize(this);
                this.refresh();
                this.onAfterResize(this);
            },
        }).init();
        this.parameters = parameters;
        this.resizeObserver = new ResizeObserver(() => {
            if (this.initialized) {
                this.resizeTicker.restart();
            }
            else {
                this.initialized = true;
            }
        });
        this.enable();
        this.refresh();
        this.resizeObserver.observe(this.$container);
        if (!isObj(target))
            this.resizeObserver.observe(this.$target);
    }
    /**
     * @param  {Number} dx
     * @param  {Number} dy
     * @return {Number}
     */
    computeVelocity(dx, dy) {
        const prevTime = this.velocityTime;
        const curTime = now();
        const elapsed = curTime - prevTime;
        if (elapsed < 17)
            return this.velocity;
        this.velocityTime = curTime;
        const velocityStack = this.velocityStack;
        const vMul = this.velocityMultiplier;
        const minV = this.minVelocity;
        const maxV = this.maxVelocity;
        const vi = this.velocityStackIndex;
        velocityStack[vi] = round(clamp((sqrt(dx * dx + dy * dy) / elapsed) * vMul, minV, maxV), 5);
        const velocity = max(velocityStack[0], velocityStack[1], velocityStack[2]);
        this.velocity = velocity;
        this.velocityStackIndex = (vi + 1) % 3;
        return velocity;
    }
    /**
     * @param {Number}  x
     * @param {Boolean} [muteUpdateCallback]
     * @return {this}
     */
    setX(x, muteUpdateCallback = false) {
        if (this.disabled[0])
            return;
        const v = round(x, 5);
        this.overshootXTicker.pause();
        this.manual = true;
        this.updated = !muteUpdateCallback;
        this.destX = v;
        this.snapped[0] = snap(v, this.snapX);
        this.animate[this.xProp](v, 0);
        this.manual = false;
        return this;
    }
    /**
     * @param {Number}  y
     * @param {Boolean} [muteUpdateCallback]
     * @return {this}
     */
    setY(y, muteUpdateCallback = false) {
        if (this.disabled[1])
            return;
        const v = round(y, 5);
        this.overshootYTicker.pause();
        this.manual = true;
        this.updated = !muteUpdateCallback;
        this.destY = v;
        this.snapped[1] = snap(v, this.snapY);
        this.animate[this.yProp](v, 0);
        this.manual = false;
        return this;
    }
    get x() {
        return round(/** @type {Number} */ (this.animate[this.xProp]()), globals.precision);
    }
    set x(x) {
        this.setX(x, false);
    }
    get y() {
        return round(/** @type {Number} */ (this.animate[this.yProp]()), globals.precision);
    }
    set y(y) {
        this.setY(y, false);
    }
    get progressX() {
        return mapRange(this.x, this.containerBounds[3], this.containerBounds[1], 0, 1);
    }
    set progressX(x) {
        this.setX(mapRange(x, 0, 1, this.containerBounds[3], this.containerBounds[1]), false);
    }
    get progressY() {
        return mapRange(this.y, this.containerBounds[0], this.containerBounds[2], 0, 1);
    }
    set progressY(y) {
        this.setY(mapRange(y, 0, 1, this.containerBounds[0], this.containerBounds[2]), false);
    }
    updateScrollCoords() {
        const sx = round(this.useWin ? win.scrollX : this.$container.scrollLeft, 0);
        const sy = round(this.useWin ? win.scrollY : this.$container.scrollTop, 0);
        const [cpt, cpr, cpb, cpl] = this.containerPadding;
        const threshold = this.scrollThreshold;
        this.scroll.x = sx;
        this.scroll.y = sy;
        this.scrollBounds[0] = sy - this.targetBounds[0] + cpt - threshold;
        this.scrollBounds[1] = sx - this.targetBounds[1] - cpr + threshold;
        this.scrollBounds[2] = sy - this.targetBounds[2] - cpb + threshold;
        this.scrollBounds[3] = sx - this.targetBounds[3] + cpl - threshold;
    }
    updateBoundingValues() {
        const $container = this.$container;
        const cx = this.x;
        const cy = this.y;
        const cx2 = this.coords[2];
        const cy2 = this.coords[3];
        // Prevents interfering with the scroll area in cases the target is outside of the container
        // Make sure the temp coords are also adjuset to prevents wrong delta calculation on updates
        this.coords[2] = 0;
        this.coords[3] = 0;
        this.setX(0, true);
        this.setY(0, true);
        this.transforms.remove();
        const iw = this.window[0] = win.innerWidth;
        const ih = this.window[1] = win.innerHeight;
        const uw = this.useWin;
        const sw = $container.scrollWidth;
        const sh = $container.scrollHeight;
        const fx = this.fixed;
        const transformContainerRect = $container.getBoundingClientRect();
        const [cpt, cpr, cpb, cpl] = this.containerPadding;
        this.dragArea[0] = uw ? 0 : transformContainerRect.left;
        this.dragArea[1] = uw ? 0 : transformContainerRect.top;
        this.scrollView[0] = uw ? clamp(sw, iw, sw) : sw;
        this.scrollView[1] = uw ? clamp(sh, ih, sh) : sh;
        this.updateScrollCoords();
        const { width, height, left, top, right, bottom } = $container.getBoundingClientRect();
        this.dragArea[2] = round(uw ? clamp(width, iw, iw) : width, 0);
        this.dragArea[3] = round(uw ? clamp(height, ih, ih) : height, 0);
        const containerOverflow = getTargetValue($container, 'overflow');
        const visibleOverflow = containerOverflow === 'visible';
        const hiddenOverflow = containerOverflow === 'hidden';
        this.canScroll = fx ? false :
            this.contained &&
                (($container === doc.body && visibleOverflow) || (!hiddenOverflow && !visibleOverflow)) &&
                (sw > this.dragArea[2] + cpl - cpr || sh > this.dragArea[3] + cpt - cpb) &&
                (!this.containerArray || (this.containerArray && !isArr(this.containerArray)));
        if (this.contained) {
            const sx = this.scroll.x;
            const sy = this.scroll.y;
            const canScroll = this.canScroll;
            const targetRect = this.$target.getBoundingClientRect();
            const hiddenLeft = canScroll ? uw ? 0 : $container.scrollLeft : 0;
            const hiddenTop = canScroll ? uw ? 0 : $container.scrollTop : 0;
            const hiddenRight = canScroll ? this.scrollView[0] - hiddenLeft - width : 0;
            const hiddenBottom = canScroll ? this.scrollView[1] - hiddenTop - height : 0;
            this.targetBounds[0] = round((targetRect.top + sy) - (uw ? 0 : top), 0);
            this.targetBounds[1] = round((targetRect.right + sx) - (uw ? iw : right), 0);
            this.targetBounds[2] = round((targetRect.bottom + sy) - (uw ? ih : bottom), 0);
            this.targetBounds[3] = round((targetRect.left + sx) - (uw ? 0 : left), 0);
            if (this.containerArray) {
                this.containerBounds[0] = this.containerArray[0] + cpt;
                this.containerBounds[1] = this.containerArray[1] - cpr;
                this.containerBounds[2] = this.containerArray[2] - cpb;
                this.containerBounds[3] = this.containerArray[3] + cpl;
            }
            else {
                this.containerBounds[0] = -round(targetRect.top - (fx ? clamp(top, 0, ih) : top) + hiddenTop - cpt, 0);
                this.containerBounds[1] = -round(targetRect.right - (fx ? clamp(right, 0, iw) : right) - hiddenRight + cpr, 0);
                this.containerBounds[2] = -round(targetRect.bottom - (fx ? clamp(bottom, 0, ih) : bottom) - hiddenBottom + cpb, 0);
                this.containerBounds[3] = -round(targetRect.left - (fx ? clamp(left, 0, iw) : left) + hiddenLeft - cpl, 0);
            }
        }
        this.transforms.revert();
        // Restore coordinates
        this.coords[2] = cx2;
        this.coords[3] = cy2;
        this.setX(cx, true);
        this.setY(cy, true);
    }
    /**
     * Returns 0 if not OB, 1 if x is OB, 2 if y is OB, 3 if both x and y are OB
     *
     * @param  {Array} bounds
     * @param  {Number} x
     * @param  {Number} y
     * @return {Number}
     */
    isOutOfBounds(bounds, x, y) {
        if (!this.contained)
            return 0;
        const [bt, br, bb, bl] = bounds;
        const [dx, dy] = this.disabled;
        const obx = !dx && x < bl || !dx && x > br;
        const oby = !dy && y < bt || !dy && y > bb;
        return obx && !oby ? 1 : !obx && oby ? 2 : obx && oby ? 3 : 0;
    }
    refresh() {
        const params = this.parameters;
        const paramX = params.x;
        const paramY = params.y;
        const container = parseDraggableFunctionParameter(params.container, this);
        const cp = parseDraggableFunctionParameter(params.containerPadding, this) || 0;
        const containerPadding = /** @type {[Number, Number, Number, Number]} */ (isArr(cp) ? cp : [cp, cp, cp, cp]);
        const cx = this.x;
        const cy = this.y;
        const parsedCursorStyles = parseDraggableFunctionParameter(params.cursor, this);
        const cursorStyles = { onHover: 'grab', onGrab: 'grabbing' };
        if (parsedCursorStyles) {
            const { onHover, onGrab } = /** @type {DraggableCursorParams} */ (parsedCursorStyles);
            if (onHover)
                cursorStyles.onHover = onHover;
            if (onGrab)
                cursorStyles.onGrab = onGrab;
        }
        this.containerArray = isArr(container) ? container : null;
        this.$container = /** @type {HTMLElement} */ (container && !this.containerArray ? parseTargets(/** @type {DOMTarget} */ (container))[0] : doc.body);
        this.useWin = this.$container === doc.body;
        /** @type {Window | HTMLElement} */
        this.$scrollContainer = this.useWin ? win : this.$container;
        this.isFinePointer = matchMedia('(pointer:fine)').matches;
        this.containerPadding = setValue(containerPadding, [0, 0, 0, 0]);
        this.containerFriction = clamp(setValue(parseDraggableFunctionParameter(params.containerFriction, this), .8), 0, 1);
        this.releaseContainerFriction = clamp(setValue(parseDraggableFunctionParameter(params.releaseContainerFriction, this), this.containerFriction), 0, 1);
        this.snapX = parseDraggableFunctionParameter(isObj(paramX) && !isUnd(paramX.snap) ? paramX.snap : params.snap, this);
        this.snapY = parseDraggableFunctionParameter(isObj(paramY) && !isUnd(paramY.snap) ? paramY.snap : params.snap, this);
        this.scrollSpeed = setValue(parseDraggableFunctionParameter(params.scrollSpeed, this), 1.5);
        this.scrollThreshold = setValue(parseDraggableFunctionParameter(params.scrollThreshold, this), 20);
        this.dragSpeed = setValue(parseDraggableFunctionParameter(params.dragSpeed, this), 1);
        this.minVelocity = setValue(parseDraggableFunctionParameter(params.minVelocity, this), 0);
        this.maxVelocity = setValue(parseDraggableFunctionParameter(params.maxVelocity, this), 50);
        this.velocityMultiplier = setValue(parseDraggableFunctionParameter(params.velocityMultiplier, this), 1);
        this.cursor = parsedCursorStyles === false ? false : cursorStyles;
        this.updateBoundingValues();
        // const ob = this.isOutOfBounds(this.containerBounds, this.x, this.y);
        // if (ob === 1 || ob === 3) this.progressX = px;
        // if (ob === 2 || ob === 3) this.progressY = py;
        // if (this.initialized && this.contained) {
        //   if (this.progressX !== px) this.progressX = px;
        //   if (this.progressY !== py) this.progressY = py;
        // }
        const [bt, br, bb, bl] = this.containerBounds;
        this.setX(clamp(cx, bl, br), true);
        this.setY(clamp(cy, bt, bb), true);
    }
    update() {
        this.updateScrollCoords();
        if (this.canScroll) {
            const [cpt, cpr, cpb, cpl] = this.containerPadding;
            const [sw, sh] = this.scrollView;
            const daw = this.dragArea[2];
            const dah = this.dragArea[3];
            const csx = this.scroll.x;
            const csy = this.scroll.y;
            const nsw = this.$container.scrollWidth;
            const nsh = this.$container.scrollHeight;
            const csw = this.useWin ? clamp(nsw, this.window[0], nsw) : nsw;
            const csh = this.useWin ? clamp(nsh, this.window[1], nsh) : nsh;
            const swd = sw - csw;
            const shd = sh - csh;
            // Handle cases where the scrollarea dimensions changes during drag
            if (this.dragged && swd > 0) {
                this.coords[0] -= swd;
                this.scrollView[0] = csw;
            }
            if (this.dragged && shd > 0) {
                this.coords[1] -= shd;
                this.scrollView[1] = csh;
            }
            // Handle autoscroll when target is at the edges of the scroll bounds
            const s = this.scrollSpeed * 10;
            const threshold = this.scrollThreshold;
            const [x, y] = this.coords;
            const [st, sr, sb, sl] = this.scrollBounds;
            const t = round(clamp((y - st + cpt) / threshold, -1, 0) * s, 0);
            const r = round(clamp((x - sr - cpr) / threshold, 0, 1) * s, 0);
            const b = round(clamp((y - sb - cpb) / threshold, 0, 1) * s, 0);
            const l = round(clamp((x - sl + cpl) / threshold, -1, 0) * s, 0);
            if (t || b || l || r) {
                const [nx, ny] = this.disabled;
                let scrollX = csx;
                let scrollY = csy;
                if (!nx) {
                    scrollX = round(clamp(csx + (l || r), 0, sw - daw), 0);
                    this.coords[0] -= csx - scrollX;
                }
                if (!ny) {
                    scrollY = round(clamp(csy + (t || b), 0, sh - dah), 0);
                    this.coords[1] -= csy - scrollY;
                }
                // Note: Safari mobile requires to use different scroll methods depending if using the window or not
                if (this.useWin) {
                    this.$scrollContainer.scrollBy(-(csx - scrollX), -(csy - scrollY));
                }
                else {
                    this.$scrollContainer.scrollTo(scrollX, scrollY);
                }
            }
        }
        const [ct, cr, cb, cl] = this.containerBounds;
        const [px1, py1, px2, py2, px3, py3] = this.pointer;
        this.coords[0] += (px1 - px3) * this.dragSpeed;
        this.coords[1] += (py1 - py3) * this.dragSpeed;
        this.pointer[4] = px1;
        this.pointer[5] = py1;
        const [cx, cy] = this.coords;
        const [sx, sy] = this.snapped;
        const cf = (1 - this.containerFriction) * this.dragSpeed;
        this.setX(cx > cr ? cr + (cx - cr) * cf : cx < cl ? cl + (cx - cl) * cf : cx, false);
        this.setY(cy > cb ? cb + (cy - cb) * cf : cy < ct ? ct + (cy - ct) * cf : cy, false);
        this.computeVelocity(px1 - px3, py1 - py3);
        this.angle = atan2(py1 - py2, px1 - px2);
        const [nsx, nsy] = this.snapped;
        if (nsx !== sx && this.snapX || nsy !== sy && this.snapY) {
            this.onSnap(this);
        }
    }
    stop() {
        this.updateTicker.pause();
        this.overshootXTicker.pause();
        this.overshootYTicker.pause();
        // Pauses the in bounds onRelease animations
        for (let prop in this.animate.animations)
            this.animate.animations[prop].pause();
        remove(this, null, 'x');
        remove(this, null, 'y');
        remove(this, null, 'progressX');
        remove(this, null, 'progressY');
        remove(this.scroll); // Removes any active animations on the container scroll
        remove(this.overshootCoords); // Removes active overshoot animations
        return this;
    }
    /**
     * @param {Number} [duration]
     * @param {Number} [gap]
     * @param {EasingParam} [ease]
     * @return {this}
     */
    scrollInView(duration, gap = 0, ease = eases.inOutQuad) {
        this.updateScrollCoords();
        const x = this.destX;
        const y = this.destY;
        const scroll = this.scroll;
        const scrollBounds = this.scrollBounds;
        const canScroll = this.canScroll;
        if (!this.containerArray && this.isOutOfBounds(scrollBounds, x, y)) {
            const [st, sr, sb, sl] = scrollBounds;
            const t = round(clamp(y - st, -1e12, 0), 0);
            const r = round(clamp(x - sr, 0, maxValue), 0);
            const b = round(clamp(y - sb, 0, maxValue), 0);
            const l = round(clamp(x - sl, -1e12, 0), 0);
            new JSAnimation(scroll, {
                x: round(scroll.x + (l ? l - gap : r ? r + gap : 0), 0),
                y: round(scroll.y + (t ? t - gap : b ? b + gap : 0), 0),
                duration: isUnd(duration) ? 350 * globals.timeScale : duration,
                ease,
                onUpdate: () => {
                    this.canScroll = false;
                    this.$scrollContainer.scrollTo(scroll.x, scroll.y);
                }
            }).init().then(() => {
                this.canScroll = canScroll;
            });
        }
        return this;
    }
    handleHover() {
        if (this.isFinePointer && this.cursor && !this.cursorStyles) {
            this.cursorStyles = setTargetValues(this.$trigger, {
                cursor: /** @type {DraggableCursorParams} */ (this.cursor).onHover
            });
        }
    }
    /**
     * @param  {Number} [duration]
     * @param  {Number} [gap]
     * @param  {EasingParam} [ease]
     * @return {this}
     */
    animateInView(duration, gap = 0, ease = eases.inOutQuad) {
        this.stop();
        this.updateBoundingValues();
        const x = this.x;
        const y = this.y;
        const [cpt, cpr, cpb, cpl] = this.containerPadding;
        const bt = this.scroll.y - this.targetBounds[0] + cpt + gap;
        const br = this.scroll.x - this.targetBounds[1] - cpr - gap;
        const bb = this.scroll.y - this.targetBounds[2] - cpb - gap;
        const bl = this.scroll.x - this.targetBounds[3] + cpl + gap;
        const ob = this.isOutOfBounds([bt, br, bb, bl], x, y);
        if (ob) {
            const [disabledX, disabledY] = this.disabled;
            const destX = clamp(snap(x, this.snapX), bl, br);
            const destY = clamp(snap(y, this.snapY), bt, bb);
            const dur = isUnd(duration) ? 350 * globals.timeScale : duration;
            if (!disabledX && (ob === 1 || ob === 3))
                this.animate[this.xProp](destX, dur, ease);
            if (!disabledY && (ob === 2 || ob === 3))
                this.animate[this.yProp](destY, dur, ease);
        }
        return this;
    }
    /**
     * @param {MouseEvent|TouchEvent} e
     */
    handleDown(e) {
        const $eTarget = /** @type {HTMLElement} */ (e.target);
        if (this.grabbed || /** @type {HTMLInputElement}  */ ($eTarget).type === 'range')
            return;
        e.stopPropagation();
        this.grabbed = true;
        this.released = false;
        this.stop();
        this.updateBoundingValues();
        const touches = /** @type {TouchEvent} */ (e).changedTouches;
        const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */ (e).clientX;
        const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */ (e).clientY;
        const { x, y } = this.transforms.normalizePoint(eventX, eventY);
        const [ct, cr, cb, cl] = this.containerBounds;
        const cf = (1 - this.containerFriction) * this.dragSpeed;
        const cx = this.x;
        const cy = this.y;
        this.coords[0] = this.coords[2] = !cf ? cx : cx > cr ? cr + (cx - cr) / cf : cx < cl ? cl + (cx - cl) / cf : cx;
        this.coords[1] = this.coords[3] = !cf ? cy : cy > cb ? cb + (cy - cb) / cf : cy < ct ? ct + (cy - ct) / cf : cy;
        this.pointer[0] = x;
        this.pointer[1] = y;
        this.pointer[2] = x;
        this.pointer[3] = y;
        this.pointer[4] = x;
        this.pointer[5] = y;
        this.pointer[6] = x;
        this.pointer[7] = y;
        this.deltaX = 0;
        this.deltaY = 0;
        this.velocity = 0;
        this.velocityStack[0] = 0;
        this.velocityStack[1] = 0;
        this.velocityStack[2] = 0;
        this.velocityStackIndex = 0;
        this.angle = 0;
        if (this.targetStyles) {
            this.targetStyles.revert();
            this.targetStyles = null;
        }
        const z = /** @type {Number} */ (getTargetValue(this.$target, 'zIndex', false));
        zIndex = (z > zIndex ? z : zIndex) + 1;
        this.targetStyles = setTargetValues(this.$target, { zIndex });
        if (this.triggerStyles) {
            this.triggerStyles.revert();
            this.triggerStyles = null;
        }
        if (this.cursorStyles) {
            this.cursorStyles.revert();
            this.cursorStyles = null;
        }
        if (this.isFinePointer && this.cursor) {
            this.bodyStyles = setTargetValues(doc.body, {
                cursor: /** @type {DraggableCursorParams} */ (this.cursor).onGrab
            });
        }
        this.scrollInView(100, 0, eases.out(3));
        this.onGrab(this);
        doc.addEventListener('touchmove', this);
        doc.addEventListener('touchend', this);
        doc.addEventListener('touchcancel', this);
        doc.addEventListener('mousemove', this);
        doc.addEventListener('mouseup', this);
        doc.addEventListener('selectstart', this);
    }
    /**
     * @param {MouseEvent|TouchEvent} e
     */
    handleMove(e) {
        if (!this.grabbed)
            return;
        const touches = /** @type {TouchEvent} */ (e).changedTouches;
        const eventX = touches ? touches[0].clientX : /** @type {MouseEvent} */ (e).clientX;
        const eventY = touches ? touches[0].clientY : /** @type {MouseEvent} */ (e).clientY;
        const { x, y } = this.transforms.normalizePoint(eventX, eventY);
        const movedX = x - this.pointer[6];
        const movedY = y - this.pointer[7];
        let $parent = /** @type {HTMLElement} */ (e.target);
        let isAtTop = false;
        let isAtBottom = false;
        let canTouchScroll = false;
        while (touches && $parent && $parent !== this.$trigger) {
            const overflowY = getTargetValue($parent, 'overflow-y');
            if (overflowY !== 'hidden' && overflowY !== 'visible') {
                const { scrollTop, scrollHeight, clientHeight } = $parent;
                if (scrollHeight > clientHeight) {
                    canTouchScroll = true;
                    isAtTop = scrollTop <= 3;
                    isAtBottom = scrollTop >= (scrollHeight - clientHeight) - 3;
                    break;
                }
            }
            $parent = /** @type {HTMLElement} */ ($parent.parentNode);
        }
        if (canTouchScroll && ((!isAtTop && !isAtBottom) || (isAtTop && movedY < 0) || (isAtBottom && movedY > 0))) {
            this.pointer[0] = x;
            this.pointer[1] = y;
            this.pointer[2] = x;
            this.pointer[3] = y;
            this.pointer[4] = x;
            this.pointer[5] = y;
            this.pointer[6] = x;
            this.pointer[7] = y;
        }
        else {
            preventDefault(e);
            // Needed to prevents click on handleUp
            if (!this.triggerStyles)
                this.triggerStyles = setTargetValues(this.$trigger, { pointerEvents: 'none' });
            // Needed to prevent page scroll while dragging on touch devvice
            this.$trigger.addEventListener('touchstart', preventDefault, { passive: false });
            this.$trigger.addEventListener('touchmove', preventDefault, { passive: false });
            this.$trigger.addEventListener('touchend', preventDefault);
            if ((!this.disabled[0] && abs(movedX) > 3) || (!this.disabled[1] && abs(movedY) > 3)) {
                this.updateTicker.resume();
                this.pointer[2] = this.pointer[0];
                this.pointer[3] = this.pointer[1];
                this.pointer[0] = x;
                this.pointer[1] = y;
                this.dragged = true;
                this.released = false;
                this.onDrag(this);
            }
        }
    }
    handleUp() {
        if (!this.grabbed)
            return;
        this.updateTicker.pause();
        if (this.triggerStyles) {
            this.triggerStyles.revert();
            this.triggerStyles = null;
        }
        if (this.bodyStyles) {
            this.bodyStyles.revert();
            this.bodyStyles = null;
        }
        const [disabledX, disabledY] = this.disabled;
        const [px1, py1, px2, py2, px3, py3] = this.pointer;
        const [ct, cr, cb, cl] = this.containerBounds;
        const [sx, sy] = this.snapped;
        const springX = this.releaseXSpring;
        const springY = this.releaseYSpring;
        const releaseEase = this.releaseEase;
        const hasReleaseSpring = this.hasReleaseSpring;
        const overshootCoords = this.overshootCoords;
        const cx = this.x;
        const cy = this.y;
        const pv = this.computeVelocity(px1 - px3, py1 - py3);
        const pa = this.angle = atan2(py1 - py2, px1 - px2);
        const ds = pv * 150;
        const cf = (1 - this.releaseContainerFriction) * this.dragSpeed;
        const nx = cx + (cos(pa) * ds);
        const ny = cy + (sin(pa) * ds);
        const bx = nx > cr ? cr + (nx - cr) * cf : nx < cl ? cl + (nx - cl) * cf : nx;
        const by = ny > cb ? cb + (ny - cb) * cf : ny < ct ? ct + (ny - ct) * cf : ny;
        const dx = this.destX = clamp(round(snap(bx, this.snapX), 5), cl, cr);
        const dy = this.destY = clamp(round(snap(by, this.snapY), 5), ct, cb);
        const ob = this.isOutOfBounds(this.containerBounds, nx, ny);
        let durationX = 0;
        let durationY = 0;
        let easeX = releaseEase;
        let easeY = releaseEase;
        let longestReleaseDuration = 0;
        overshootCoords.x = cx;
        overshootCoords.y = cy;
        if (!disabledX) {
            const directionX = dx === cr ? cx > cr ? -1 : 1 : cx < cl ? -1 : 1;
            const distanceX = round(cx - dx, 0);
            springX.velocity = disabledY && hasReleaseSpring ? distanceX ? (ds * directionX) / abs(distanceX) : 0 : pv;
            const { ease, duration, restDuration } = springX;
            durationX = cx === dx ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);
            if (hasReleaseSpring)
                easeX = ease;
            if (durationX > longestReleaseDuration)
                longestReleaseDuration = durationX;
        }
        if (!disabledY) {
            const directionY = dy === cb ? cy > cb ? -1 : 1 : cy < ct ? -1 : 1;
            const distanceY = round(cy - dy, 0);
            springY.velocity = disabledX && hasReleaseSpring ? distanceY ? (ds * directionY) / abs(distanceY) : 0 : pv;
            const { ease, duration, restDuration } = springY;
            durationY = cy === dy ? 0 : hasReleaseSpring ? duration : duration - (restDuration * globals.timeScale);
            if (hasReleaseSpring)
                easeY = ease;
            if (durationY > longestReleaseDuration)
                longestReleaseDuration = durationY;
        }
        if (!hasReleaseSpring && ob && cf && (durationX || durationY)) {
            const composition = compositionTypes.blend;
            new JSAnimation(overshootCoords, {
                x: { to: bx, duration: durationX * .65 },
                y: { to: by, duration: durationY * .65 },
                ease: releaseEase,
                composition,
            }).init();
            new JSAnimation(overshootCoords, {
                x: { to: dx, duration: durationX },
                y: { to: dy, duration: durationY },
                ease: releaseEase,
                composition,
            }).init();
            this.overshootXTicker.stretch(durationX).restart();
            this.overshootYTicker.stretch(durationY).restart();
        }
        else {
            if (!disabledX)
                this.animate[this.xProp](dx, durationX, easeX);
            if (!disabledY)
                this.animate[this.yProp](dy, durationY, easeY);
        }
        this.scrollInView(longestReleaseDuration, this.scrollThreshold, releaseEase);
        let hasSnapped = false;
        if (dx !== sx) {
            this.snapped[0] = dx;
            if (this.snapX)
                hasSnapped = true;
        }
        if (dy !== sy && this.snapY) {
            this.snapped[1] = dy;
            if (this.snapY)
                hasSnapped = true;
        }
        if (hasSnapped)
            this.onSnap(this);
        this.grabbed = false;
        this.dragged = false;
        this.updated = true;
        this.released = true;
        // It's important to trigger the callback after the release animations to be able to cancel them
        this.onRelease(this);
        this.$trigger.removeEventListener('touchstart', preventDefault);
        this.$trigger.removeEventListener('touchmove', preventDefault);
        this.$trigger.removeEventListener('touchend', preventDefault);
        doc.removeEventListener('touchmove', this);
        doc.removeEventListener('touchend', this);
        doc.removeEventListener('touchcancel', this);
        doc.removeEventListener('mousemove', this);
        doc.removeEventListener('mouseup', this);
        doc.removeEventListener('selectstart', this);
    }
    reset() {
        this.stop();
        this.resizeTicker.pause();
        this.grabbed = false;
        this.dragged = false;
        this.updated = false;
        this.released = false;
        this.canScroll = false;
        this.setX(0, true);
        this.setY(0, true);
        this.coords[0] = 0;
        this.coords[1] = 0;
        this.pointer[0] = 0;
        this.pointer[1] = 0;
        this.pointer[2] = 0;
        this.pointer[3] = 0;
        this.pointer[4] = 0;
        this.pointer[5] = 0;
        this.pointer[6] = 0;
        this.pointer[7] = 0;
        this.velocity = 0;
        this.velocityStack[0] = 0;
        this.velocityStack[1] = 0;
        this.velocityStack[2] = 0;
        this.velocityStackIndex = 0;
        this.angle = 0;
        return this;
    }
    enable() {
        if (!this.enabled) {
            this.enabled = true;
            this.$target.classList.remove('is-disabled');
            this.touchActionStyles = setTargetValues(this.$trigger, {
                touchAction: this.disabled[0] ? 'pan-x' : this.disabled[1] ? 'pan-y' : 'none'
            });
            this.$trigger.addEventListener('touchstart', this, { passive: true });
            this.$trigger.addEventListener('mousedown', this, { passive: true });
            this.$trigger.addEventListener('mouseenter', this);
        }
        return this;
    }
    disable() {
        this.enabled = false;
        this.grabbed = false;
        this.dragged = false;
        this.updated = false;
        this.released = false;
        this.canScroll = false;
        this.touchActionStyles.revert();
        if (this.cursorStyles) {
            this.cursorStyles.revert();
            this.cursorStyles = null;
        }
        if (this.triggerStyles) {
            this.triggerStyles.revert();
            this.triggerStyles = null;
        }
        if (this.bodyStyles) {
            this.bodyStyles.revert();
            this.bodyStyles = null;
        }
        if (this.targetStyles) {
            this.targetStyles.revert();
            this.targetStyles = null;
        }
        this.stop();
        this.$target.classList.add('is-disabled');
        this.$trigger.removeEventListener('touchstart', this);
        this.$trigger.removeEventListener('mousedown', this);
        this.$trigger.removeEventListener('mouseenter', this);
        doc.removeEventListener('touchmove', this);
        doc.removeEventListener('touchend', this);
        doc.removeEventListener('touchcancel', this);
        doc.removeEventListener('mousemove', this);
        doc.removeEventListener('mouseup', this);
        doc.removeEventListener('selectstart', this);
        return this;
    }
    revert() {
        this.reset();
        this.disable();
        this.$target.classList.remove('is-disabled');
        this.updateTicker.revert();
        this.overshootXTicker.revert();
        this.overshootYTicker.revert();
        this.resizeTicker.revert();
        return this;
    }
    /**
     * @param {Event} e
     */
    handleEvent(e) {
        switch (e.type) {
            case 'mousedown':
                this.handleDown(/** @type {MouseEvent} */ (e));
                break;
            case 'touchstart':
                this.handleDown(/** @type {TouchEvent} */ (e));
                break;
            case 'mousemove':
                this.handleMove(/** @type {MouseEvent} */ (e));
                break;
            case 'touchmove':
                this.handleMove(/** @type {TouchEvent} */ (e));
                break;
            case 'mouseup':
                this.handleUp();
                break;
            case 'touchend':
                this.handleUp();
                break;
            case 'touchcancel':
                this.handleUp();
                break;
            case 'mouseenter':
                this.handleHover();
                break;
            case 'selectstart':
                preventDefault(e);
                break;
        }
    }
}
/**
 * @param {TargetsParam} target
 * @param {DraggableParams} [parameters]
 * @return {Draggable}
 */
const createDraggable = (target, parameters) => new Draggable(target, parameters);


/**
 * @typedef {Object} ReactRef
 * @property {HTMLElement|SVGElement|null} [current]
 */
/**
 * @typedef {Object} AngularRef
 * @property {HTMLElement|SVGElement} [nativeElement]
 */
/**
 * @typedef {Object} ScopeParams
 * @property {DOMTargetSelector|ReactRef|AngularRef} [root]
 * @property {DefaultsParams} [defaults]
 * @property {Record<String, String>} [mediaQueries]
 */
/**
 * @callback ScopeCleanup
 * @param {Scope} [scope]
 */
/**
 * @callback ScopeConstructor
 * @param {Scope} [scope]
 * @return {ScopeCleanup|void}
 */
/**
 * @callback ScopeMethod
 * @param {...*} args
 * @return {ScopeCleanup|void}
 */
class Scope {
    /** @param {ScopeParams} [parameters] */
    constructor(parameters = {}) {
        if (globals.scope)
            globals.scope.revertibles.push(this);
        const rootParam = parameters.root;
        /** @type {Document|DOMTarget} */
        let root = doc;
        if (rootParam) {
            root = /** @type {ReactRef} */ (rootParam).current ||
                /** @type {AngularRef} */ (rootParam).nativeElement ||
                parseTargets(/** @type {DOMTargetSelector} */ (rootParam))[0] ||
                doc;
        }
        const scopeDefaults = parameters.defaults;
        const globalDefault = globals.defaults;
        const mediaQueries = parameters.mediaQueries;
        /** @type {DefaultsParams} */
        this.defaults = scopeDefaults ? mergeObjects(scopeDefaults, globalDefault) : globalDefault;
        /** @type {Document|DOMTarget} */
        this.root = root;
        /** @type {Array<ScopeConstructor>} */
        this.constructors = [];
        /** @type {Array<Function>} */
        this.revertConstructors = [];
        /** @type {Array<Revertible>} */
        this.revertibles = [];
        /** @type {Record<String, Function>} */
        this.methods = {};
        /** @type {Record<String, Boolean>} */
        this.matches = {};
        /** @type {Record<String, MediaQueryList>} */
        this.mediaQueryLists = {};
        /** @type {Record<String, any>} */
        this.data = {};
        if (mediaQueries) {
            for (let mq in mediaQueries) {
                const _mq = win.matchMedia(mediaQueries[mq]);
                this.mediaQueryLists[mq] = _mq;
                _mq.addEventListener('change', this);
            }
        }
    }
    /**
     * @callback ScoppedCallback
     * @param {this} scope
     * @return {any}
     *
     * @param {ScoppedCallback} cb
     * @return {this}
     */
    execute(cb) {
        let activeScope = globals.scope;
        let activeRoot = globals.root;
        let activeDefaults = globals.defaults;
        globals.scope = this;
        globals.root = this.root;
        globals.defaults = this.defaults;
        const mqs = this.mediaQueryLists;
        for (let mq in mqs)
            this.matches[mq] = mqs[mq].matches;
        const returned = cb(this);
        globals.scope = activeScope;
        globals.root = activeRoot;
        globals.defaults = activeDefaults;
        return returned;
    }
    /**
     * @return {this}
     */
    refresh() {
        this.execute(() => {
            let i = this.revertibles.length;
            let y = this.revertConstructors.length;
            while (i--)
                this.revertibles[i].revert();
            while (y--)
                this.revertConstructors[y](this);
            this.revertibles.length = 0;
            this.revertConstructors.length = 0;
            this.constructors.forEach(constructor => {
                const revertConstructor = constructor(this);
                if (revertConstructor) {
                    this.revertConstructors.push(revertConstructor);
                }
            });
        });
        return this;
    }
    /**
     * @callback contructorCallback
     * @param {this} self
     *
     * @overload
     * @param {String} a1
     * @param {ScopeMethod} a2
     * @return {this}
     *
     * @overload
     * @param {contructorCallback} a1
     * @return {this}
     *
     * @param {String|contructorCallback} a1
     * @param {ScopeMethod} [a2]
     */
    add(a1, a2) {
        if (isFnc(a1)) {
            const constructor = /** @type {contructorCallback} */ (a1);
            this.constructors.push(constructor);
            this.execute(() => {
                const revertConstructor = constructor(this);
                if (revertConstructor) {
                    this.revertConstructors.push(revertConstructor);
                }
            });
        }
        else {
            this.methods[ /** @type {String} */(a1)] = (/** @type {any} */ ...args) => this.execute(() => a2(...args));
        }
        return this;
    }
    /**
     * @param {Event} e
     */
    handleEvent(e) {
        switch (e.type) {
            case 'change':
                this.refresh();
                break;
        }
    }
    revert() {
        const revertibles = this.revertibles;
        const revertConstructors = this.revertConstructors;
        const mqs = this.mediaQueryLists;
        let i = revertibles.length;
        let y = revertConstructors.length;
        while (i--)
            revertibles[i].revert();
        while (y--)
            revertConstructors[y](this);
        for (let mq in mqs)
            mqs[mq].removeEventListener('change', this);
        revertibles.length = 0;
        revertConstructors.length = 0;
        this.constructors.length = 0;
        this.matches = {};
        this.methods = {};
        this.mediaQueryLists = {};
        this.data = {};
    }
}
/**
 * @param {ScopeParams} [params]
 * @return {Scope}
 */
const createScope = params => new Scope(params);

/**
 * @typedef {String|Number} ScrollThresholdValue
 */
/**
 * @return {Number}
 */
const getMaxViewHeight = () => {
    const $el = document.createElement('div');
    doc.body.appendChild($el);
    $el.style.height = '100lvh';
    const height = $el.offsetHeight;
    doc.body.removeChild($el);
    return height;
};
/**
 * @template {ScrollThresholdValue|String|Number|Boolean|Function|Object} T
 * @param {T | ((observer: ScrollObserver) => T)} value
 * @param {ScrollObserver} scroller
 * @return {T}
 */
const parseScrollObserverFunctionParameter = (value, scroller) => value && isFnc(value) ? /** @type {Function} */ (value)(scroller) : value;
const scrollContainers = new Map();
class ScrollContainer {
    /**
     * @param {HTMLElement} $el
     */
    constructor($el) {
        /** @type {HTMLElement} */
        this.element = $el;
        /** @type {Boolean} */
        this.useWin = this.element === doc.body;
        /** @type {Number} */
        this.winWidth = 0;
        /** @type {Number} */
        this.winHeight = 0;
        /** @type {Number} */
        this.width = 0;
        /** @type {Number} */
        this.height = 0;
        /** @type {Number} */
        this.left = 0;
        /** @type {Number} */
        this.top = 0;
        /** @type {Number} */
        this.zIndex = 0;
        /** @type {Number} */
        this.scrollX = 0;
        /** @type {Number} */
        this.scrollY = 0;
        /** @type {Number} */
        this.prevScrollX = 0;
        /** @type {Number} */
        this.prevScrollY = 0;
        /** @type {Number} */
        this.scrollWidth = 0;
        /** @type {Number} */
        this.scrollHeight = 0;
        /** @type {Number} */
        this.velocity = 0;
        /** @type {Boolean} */
        this.backwardX = false;
        /** @type {Boolean} */
        this.backwardY = false;
        /** @type {Timer} */
        this.scrollTicker = new Timer({
            autoplay: false,
            onBegin: () => this.dataTimer.resume(),
            onUpdate: () => {
                const backwards = this.backwardX || this.backwardY;
                forEachChildren(this, (/** @type {ScrollObserver} */ child) => child.handleScroll(), backwards);
            },
            onComplete: () => this.dataTimer.pause()
        }).init();
        /** @type {Timer} */
        this.dataTimer = new Timer({
            autoplay: false,
            frameRate: 30,
            onUpdate: self => {
                const dt = self.deltaTime;
                const px = this.prevScrollX;
                const py = this.prevScrollY;
                const nx = this.scrollX;
                const ny = this.scrollY;
                const dx = px - nx;
                const dy = py - ny;
                this.prevScrollX = nx;
                this.prevScrollY = ny;
                if (dx)
                    this.backwardX = px > nx;
                if (dy)
                    this.backwardY = py > ny;
                this.velocity = round(dt > 0 ? Math.sqrt(dx * dx + dy * dy) / dt : 0, 5);
            }
        }).init();
        /** @type {Timer} */
        this.resizeTicker = new Timer({
            autoplay: false,
            duration: 250 * globals.timeScale,
            onComplete: () => {
                this.updateWindowBounds();
                this.refreshScrollObservers();
                this.handleScroll();
            }
        }).init();
        /** @type {Timer} */
        this.wakeTicker = new Timer({
            autoplay: false,
            duration: 500 * globals.timeScale,
            onBegin: () => {
                this.scrollTicker.resume();
            },
            onComplete: () => {
                this.scrollTicker.pause();
            }
        }).init();
        /** @type {ScrollObserver} */
        this._head = null;
        /** @type {ScrollObserver} */
        this._tail = null;
        this.updateScrollCoords();
        this.updateWindowBounds();
        this.updateBounds();
        this.refreshScrollObservers();
        this.handleScroll();
        this.resizeObserver = new ResizeObserver(() => this.resizeTicker.restart());
        this.resizeObserver.observe(this.element);
        (this.useWin ? win : this.element).addEventListener('scroll', this, false);
    }
    updateScrollCoords() {
        const useWin = this.useWin;
        const $el = this.element;
        this.scrollX = round(useWin ? win.scrollX : $el.scrollLeft, 0);
        this.scrollY = round(useWin ? win.scrollY : $el.scrollTop, 0);
    }
    updateWindowBounds() {
        this.winWidth = win.innerWidth;
        this.winHeight = getMaxViewHeight();
    }
    updateBounds() {
        const style = getComputedStyle(this.element);
        const $el = this.element;
        this.scrollWidth = $el.scrollWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        this.scrollHeight = $el.scrollHeight + parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        this.updateWindowBounds();
        let width, height;
        if (this.useWin) {
            width = this.winWidth;
            height = this.winHeight;
        }
        else {
            const elRect = $el.getBoundingClientRect();
            width = elRect.width;
            height = elRect.height;
            this.top = elRect.top;
            this.left = elRect.left;
        }
        this.width = width;
        this.height = height;
    }
    refreshScrollObservers() {
        forEachChildren(this, (/** @type {ScrollObserver} */ child) => {
            if (child._debug) {
                child.removeDebug();
            }
        });
        this.updateBounds();
        forEachChildren(this, (/** @type {ScrollObserver} */ child) => {
            child.refresh();
            if (child._debug) {
                child.debug();
            }
        });
    }
    refresh() {
        this.updateWindowBounds();
        this.updateBounds();
        this.refreshScrollObservers();
        this.handleScroll();
    }
    handleScroll() {
        this.updateScrollCoords();
        this.wakeTicker.restart();
    }
    /**
     * @param {Event} e
     */
    handleEvent(e) {
        switch (e.type) {
            case 'scroll':
                this.handleScroll();
                break;
        }
    }
    revert() {
        this.scrollTicker.cancel();
        this.dataTimer.cancel();
        this.resizeTicker.cancel();
        this.wakeTicker.cancel();
        this.resizeObserver.unobserve(this.element);
        (this.useWin ? win : this.element).removeEventListener('scroll', this);
        scrollContainers.delete(this.element);
    }
}
/**
 * @param {TargetsParam} target
 * @return {ScrollContainer}
 */
const registerAndGetScrollContainer = target => {
    const $el = /** @type {HTMLElement} */ (target ? parseTargets(target)[0] || doc.body : doc.body);
    let scrollContainer = scrollContainers.get($el);
    if (!scrollContainer) {
        scrollContainer = new ScrollContainer($el);
        scrollContainers.set($el, scrollContainer);
    }
    return scrollContainer;
};
/**
 * @param {HTMLElement} $el
 * @param {Number|string} v
 * @param {Number} size
 * @param {Number} [under]
 * @param {Number} [over]
 * @return {Number}
 */
const convertValueToPx = ($el, v, size, under, over) => {
    const clampMin = v === 'min';
    const clampMax = v === 'max';
    const value = v === 'top' || v === 'left' || v === 'start' || clampMin ? 0 :
        v === 'bottom' || v === 'right' || v === 'end' || clampMax ? '100%' :
            v === 'center' ? '50%' :
                v;
    const { n, u } = decomposeRawValue(value, decomposedOriginalValue);
    let px = n;
    if (u === '%') {
        px = (n / 100) * size;
    }
    else if (u) {
        px = convertValueUnit($el, decomposedOriginalValue, 'px', true).n;
    }
    if (clampMax && under < 0)
        px += under;
    if (clampMin && over > 0)
        px += over;
    return px;
};
/**
 * @param {HTMLElement} $el
 * @param {ScrollThresholdValue} v
 * @param {Number} size
 * @param {Number} [under]
 * @param {Number} [over]
 * @return {Number}
 */
const parseBoundValue = ($el, v, size, under, over) => {
    /** @type {Number} */
    let value;
    if (isStr(v)) {
        const matchedOperator = relativeValuesExecRgx.exec(/** @type {String} */ (v));
        if (matchedOperator) {
            const splitter = matchedOperator[0];
            const operator = splitter[0];
            const splitted = /** @type {String} */ (v).split(splitter);
            const clampMin = splitted[0] === 'min';
            const clampMax = splitted[0] === 'max';
            const valueAPx = convertValueToPx($el, splitted[0], size, under, over);
            const valueBPx = convertValueToPx($el, splitted[1], size, under, over);
            if (clampMin) {
                const min = getRelativeValue(convertValueToPx($el, 'min', size), valueBPx, operator);
                value = min < valueAPx ? valueAPx : min;
            }
            else if (clampMax) {
                const max = getRelativeValue(convertValueToPx($el, 'max', size), valueBPx, operator);
                value = max > valueAPx ? valueAPx : max;
            }
            else {
                value = getRelativeValue(valueAPx, valueBPx, operator);
            }
        }
        else {
            value = convertValueToPx($el, v, size, under, over);
        }
    }
    else {
        value = /** @type {Number} */ (v);
    }
    return round(value, 0);
};
/**
 * @param {JSAnimation} linked
 * @return {HTMLElement}
 */
const getAnimationDomTarget = linked => {
    let $linkedTarget;
    const linkedTargets = linked.targets;
    for (let i = 0, l = linkedTargets.length; i < l; i++) {
        const target = linkedTargets[i];
        if (target[isDomSymbol]) {
            $linkedTarget = /** @type {HTMLElement} */ (target);
            break;
        }
    }
    return $linkedTarget;
};
let scrollerIndex = 0;
const debugColors = ['#FF4B4B', '#FF971B', '#FFC730', '#F9F640', '#7AFF5A', '#18FF74', '#17E09B', '#3CFFEC', '#05DBE9', '#33B3F1', '#638CF9', '#C563FE', '#FF4FCF', '#F93F8A'];
/**
 * @typedef {Object} ScrollThresholdParam
 * @property {ScrollThresholdValue} [target]
 * @property {ScrollThresholdValue} [container]
 */
/**
 * @callback ScrollObserverAxisCallback
 * @param {ScrollObserver} self
 * @return {'x'|'y'}
 */
/**
 * @callback ScrollThresholdCallback
 * @param {ScrollObserver} self
 * @return {ScrollThresholdValue|ScrollThresholdParam}
 */
/**
 * @typedef {Object} ScrollObserverParams
 * @property {Number|String} [id]
 * @property {Boolean|Number|String|EasingParam} [sync]
 * @property {TargetsParam} [container]
 * @property {TargetsParam} [target]
 * @property {'x'|'y'|ScrollObserverAxisCallback|((observer: ScrollObserver) => 'x'|'y'|ScrollObserverAxisCallback)} [axis]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [enter]
 * @property {ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback|((observer: ScrollObserver) => ScrollThresholdValue|ScrollThresholdParam|ScrollThresholdCallback)} [leave]
 * @property {Boolean|((observer: ScrollObserver) => Boolean)} [repeat]
 * @property {Boolean} [debug]
 * @property {Callback<ScrollObserver>} [onEnter]
 * @property {Callback<ScrollObserver>} [onLeave]
 * @property {Callback<ScrollObserver>} [onEnterForward]
 * @property {Callback<ScrollObserver>} [onLeaveForward]
 * @property {Callback<ScrollObserver>} [onEnterBackward]
 * @property {Callback<ScrollObserver>} [onLeaveBackward]
 * @property {Callback<ScrollObserver>} [onUpdate]
 * @property {Callback<ScrollObserver>} [onSyncComplete]
 */
class ScrollObserver {
    /**
     * @param {ScrollObserverParams} parameters
     */
    constructor(parameters = {}) {
        if (globals.scope)
            globals.scope.revertibles.push(this);
        const syncMode = setValue(parameters.sync, 'play pause');
        const ease = syncMode ? parseEasings(/** @type {EasingParam} */ (syncMode)) : null;
        const isLinear = syncMode && (syncMode === 'linear' || syncMode === none);
        const isEase = syncMode && !(ease === none && !isLinear);
        const isSmooth = syncMode && (isNum(syncMode) || syncMode === true || isLinear);
        const isMethods = syncMode && (isStr(syncMode) && !isEase && !isSmooth);
        const syncMethods = isMethods ? /** @type {String} */ (syncMode).split(' ').map((/** @type {String} */ m) => () => {
            const linked = this.linked;
            return linked && linked[m] ? linked[m]() : null;
        }) : null;
        const biDirSync = isMethods && syncMethods.length > 2;
        /** @type {Number} */
        this.index = scrollerIndex++;
        /** @type {String|Number} */
        this.id = !isUnd(parameters.id) ? parameters.id : this.index;
        /** @type {ScrollContainer} */
        this.container = registerAndGetScrollContainer(parameters.container);
        /** @type {HTMLElement} */
        this.target = null;
        /** @type {Tickable|WAAPIAnimation} */
        this.linked = null;
        /** @type {Boolean} */
        this.repeat = null;
        /** @type {Boolean} */
        this.horizontal = null;
        /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
        this.enter = null;
        /** @type {ScrollThresholdParam|ScrollThresholdValue|ScrollThresholdCallback} */
        this.leave = null;
        /** @type {Boolean} */
        this.sync = isEase || isSmooth || !!syncMethods;
        /** @type {EasingFunction} */
        this.syncEase = isEase ? ease : null;
        /** @type {Number} */
        this.syncSmooth = isSmooth ? syncMode === true || isLinear ? 1 : /** @type {Number} */ (syncMode) : null;
        /** @type {Callback<ScrollObserver>} */
        this.onSyncEnter = syncMethods && !biDirSync && syncMethods[0] ? syncMethods[0] : noop;
        /** @type {Callback<ScrollObserver>} */
        this.onSyncLeave = syncMethods && !biDirSync && syncMethods[1] ? syncMethods[1] : noop;
        /** @type {Callback<ScrollObserver>} */
        this.onSyncEnterForward = syncMethods && biDirSync && syncMethods[0] ? syncMethods[0] : noop;
        /** @type {Callback<ScrollObserver>} */
        this.onSyncLeaveForward = syncMethods && biDirSync && syncMethods[1] ? syncMethods[1] : noop;
        /** @type {Callback<ScrollObserver>} */
        this.onSyncEnterBackward = syncMethods && biDirSync && syncMethods[2] ? syncMethods[2] : noop;
        /** @type {Callback<ScrollObserver>} */
        this.onSyncLeaveBackward = syncMethods && biDirSync && syncMethods[3] ? syncMethods[3] : noop;
        /** @type {Callback<ScrollObserver>} */
        this.onEnter = parameters.onEnter || noop;
        /** @type {Callback<ScrollObserver>} */
        this.onLeave = parameters.onLeave || noop;
        /** @type {Callback<ScrollObserver>} */
        this.onEnterForward = parameters.onEnterForward || noop;
        /** @type {Callback<ScrollObserver>} */
        this.onLeaveForward = parameters.onLeaveForward || noop;
        /** @type {Callback<ScrollObserver>} */
        this.onEnterBackward = parameters.onEnterBackward || noop;
        /** @type {Callback<ScrollObserver>} */
        this.onLeaveBackward = parameters.onLeaveBackward || noop;
        /** @type {Callback<ScrollObserver>} */
        this.onUpdate = parameters.onUpdate || noop;
        /** @type {Callback<ScrollObserver>} */
        this.onSyncComplete = parameters.onSyncComplete || noop;
        /** @type {Boolean} */
        this.reverted = false;
        /** @type {Boolean} */
        this.completed = false;
        /** @type {Boolean} */
        this.began = false;
        /** @type {Boolean} */
        this.isInView = false;
        /** @type {Boolean} */
        this.forceEnter = false;
        /** @type {Boolean} */
        this.hasEntered = false;
        /** @type {Array.<Number>} */
        this.offsets = [];
        /** @type {Number} */
        this.offset = 0;
        /** @type {Number} */
        this.offsetStart = 0;
        /** @type {Number} */
        this.offsetEnd = 0;
        /** @type {Number} */
        this.distance = 0;
        /** @type {Number} */
        this.prevProgress = 0;
        /** @type {Array} */
        this.thresholds = ['start', 'end', 'end', 'start'];
        /** @type {[Number, Number, Number, Number]} */
        this.coords = [0, 0, 0, 0];
        /** @type {JSAnimation} */
        this.debugStyles = null;
        /** @type {HTMLElement} */
        this.$debug = null;
        /** @type {ScrollObserverParams} */
        this._params = parameters;
        /** @type {Boolean} */
        this._debug = setValue(parameters.debug, false);
        /** @type {ScrollObserver} */
        this._next = null;
        /** @type {ScrollObserver} */
        this._prev = null;
        addChild(this.container, this);
        // Wait for the next frame to add to the container in order to handle calls to link()
        sync(() => {
            if (this.reverted)
                return;
            if (!this.target) {
                const target = /** @type {HTMLElement} */ (parseTargets(parameters.target)[0]);
                this.target = target || doc.body;
                this.refresh();
            }
            if (this._debug)
                this.debug();
        });
    }
    /**
     * @param {Tickable|WAAPIAnimation} linked
     */
    link(linked) {
        if (linked) {
            // Make sure to pause the linked object in case it's added later
            linked.pause();
            this.linked = linked;
            // Try to use a target of the linked object if no target parameters specified
            if (!this._params.target) {
                /** @type {HTMLElement} */
                let $linkedTarget;
                if (!isUnd(/** @type {JSAnimation} */ (linked).targets)) {
                    $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */ (linked));
                }
                else {
                    forEachChildren(/** @type {Timeline} */ (linked), (/** @type {JSAnimation} */ child) => {
                        if (child.targets && !$linkedTarget) {
                            $linkedTarget = getAnimationDomTarget(/** @type {JSAnimation} */ (child));
                        }
                    });
                }
                // Fallback to body if no target found
                this.target = $linkedTarget || doc.body;
                this.refresh();
            }
        }
        return this;
    }
    get velocity() {
        return this.container.velocity;
    }
    get backward() {
        return this.horizontal ? this.container.backwardX : this.container.backwardY;
    }
    get scroll() {
        return this.horizontal ? this.container.scrollX : this.container.scrollY;
    }
    get progress() {
        const p = (this.scroll - this.offsetStart) / this.distance;
        return p === Infinity || isNaN(p) ? 0 : round(clamp(p, 0, 1), 6);
    }
    refresh() {
        this.reverted = false;
        const params = this._params;
        this.repeat = setValue(parseScrollObserverFunctionParameter(params.repeat, this), true);
        this.horizontal = setValue(parseScrollObserverFunctionParameter(params.axis, this), 'y') === 'x';
        this.enter = setValue(parseScrollObserverFunctionParameter(params.enter, this), 'end start');
        this.leave = setValue(parseScrollObserverFunctionParameter(params.leave, this), 'start end');
        this.updateBounds();
        this.handleScroll();
        return this;
    }
    removeDebug() {
        if (this.$debug) {
            this.$debug.parentNode.removeChild(this.$debug);
            this.$debug = null;
        }
        if (this.debugStyles) {
            this.debugStyles.revert();
            this.$debug = null;
        }
        return this;
    }
    debug() {
        this.removeDebug();
        const container = this.container;
        const isHori = this.horizontal;
        const $existingDebug = container.element.querySelector(':scope > .animejs-onscroll-debug');
        const $debug = doc.createElement('div');
        const $thresholds = doc.createElement('div');
        const $triggers = doc.createElement('div');
        const color = debugColors[this.index % debugColors.length];
        const useWin = container.useWin;
        const containerWidth = useWin ? container.winWidth : container.width;
        const containerHeight = useWin ? container.winHeight : container.height;
        const scrollWidth = container.scrollWidth;
        const scrollHeight = container.scrollHeight;
        const size = this.container.width > 360 ? 320 : 260;
        const offLeft = isHori ? 0 : 10;
        const offTop = isHori ? 10 : 0;
        const half = isHori ? 24 : size / 2;
        const labelHeight = isHori ? half : 15;
        const labelWidth = isHori ? 60 : half;
        const labelSize = isHori ? labelWidth : labelHeight;
        const repeat = isHori ? 'repeat-x' : 'repeat-y';
        /**
         * @param {Number} v
         * @return {String}
         */
        const gradientOffset = v => isHori ? '0px ' + (v) + 'px' : (v) + 'px' + ' 2px';
        /**
         * @param {String} c
         * @return {String}
         */
        const lineCSS = (c) => `linear-gradient(${isHori ? 90 : 0}deg, ${c} 2px, transparent 1px)`;
        /**
         * @param {String} p
         * @param {Number} l
         * @param {Number} t
         * @param {Number} w
         * @param {Number} h
         * @return {String}
         */
        const baseCSS = (p, l, t, w, h) => `position:${p};left:${l}px;top:${t}px;width:${w}px;height:${h}px;`;
        $debug.style.cssText = `${baseCSS('absolute', offLeft, offTop, isHori ? scrollWidth : size, isHori ? size : scrollHeight)}
      pointer-events: none;
      z-index: ${this.container.zIndex++};
      display: flex;
      flex-direction: ${isHori ? 'column' : 'row'};
      filter: drop-shadow(0px 1px 0px rgba(0,0,0,.75));
    `;
        $thresholds.style.cssText = `${baseCSS('sticky', 0, 0, isHori ? containerWidth : half, isHori ? half : containerHeight)}`;
        if (!$existingDebug) {
            $thresholds.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(half - 10)} / ${isHori ? '100px 100px' : '100px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(half - 10)} / ${isHori ? '10px 10px' : '10px 10px'} ${repeat};
      `;
        }
        $triggers.style.cssText = `${baseCSS('relative', 0, 0, isHori ? scrollWidth : half, isHori ? half : scrollHeight)}`;
        if (!$existingDebug) {
            $triggers.style.cssText += `background:
        ${lineCSS('#FFFF')}${gradientOffset(0)} / ${isHori ? '100px 10px' : '10px 100px'} ${repeat},
        ${lineCSS('#FFF8')}${gradientOffset(0)} / ${isHori ? '10px 0px' : '0px 10px'} ${repeat};
      `;
        }
        const labels = [' enter: ', ' leave: '];
        this.coords.forEach((v, i) => {
            const isView = i > 1;
            const value = (isView ? 0 : this.offset) + v;
            const isTail = i % 2;
            const isFirst = value < labelSize;
            const isOver = value > (isView ? isHori ? containerWidth : containerHeight : isHori ? scrollWidth : scrollHeight) - labelSize;
            const isFlip = (isView ? isTail && !isFirst : !isTail && !isFirst) || isOver;
            const $label = doc.createElement('div');
            const $text = doc.createElement('div');
            const dirProp = isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top';
            const flipOffset = isFlip ? (isHori ? labelWidth : labelHeight) + (!isView ? isHori ? -1 : -2 : isHori ? -1 : isOver ? 0 : -2) : !isView ? isHori ? 1 : 0 : isHori ? 1 : 0;
            // $text.innerHTML = `${!isView ? '' : labels[isTail] + ' '}${this.id}: ${this.thresholds[i]} ${isView ? '' : labels[isTail]}`;
            $text.innerHTML = `${this.id}${labels[isTail]}${this.thresholds[i]}`;
            $label.style.cssText = `${baseCSS('absolute', 0, 0, labelWidth, labelHeight)}
        display: flex;
        flex-direction: ${isHori ? 'column' : 'row'};
        justify-content: flex-${isView ? 'start' : 'end'};
        align-items: flex-${isFlip ? 'end' : 'start'};
        border-${dirProp}: 2px ${isTail ? 'solid' : 'solid'} ${color};
      `;
            $text.style.cssText = `
        overflow: hidden;
        max-width: ${(size / 2) - 10}px;
        height: ${labelHeight};
        margin-${isHori ? isFlip ? 'right' : 'left' : isFlip ? 'bottom' : 'top'}: -2px;
        padding: 1px;
        font-family: ui-monospace, monospace;
        font-size: 10px;
        letter-spacing: -.025em;
        line-height: 9px;
        font-weight: 600;
        text-align: ${isHori && isFlip || !isHori && !isView ? 'right' : 'left'};
        white-space: pre;
        text-overflow: ellipsis;
        color: ${isTail ? color : 'rgba(0,0,0,.75)'};
        background-color: ${isTail ? 'rgba(0,0,0,.65)' : color};
        border: 2px solid ${isTail ? color : 'transparent'};
        border-${isHori ? isFlip ? 'top-left' : 'top-right' : isFlip ? 'top-left' : 'bottom-left'}-radius: 5px;
        border-${isHori ? isFlip ? 'bottom-left' : 'bottom-right' : isFlip ? 'top-right' : 'bottom-right'}-radius: 5px;
      `;
            $label.appendChild($text);
            let position = value - flipOffset + (isHori ? 1 : 0);
            $label.style[isHori ? 'left' : 'top'] = `${position}px`;
            // $label.style[isHori ? 'left' : 'top'] = value - flipOffset + (!isFlip && isFirst && !isView ? 1 : isFlip ? 0 : -2) + 'px';
            (isView ? $thresholds : $triggers).appendChild($label);
        });
        $debug.appendChild($thresholds);
        $debug.appendChild($triggers);
        container.element.appendChild($debug);
        if (!$existingDebug)
            $debug.classList.add('animejs-onscroll-debug');
        this.$debug = $debug;
        const containerPosition = getTargetValue(container.element, 'position');
        if (containerPosition === 'static') {
            this.debugStyles = setTargetValues(container.element, { position: 'relative ' });
        }
    }
    updateBounds() {
        if (this._debug) {
            this.removeDebug();
        }
        let stickys;
        const $target = this.target;
        const container = this.container;
        const isHori = this.horizontal;
        const linked = this.linked;
        let linkedTime;
        let $el = $target;
        let offsetX = 0;
        let offsetY = 0;
        /** @type {Element} */
        let $offsetParent = $el;
        if (linked) {
            linkedTime = linked.currentTime;
            linked.seek(0, true);
        }
        const isContainerStatic = getTargetValue(container.element, 'position') === 'static' ? setTargetValues(container.element, { position: 'relative ' }) : false;
        while ($el && $el !== container.element && $el !== doc.body) {
            const isSticky = getTargetValue($el, 'position') === 'sticky' ?
                setTargetValues($el, { position: 'static' }) :
                false;
            if ($el === $offsetParent) {
                offsetX += $el.offsetLeft || 0;
                offsetY += $el.offsetTop || 0;
                $offsetParent = $el.offsetParent;
            }
            $el = /** @type {HTMLElement} */ ($el.parentElement);
            if (isSticky) {
                if (!stickys)
                    stickys = [];
                stickys.push(isSticky);
            }
        }
        if (isContainerStatic)
            isContainerStatic.revert();
        const offset = isHori ? offsetX : offsetY;
        const targetSize = isHori ? $target.offsetWidth : $target.offsetHeight;
        const containerSize = isHori ? container.width : container.height;
        const scrollSize = isHori ? container.scrollWidth : container.scrollHeight;
        const maxScroll = scrollSize - containerSize;
        const enter = this.enter;
        const leave = this.leave;
        /** @type {ScrollThresholdValue} */
        let enterTarget = 'start';
        /** @type {ScrollThresholdValue} */
        let leaveTarget = 'end';
        /** @type {ScrollThresholdValue} */
        let enterContainer = 'end';
        /** @type {ScrollThresholdValue} */
        let leaveContainer = 'start';
        if (isStr(enter)) {
            const splitted = /** @type {String} */ (enter).split(' ');
            enterContainer = splitted[0];
            enterTarget = splitted.length > 1 ? splitted[1] : enterTarget;
        }
        else if (isObj(enter)) {
            const e = /** @type {ScrollThresholdParam} */ (enter);
            if (!isUnd(e.container))
                enterContainer = e.container;
            if (!isUnd(e.target))
                enterTarget = e.target;
        }
        else if (isNum(enter)) {
            enterContainer = /** @type {Number} */ (enter);
        }
        if (isStr(leave)) {
            const splitted = /** @type {String} */ (leave).split(' ');
            leaveContainer = splitted[0];
            leaveTarget = splitted.length > 1 ? splitted[1] : leaveTarget;
        }
        else if (isObj(leave)) {
            const t = /** @type {ScrollThresholdParam} */ (leave);
            if (!isUnd(t.container))
                leaveContainer = t.container;
            if (!isUnd(t.target))
                leaveTarget = t.target;
        }
        else if (isNum(leave)) {
            leaveContainer = /** @type {Number} */ (leave);
        }
        const parsedEnterTarget = parseBoundValue($target, enterTarget, targetSize);
        const parsedLeaveTarget = parseBoundValue($target, leaveTarget, targetSize);
        const under = (parsedEnterTarget + offset) - containerSize;
        const over = (parsedLeaveTarget + offset) - maxScroll;
        const parsedEnterContainer = parseBoundValue($target, enterContainer, containerSize, under, over);
        const parsedLeaveContainer = parseBoundValue($target, leaveContainer, containerSize, under, over);
        const offsetStart = parsedEnterTarget + offset - parsedEnterContainer;
        const offsetEnd = parsedLeaveTarget + offset - parsedLeaveContainer;
        const scrollDelta = offsetEnd - offsetStart;
        this.offsets[0] = offsetX;
        this.offsets[1] = offsetY;
        this.offset = offset;
        this.offsetStart = offsetStart;
        this.offsetEnd = offsetEnd;
        this.distance = scrollDelta <= 0 ? 0 : scrollDelta;
        this.thresholds = [enterTarget, leaveTarget, enterContainer, leaveContainer];
        this.coords = [parsedEnterTarget, parsedLeaveTarget, parsedEnterContainer, parsedLeaveContainer];
        if (stickys) {
            stickys.forEach(sticky => sticky.revert());
        }
        if (linked) {
            linked.seek(linkedTime, true);
        }
        if (this._debug) {
            this.debug();
        }
    }
    handleScroll() {
        const linked = this.linked;
        const sync = this.sync;
        const syncEase = this.syncEase;
        const syncSmooth = this.syncSmooth;
        const shouldSeek = linked && (syncEase || syncSmooth);
        const isHori = this.horizontal;
        const container = this.container;
        const scroll = this.scroll;
        const isBefore = scroll <= this.offsetStart;
        const isAfter = scroll >= this.offsetEnd;
        const isInView = !isBefore && !isAfter;
        const isOnTheEdge = scroll === this.offsetStart || scroll === this.offsetEnd;
        const forceEnter = !this.hasEntered && isOnTheEdge;
        const $debug = this._debug && this.$debug;
        let hasUpdated = false;
        let syncCompleted = false;
        let p = this.progress;
        if (isBefore && this.began) {
            this.began = false;
        }
        if (p > 0 && !this.began) {
            this.began = true;
        }
        if (shouldSeek) {
            const lp = linked.progress;
            if (syncSmooth && isNum(syncSmooth)) {
                if ( /** @type {Number} */(syncSmooth) < 1) {
                    const step = 0.0001;
                    const snap = lp < p && p === 1 ? step : lp > p && !p ? -1e-4 : 0;
                    p = round(lerp(lp, p, interpolate(.01, .2, /** @type {Number} */ (syncSmooth)), false) + snap, 6);
                }
            }
            else if (syncEase) {
                p = syncEase(p);
            }
            hasUpdated = p !== this.prevProgress;
            syncCompleted = lp === 1;
            if (hasUpdated && !syncCompleted && (syncSmooth && lp)) {
                container.wakeTicker.restart();
            }
        }
        if ($debug) {
            const sticky = isHori ? container.scrollY : container.scrollX;
            $debug.style[isHori ? 'top' : 'left'] = sticky + 10 + 'px';
        }
        // Trigger enter callbacks if already in view or when entering the view
        if ((isInView && !this.isInView) || (forceEnter && !this.forceEnter && !this.hasEntered)) {
            if (isInView)
                this.isInView = true;
            if (!this.forceEnter || !this.hasEntered) {
                if ($debug && isInView)
                    $debug.style.zIndex = `${this.container.zIndex++}`;
                this.onSyncEnter(this);
                this.onEnter(this);
                if (this.backward) {
                    this.onSyncEnterBackward(this);
                    this.onEnterBackward(this);
                }
                else {
                    this.onSyncEnterForward(this);
                    this.onEnterForward(this);
                }
                this.hasEntered = true;
                if (forceEnter)
                    this.forceEnter = true;
            }
            else if (isInView) {
                this.forceEnter = false;
            }
        }
        if (isInView || !isInView && this.isInView) {
            hasUpdated = true;
        }
        if (hasUpdated) {
            if (shouldSeek)
                linked.seek(linked.duration * p);
            this.onUpdate(this);
        }
        if (!isInView && this.isInView) {
            this.isInView = false;
            this.onSyncLeave(this);
            this.onLeave(this);
            if (this.backward) {
                this.onSyncLeaveBackward(this);
                this.onLeaveBackward(this);
            }
            else {
                this.onSyncLeaveForward(this);
                this.onLeaveForward(this);
            }
            if (sync && !syncSmooth) {
                syncCompleted = true;
            }
        }
        if (p >= 1 && this.began && !this.completed && (sync && syncCompleted || !sync)) {
            if (sync) {
                this.onSyncComplete(this);
            }
            this.completed = true;
            if ((!this.repeat && !linked) || (!this.repeat && linked && linked.completed)) {
                this.revert();
            }
        }
        if (p < 1 && this.completed) {
            this.completed = false;
        }
        this.prevProgress = p;
    }
    revert() {
        if (this.reverted)
            return;
        const container = this.container;
        removeChild(container, this);
        if (!container._head) {
            container.revert();
        }
        if (this._debug) {
            this.removeDebug();
        }
        this.reverted = true;
        return this;
    }
}
/**
 * @param {ScrollObserverParams} [parameters={}]
 * @return {ScrollObserver}
 */
const onScroll = (parameters = {}) => new ScrollObserver(parameters);


/**
 * @typedef  {Object} StaggerParameters
 * @property {Number|String} [start]
 * @property {Number|'first'|'center'|'last'} [from]
 * @property {Boolean} [reversed]
 * @property {Array.<Number>} [grid]
 * @property {('x'|'y')} [axis]
 * @property {EasingParam} [ease]
 * @property {TweenModifier} [modifier]
 */
/**
 * @callback StaggerFunction
 * @param {Target} [target]
 * @param {Number} [index]
 * @param {Number} [length]
 * @param {Timeline} [tl]
 * @return {Number|String}
 */
/**
 * @param  {Number|String|[Number|String,Number|String]} val
 * @param  {StaggerParameters} params
 * @return {StaggerFunction}
 */
const stagger = (val, params = {}) => {
    let values = [];
    let maxValue = 0;
    const from = params.from;
    const reversed = params.reversed;
    const ease = params.ease;
    const hasEasing = !isUnd(ease);
    const hasSpring = hasEasing && !isUnd(/** @type {Spring} */ (ease).ease);
    const staggerEase = hasSpring ? /** @type {Spring} */ (ease).ease : hasEasing ? parseEasings(ease) : null;
    const grid = params.grid;
    const axis = params.axis;
    const fromFirst = isUnd(from) || from === 0 || from === 'first';
    const fromCenter = from === 'center';
    const fromLast = from === 'last';
    const isRange = isArr(val);
    const val1 = isRange ? parseNumber(val[0]) : parseNumber(val);
    const val2 = isRange ? parseNumber(val[1]) : 0;
    const unitMatch = unitsExecRgx.exec((isRange ? val[1] : val) + emptyString);
    const start = params.start || 0 + (isRange ? val1 : 0);
    let fromIndex = fromFirst ? 0 : isNum(from) ? from : 0;
    return (_, i, t, tl) => {
        if (fromCenter)
            fromIndex = (t - 1) / 2;
        if (fromLast)
            fromIndex = t - 1;
        if (!values.length) {
            for (let index = 0; index < t; index++) {
                if (!grid) {
                    values.push(abs(fromIndex - index));
                }
                else {
                    const fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
                    const fromY = !fromCenter ? floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
                    const toX = index % grid[0];
                    const toY = floor(index / grid[0]);
                    const distanceX = fromX - toX;
                    const distanceY = fromY - toY;
                    let value = sqrt(distanceX * distanceX + distanceY * distanceY);
                    if (axis === 'x')
                        value = -distanceX;
                    if (axis === 'y')
                        value = -distanceY;
                    values.push(value);
                }
                maxValue = max(...values);
            }
            if (staggerEase)
                values = values.map(val => staggerEase(val / maxValue) * maxValue);
            if (reversed)
                values = values.map(val => axis ? (val < 0) ? val * -1 : -val : abs(maxValue - val));
        }
        const spacing = isRange ? (val2 - val1) / maxValue : val1;
        const offset = tl ? parseTimelinePosition(tl, isUnd(params.start) ? tl.iterationDuration : start) : /** @type {Number} */ (start);
        /** @type {String|Number} */
        let output = offset + ((spacing * round(values[i], 2)) || 0);
        if (params.modifier)
            output = params.modifier(output);
        if (unitMatch)
            output = `${output}${unitMatch[2]}`;
        return output;
    };
};

export { Animatable, Draggable, JSAnimation, Scope, ScrollObserver, Spring, Timeline, Timer, WAAPIAnimation, animate, createAnimatable, createDraggable, createScope, createSpring, createTimeline, createTimer, eases, engine, onScroll, scrollContainers, stagger, svg, utils, waapi };


