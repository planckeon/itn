Directory structure:
└── peterdenton-nufast/
    ├── Readme.md
    ├── LICENSE
    ├── Benchmarks/
    │   ├── c++/
    │   │   ├── Makefile
    │   │   ├── include/
    │   │   │   ├── Benchmark.h
    │   │   │   ├── DMP.h
    │   │   │   ├── Exact_Cubic.h
    │   │   │   ├── NuFast.h
    │   │   │   └── Page.h
    │   │   └── src/
    │   │       ├── Benchmark.cpp
    │   │       ├── DMP.cpp
    │   │       ├── Exact_Cubic.cpp
    │   │       ├── NuFast.cpp
    │   │       └── Page.cpp
    │   ├── f/
    │   │   ├── Makefile
    │   │   └── src/
    │   │       ├── Benchmark.f90
    │   │       ├── Exact_Cubic.f90
    │   │       └── NuFast.f90
    │   └── globes/
    │       ├── Makefile
    │       ├── include/
    │       │   ├── glb_error.h
    │       │   ├── glb_probability.h
    │       │   └── Parameters.h
    │       └── src/
    │           ├── glb_error.c
    │           ├── glb_probability.c
    │           └── main.c
    ├── c++/
    │   ├── compile.sh
    │   └── NuFast.cpp
    ├── f/
    │   ├── compile.sh
    │   └── NuFast.f90
    └── py/
        └── NuFast.py

================================================
FILE: Readme.md
================================================
| arXiv |
|:-----:|
|[![arXiv](https://img.shields.io/badge/arXiv-2405.02400-orange.svg)](https://arXiv.org/abs/2405.02400)|

# **NuFast**: A fast code for long-baseline neutrino oscillation probabilities in matter

### Overview
**NuFast** is designed to calculate all nine neutrino oscillation probabilities in matter for long-baseline accelerator (e.g. NOvA, T2K, DUNE, HK) and reactor experiments (e.g. JUNO) very quickly, using the algorithms optimized for realistic oscillation scenarios. **NuFast** is provided in fortran, c++, and python, although no particular guarantees are made that the python code is "fast".

### General usage
The folders for each language contain a minimal working implementation to calculate the probabilities in matter and vacuum. The functions take as input the six oscillation parameters, with the mixing angles in the form of `s12sq` and so on. The CP violating phase, `delta`, is in radians. The atmospheric mass ordering is set by the sign of `Dmsq31`. The mass-squared differences are in eV<sup>2</sup>. For antineutrinos change only the energy to negative. The neutrino energy is in GeV, the baseline is in km, and the density is in g/cc. The electron fraction, `Ye`, is typically about 0.5 in the Earth. The function returns a 3x3 array `probs_returned` which contains all nine channels. The first index corresponds to the initial neutrino flavor (fortran is 1-indexed so e=1, while c++ and python are 0-indexed so e=0). Finally, the `N_Newton` parameter provides a proxy for the precision. `N_Newton=0` is already precise enough for even the next generation of neutrino oscillation experiments and higher values add orders of magnitude to the precision for minimal computational cost.

We strongly encourage a careful examination of the constants used (G<sub>F</sub>, etc.) when comparing to existing codes.

An additional function, `Probability_Vacuum_LBL`, is provided for vacuum calculations. The algorithm is the same as the standard one, but it skips the matter effect.

The code can be compiled with the simple `compile.sh` file provided in the fortran and c++ folders. The benchmark codes can be compiled with the given makefiles by running `make`. The inclusion of aggressive compiler flags like `-ffast-math` can be included or not.

If a user requires a python code, we recommend the use of cython, f2py, or something similar from the c++ or fortran codes. The python code is included so that those who are only familiar with python can easily parse the algorithm itself, not for efficient computations.

### Benchmark
The benchmark folder contains the same code in a slightly different structure, as well as some other neutrino oscillation probability codes. It computes the precision of the **NuFast** algorithm and also benchmarks the computational speed.

### GLoBES
The included `GLoBES` code is adapted from the well known GLoBES code at [https://www.mpi-hd.mpg.de/personalhomes/globes/index.html](https://www.mpi-hd.mpg.de/personalhomes/globes/index.html). If that portion of the code is used, please cite them as appropriate.

Running the GLoBES code requires GSL. The makefile should work fine if it is installed in a typical Linux system.

### Usage
If you use this code, please cite the associated paper [arXiv:2405.02400](https://arxiv.org/abs/2405.02400) by Peter Denton and Stephen Parke. Please also let us know if you find any bugs or further optimizations or if you run your own speed tests.



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 Peter B. Denton

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: Benchmarks/c++/Makefile
================================================
CXX=g++

CFlags=-c -Wall -MMD -std=c++11
#CFlags+=-Ofast -ffast-math # can improve speed by 10s of percent over the default of -O0

Sources=$(wildcard src/*.cpp)
IncludeDir=-I./include
AllObjects=$(addprefix obj/,$(notdir $(Sources:.cpp=.o)))
Executables=Benchmark
Objects=$(filter-out $(addprefix obj/,$(Executables:=.o)),$(AllObjects))

all: $(Sources) $(Executables)

$(Executables): $(AllObjects)
	@mkdir -p obj data
	$(CXX) $(Objects) $(addprefix obj/,$@.o) -o $@

obj/%.o: src/%.cpp
	@mkdir -p $(@D)
	$(CXX) $(CFlags) $(IncludeDir) $< -o $@

-include $(AllObjects:.o=.d)

clean:
	rm -rf obj/*.o obj/*.d $(Executables)




================================================
FILE: Benchmarks/c++/include/Benchmark.h
================================================
#ifndef Benchmark_H
#define Benchmark_H

extern double const eVsqkm_to_GeV_over4, YerhoE2a, oneThird;

#endif



================================================
FILE: Benchmarks/c++/include/DMP.h
================================================
#ifndef DMP_H
#define DMP_H

// From http://arxiv.org/abs/1604.08167
// Zeorth order only

void Probability_Matter_LBL_DMP(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int empty, double (*probs_returned)[3][3]);

#endif



================================================
FILE: Benchmarks/c++/include/Exact_Cubic.h
================================================
#ifndef Exact_Cubic_H
#define Exact_Cubic_H

void Probability_Matter_LBL_Exact_Cubic(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int empty, double (*probs_returned)[3][3]);

#endif



================================================
FILE: Benchmarks/c++/include/NuFast.h
================================================
#ifndef NuFast_H
#define NuFast_H

void Probability_Matter_LBL(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int N_Newton, double (*probs_returned)[3][3]);
void Probability_Vacuum_LBL(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double empty1, double empty2, int empty3, double (*probs_returned)[3][3]);

#endif



================================================
FILE: Benchmarks/c++/include/Page.h
================================================
#ifndef Page_H
#define Page_H

void Probability_Matter_LBL_Page(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int empty, double (*probs_returned)[3][3]);

#endif



================================================
FILE: Benchmarks/c++/src/Benchmark.cpp
================================================
#include <cmath>
#include <cstdio>
#include <chrono>
#include "Benchmark.h"
#include "NuFast.h"
#include "Exact_Cubic.h"
#include "Page.h"
#include "DMP.h"

// Some constants
double const eVsqkm_to_GeV_over4 = 1e-9 / 1.97327e-7 * 1e3 / 4;
double const YerhoE2a = 1.52588e-4;
double const oneThird = 1. / 3;

// Compute the speed n times and calculate the mean over those n times
// N_Newton is used for NuFast only, ignored otherwise
double Speed_Helper(void Probability_Calculator(double, double, double, double, double, double, double, double, double, double, int, double (*probs_returned)[3][3]), int n, int N_Newton)
{
	double s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, Emin, Emax, Estep, rho, Ye, probs_returned[3][3];

	// ------------------------------------- //
	// Set the vacuum oscillation parameters //
	// ------------------------------------- //
	s12sq = 0.31;
	s13sq = 0.02;
	s23sq = 0.55;
	delta = -0.7 * M_PI;
	Dmsq21 = 7.5e-5; // eV^2
	Dmsq31 = 2.5e-3; // eV^2

	// ------------------------------- //
	// Set the experimental parameters //
	// ------------------------------- //
	L = 1300; // km
	Emin = 0.5; // GeV
	Emax = 5;
	Estep = (Emax - Emin) / n;
	rho = 3; // g/cc
	Ye = 0.5;

	std::chrono::high_resolution_clock::time_point start_time = std::chrono::high_resolution_clock::now();
	for (int i = 0; i < n; i++)
	{
		E = Emin + i * Estep;
		Probability_Calculator(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, &probs_returned);
	} // i, E, n
	std::chrono::high_resolution_clock::time_point end_time = std::chrono::high_resolution_clock::now();
	return std::chrono::duration_cast<std::chrono::duration<double>>(end_time - start_time).count() / n;
}

// Compute the speed many times and calculate the mean and standard deviation
// m is outer loop, n, is inner loop
// N_Newton is used for NuFast only, ignored otherwise
void Speed(void Probability_Calculator(double, double, double, double, double, double, double, double, double, double, int, double (*probs_returned)[3][3]), int m, int n, int N_Newton, double &mean, double &std)
{
	double s, speed_sum, speedsq_sum;

	speed_sum = 0;
	speedsq_sum = 0;
	for (int i = 0; i < m; i++)
	{
		s = Speed_Helper(Probability_Calculator, n, N_Newton) * 1e9; // in ns
		speed_sum += s;
		speedsq_sum += s * s;
	} // i, m
	mean = speed_sum / m;
	std = sqrt(speedsq_sum / m - mean * mean);
}

int main()
{
	double s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31;
	double L, E, rho, Ye;
	double Emin, Emax, Estep;
	double mean, std;
	int N_Newton, m, n;
	double probs_returned[3][3], probs_returned_Exact_Cubic[3][3];

	// ------------------------------------- //
	// Set the vacuum oscillation parameters //
	// ------------------------------------- //
	s12sq = 0.31;
	s13sq = 0.02;
	s23sq = 0.55;
	delta = -0.7 * M_PI;
	Dmsq21 = 7.5e-5;  // eV^2
	Dmsq31 = +2.5e-3; // eV^2

	// ------------------------------- //
	// Set the experimental parameters //
	// ------------------------------- //
	L = 1300; // km
	E = 2.5; // GeV
	rho = 3; // g/cc
	Ye = 0.5;

	N_Newton = 0; // <-- Sets the precision. 0 is close to the single precision limit and is better than DUNE/HK in the high statistics regime. Increasig N_Newton improves the precision at a modest computational cost

	// ------------------------------------------ //
	// Calculate all 9 oscillations probabilities //
	// ------------------------------------------ //
	Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, &probs_returned);
	Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &probs_returned_Exact_Cubic);

	// ------------------------------- //
	// Print out the fractional errors //
	// ------------------------------- //
	printf("L = %g E = %g rho = %g Ye = %g N_Newton = %d\n", L, E, rho, Ye, N_Newton);
	printf("Precision (N_Newton = %d):\n", N_Newton);
	printf("alpha beta DeltaP/P\n");
	for (int alpha = 0; alpha < 3; alpha++)
	{
		for (int beta = 0; beta < 3; beta++)
		{
			printf("%d %d %g\n", alpha, beta, fabs(probs_returned[alpha][beta] - probs_returned_Exact_Cubic[alpha][beta]) / probs_returned_Exact_Cubic[alpha][beta]);
		} // beta, 3
	} // alpha, 3

	// ----------------------------------- //
	// Write the fractional errors to file //
	// ----------------------------------- //
	n = 1e3;
	// DUNE //
	Emin = 0.5;
	Emax = 5;
	Estep = (Emax - Emin) / n;
	FILE *dataf = fopen("data/Precision_DUNE.txt", "w");
	fprintf(dataf, "%g %g %g\n", L, rho, Ye);
	for (int i = 0; i <= n; i++)
	{
		E = Emin + i * Estep;
		fprintf(dataf, "%g ", E);
		Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &probs_returned_Exact_Cubic);
		for (int j = 0; j < 2; j++)
		{
			Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, j, &probs_returned);
			fprintf(dataf, "%g %g ", fabs(probs_returned[1][1] - probs_returned_Exact_Cubic[1][1]) / probs_returned_Exact_Cubic[1][1], fabs(probs_returned[1][0] - probs_returned_Exact_Cubic[1][0]) / probs_returned_Exact_Cubic[1][0]);
		} // j, N_Newton, 2
		// now do DMP
		Probability_Matter_LBL_DMP(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &probs_returned);
		fprintf(dataf, "%g %g ", fabs(probs_returned[1][1] - probs_returned_Exact_Cubic[1][1]) / probs_returned_Exact_Cubic[1][1], fabs(probs_returned[1][0] - probs_returned_Exact_Cubic[1][0]) / probs_returned_Exact_Cubic[1][0]);
		fprintf(dataf, "\n");
	} // i, E, n
	fclose(dataf);

	// HK //
	L = 295;
	Emin = 0.1;
	Emax = 2;
	Estep = (Emax - Emin) / n;
	dataf = fopen("data/Precision_HK.txt", "w");
	fprintf(dataf, "%g %g %g\n", L, rho, Ye);
	for (int i = 0; i <= n; i++)
	{
		E = Emin + i * Estep;
		fprintf(dataf, "%g ", E);
		Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &probs_returned_Exact_Cubic);
		for (int j = 0; j < 2; j++)
		{
			Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, j, &probs_returned);
			fprintf(dataf, "%g %g ", fabs(probs_returned[1][1] - probs_returned_Exact_Cubic[1][1]) / probs_returned_Exact_Cubic[1][1], fabs(probs_returned[1][0] - probs_returned_Exact_Cubic[1][0]) / probs_returned_Exact_Cubic[1][0]);
		} // j, N_Newton, 2
		// now do DMP
		Probability_Matter_LBL_DMP(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &probs_returned);
		fprintf(dataf, "%g %g ", fabs(probs_returned[1][1] - probs_returned_Exact_Cubic[1][1]) / probs_returned_Exact_Cubic[1][1], fabs(probs_returned[1][0] - probs_returned_Exact_Cubic[1][0]) / probs_returned_Exact_Cubic[1][0]);
		fprintf(dataf, "\n");
	} // i, E, n
	fclose(dataf);

	// JUNO //
	L = 50;
	rho = 2.6;
	Emin = 1e-3;
	Emax = 10e-3;
	Estep = (Emax - Emin) / n;
	dataf = fopen("data/Precision_JUNO.txt", "w");
	fprintf(dataf, "%g %g %g %d\n", L, rho, Ye, N_Newton);
	for (int i = 0; i <= n; i++)
	{
		E = Emin + i * Estep;
		Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, -E, rho, Ye, N_Newton, &probs_returned);
		Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, -E, rho, Ye, 0, &probs_returned_Exact_Cubic);
		fprintf(dataf, "%g %g\n", E, fabs(probs_returned[0][0] - probs_returned_Exact_Cubic[0][0]) / probs_returned_Exact_Cubic[0][0]);
	} // i, E, n
	fclose(dataf);

	// ---------- //
	// Speed test //
	// ---------- //
	dataf = fopen("data/Speed.txt", "w");
	m = int(1e3);
	n = int(1e6);

	printf("\nSpeed (this takes a moment):\n");

	// Vacuum probability
	printf("Vacuum (1/7)\n");
	Speed(Probability_Vacuum_LBL, m, n, 0, mean, std);
	printf("%g +- %g ns\n", mean, std);
	fprintf(dataf, "Vacuum %g += %g ns\n", mean, std);

	// NuFast at various N_Newton levels
	for (N_Newton = 0; N_Newton <= 3; N_Newton++)
	{
		printf("N_Newton = %d (%d/7)\n", N_Newton, N_Newton + 2);
		Speed(Probability_Matter_LBL, m, n, N_Newton, mean, std);
		printf("%g +- %g ns\n", mean, std);
		fprintf(dataf, "N_Newton=%d %g += %g ns\n", N_Newton, mean, std);
	} // N_Newton, 0, 3

	// Exact with cubic from Cardano/ZS
	printf("Exact_Cubic (6/7)\n");
	Speed(Probability_Matter_LBL_Exact_Cubic, m, n, 0, mean, std);
	printf("%g +- %g ns\n", mean, std);
	fprintf(dataf, "Exact_Cubic %g += %g ns\n", mean, std);

	// Page's algorithm from 2309.06900
	printf("Page (7/7)\n");
	Speed(Probability_Matter_LBL_Page, m, n, 0, mean, std);
	printf("%g +- %g ns\n", mean, std);
	fprintf(dataf, "Page %g += %g ns\n", mean, std);

	fclose(dataf);

	return 0;
}



================================================
FILE: Benchmarks/c++/src/DMP.cpp
================================================
#include <cmath>
#include "DMP.h"
#include "Benchmark.h"

#define sq(x) ((x)*(x))

void Probability_Matter_LBL_DMP(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int empty, double (*probs_returned)[3][3])
{
	double Dmsqeea, c2phi, a12, cphisq, sphisq, s2phi, cphi13sq, Dl21, c2psi, cpsisq, spsisq, Dl31, L4E, Delta21, Delta31, Delta32, sDelta21, sDelta31, sDelta32, dab, Jrm, C31, C32, C21, D, tmp;

	double c12, s12, s212, c212, c12sq, c13, s13, s213, c213, c13sq, c23, s23, c23sq, Dmsqee, cd, sd, a, Jrrm;
	c12sq = 1 - s12sq;
	c212 = c12sq - s12sq;
	s12 = sqrt(s12sq);
	c12 = sqrt(c12sq);
	s212 = 2 * s12 * c12;
	c23sq = 1 - s23sq;
	c23 = sqrt(c23sq);
	s23 = sqrt(s23sq);
	c13sq = 1 - s13sq;
	c13 = sqrt(c13sq);
	s13 = sqrt(s13sq);
	s213 = 2 * s13 * c13;
	c213 = c13sq - s13sq;
	Dmsqee = Dmsq31 - s12sq * Dmsq21;
	cd = cos(delta);
	sd = sin(delta);
	a = Ye * E * rho * YerhoE2a;

	tmp = c213 - a / Dmsqee;
	Dmsqeea = Dmsqee * sqrt(sq(tmp) + sq(s213));
	c2phi = (Dmsqee * c213 - a) / Dmsqeea;
	a12 = 0.5 * (a + Dmsqee - Dmsqeea);

	cphisq = 0.5 * (1 + c2phi);
	sphisq = 0.5 * (1 - c2phi);
	s2phi = s213 * Dmsqee / Dmsqeea;
	cphi13sq = cphisq * c13sq + sphisq * s13sq + s2phi * c13 * s13;

	tmp = c212 - a12 / Dmsq21;
	Dl21 = Dmsq21 * sqrt(sq(tmp) + cphi13sq * sq(s212));
	c2psi = (Dmsq21 * c212 - a12) / Dl21;
	cpsisq = 0.5 * (1 + c2psi);
	spsisq = 0.5 * (1 - c2psi);

	Dl31 = Dmsq31 + 0.25 * a + 0.5 * (Dl21 - Dmsq21) + 0.75 * (Dmsqeea - Dmsqee);

	Jrm = s23 * c23 * cphisq * sqrt(sphisq * cpsisq * spsisq);
	Jrrm = Jrm / cphisq;

	L4E = eVsqkm_to_GeV_over4 * L / E;
	Delta21 = Dl21 * L4E;
	Delta31 = Dl31 * L4E;
	Delta32 = Delta31 - Delta21;

	sDelta21 = sin(Delta21);
	sDelta31 = sin(Delta31);
	sDelta32 = sin(Delta32);

	// Pme
	dab = 0;
	C31 = s23sq * sphisq * cphisq * cpsisq + Jrm * cd;
	C32 = s23sq * sphisq * cphisq * spsisq - Jrm * cd;
	C21 = cphisq * spsisq * cpsisq * (c23sq - sphisq * s23sq) + Jrm * cd * c2psi;
	D = -Jrm * sd;
	(*probs_returned)[1][0] = dab + 4 * (C31 * sq(sDelta31) + C32 * sq(sDelta32) + C21 * sq(sDelta21)) + 8 * D * sDelta21 * sDelta31 * sDelta32;

	// Pmm
	dab = 1;
	C31 = -cphisq * s23sq * (c23sq * spsisq + s23sq * sphisq * cpsisq) - 2 * s23sq * Jrm * cd;
	C32 = -cphisq * s23sq * (c23sq * cpsisq + s23sq * sphisq * spsisq) + 2 * s23sq * Jrm * cd;
	C21 = -(c23sq * cpsisq + s23sq * sphisq * spsisq) * (c23sq * spsisq + s23sq * sphisq * cpsisq) - 2 * (c23sq - sphisq * s23sq) * c2psi * Jrrm * cd + sq(2 * Jrrm * cd);
	D = 0;
	(*probs_returned)[1][1] = dab + 4 * (C31 * sq(sDelta31) + C32 * sq(sDelta32) + C21 * sq(sDelta21)) + 8 * D * sDelta21 * sDelta31 * sDelta32; // me
}




================================================
FILE: Benchmarks/c++/src/Exact_Cubic.cpp
================================================
#include <cmath>
#include "Exact_Cubic.h"
#include "Benchmark.h"

void Probability_Matter_LBL_Exact_Cubic(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int empty, double (*probs_returned)[3][3])
{
    double Amatter, c13sq, sind, cosd;

    double A, B, C, S;
    double See, Smm, Tee, Tmm, rootAsqm3B, tmp;
    double lambda2, lambda3, Dlambda21, Dlambda31, Dlambda32;
    double Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq;

    double sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin, PiDlambdaInv, Xp2, Xp3;
    double D21, D32;
    double sinD21, sinD31, sinD32;
    double Lover4E, Jrr, Jmatter;
    double Pee, Pme_CPC, Pme_CPV, Pmm;

    // --------------------------------------------------------------------- //
    // First calculate useful simple functions of the oscillation parameters //
    // --------------------------------------------------------------------- //
    c13sq = 1 - s13sq;

    // Ueisq's
    Ue2sq = c13sq * s12sq;
    Ue3sq = s13sq;

    // Umisq's, Utisq's and Jvac     
    Um3sq = c13sq * s23sq;
    // Um2sq and Ut2sq are used here as temporary variables, will be properly defined later     
    Ut2sq = s13sq * s12sq * s23sq;
    Um2sq = (1 - s12sq) * (1 - s23sq);
      
    Jrr = sqrt(Um2sq * Ut2sq);
    sind = sin(delta);
    cosd = cos(delta);

    Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd;
    Jmatter = 8 * Jrr * c13sq * sind;
    Amatter = Ye * rho * E * YerhoE2a;

    // calculate A, B, C, See, Tee, and part of Tmm
    A = Dmsq21 + Dmsq31; // temporary variable
    See = A - Dmsq21 * Ue2sq - Dmsq31 * Ue3sq;
    Tmm = Dmsq21 * Dmsq31; // using Tmm as a temporary variable      
    Tee = Tmm * (1 - Ue3sq - Ue2sq);
    C = Amatter * Tee;
    A = A + Amatter;

    // -------------------------------- //
    // Get exact lambda3 from the cubic //
    // -------------------------------- //
    B = Tmm + Amatter * See;
    rootAsqm3B = sqrt(A * A - 3 * B);
    S = acos((A * A * A - 4.5 * A* B + 13.5 * C) / (rootAsqm3B * rootAsqm3B * rootAsqm3B));
    if (Dmsq31 < 0) S = S + 2 * M_PI; // adjust lambda3 for the IO
    lambda3 = (A + 2 * rootAsqm3B * cos(S * oneThird)) * oneThird;

    // ------------------- //
    // Get  Delta lambda's //
    // ------------------- //
	tmp = A - lambda3;
    Dlambda21 = sqrt(tmp * tmp - 4 * C / lambda3);
    lambda2 = 0.5 * (A - lambda3 + Dlambda21);
    Dlambda32 = lambda3 - lambda2;
    Dlambda31 = Dlambda32 + Dlambda21;

    // ----------------------- //
    // Use Rosetta for Ueisq's //
    // ----------------------- //
    // denominators      
    PiDlambdaInv = 1 / (Dlambda31 * Dlambda32 * Dlambda21);
    Xp3 = PiDlambdaInv * Dlambda21;
    Xp2 = -PiDlambdaInv * Dlambda31;

    // numerators
    Ue3sq = (lambda3 * (lambda3 - See) + Tee) * Xp3;
    Ue2sq = (lambda2 * (lambda2 - See) + Tee) * Xp2;

    Smm = A - Dmsq21 * Um2sq - Dmsq31 * Um3sq;
    Tmm = Tmm * (1 - Um3sq - Um2sq) + Amatter * (See + Smm - A);

    Um3sq = (lambda3 * (lambda3 - Smm) + Tmm) * Xp3;
    Um2sq = (lambda2 * (lambda2 - Smm) + Tmm) * Xp2;

    // ------------- //
    // Use NHS for J //
    // ------------- //
    Jmatter = Jmatter * Dmsq21 * Dmsq31 * (Dmsq31 - Dmsq21) * PiDlambdaInv;

    // ----------------------- //
    // Get all elements of Usq //
    // ----------------------- //
    Ue1sq = 1 - Ue3sq - Ue2sq;
    Um1sq = 1 - Um3sq - Um2sq;

    Ut3sq = 1 - Um3sq - Ue3sq;
    Ut2sq = 1 - Um2sq - Ue2sq;
    Ut1sq = 1 - Um1sq - Ue1sq;

    // ----------------------- //
    // Get the kinematic terms //
    // ----------------------- //
    Lover4E = eVsqkm_to_GeV_over4 * L / E;

    D21 = Dlambda21 * Lover4E;
    D32 = Dlambda32 * Lover4E;
      
    sinD21 = sin(D21);
    sinD31 = sin(D32 + D21);
    sinD32 = sin(D32);

    triple_sin = sinD21 * sinD31 * sinD32;

    sinsqD21_2 = 2 * sinD21 * sinD21;
    sinsqD31_2 = 2 * sinD31 * sinD31;
    sinsqD32_2 = 2 * sinD32 * sinD32;

    // ------------------------------------------------------------------- //
    // Calculate the three necessary probabilities, separating CPC and CPV //
    // ------------------------------------------------------------------- //
    Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2
            + (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2
            + (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2;
    Pme_CPV = -Jmatter * triple_sin;

    Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2
                 + Um3sq * Um1sq * sinsqD31_2
                 + Um3sq * Um2sq * sinsqD32_2);

    Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2
                 + Ue3sq * Ue1sq * sinsqD31_2
                 + Ue3sq * Ue2sq * sinsqD32_2);

    // ---------------------------- //
    // Assign all the probabilities //
    // ---------------------------- //
	(*probs_returned)[0][0] = Pee;														// Pee
	(*probs_returned)[0][1] = Pme_CPC - Pme_CPV;										// Pem
	(*probs_returned)[0][2] = 1 - Pee - (*probs_returned)[0][1];  						// Pet

	(*probs_returned)[1][0] = Pme_CPC + Pme_CPV;										// Pme
	(*probs_returned)[1][1] = Pmm;														// Pmm
	(*probs_returned)[1][2] = 1 - (*probs_returned)[1][0] - Pmm;						// Pmt

	(*probs_returned)[2][0] = 1 - Pee - (*probs_returned)[1][0];						// Pte
	(*probs_returned)[2][1] = 1 - (*probs_returned)[0][1] - Pmm;						// Ptm
	(*probs_returned)[2][2] = 1 - (*probs_returned)[0][2] - (*probs_returned)[1][2];	// Ptt
}



================================================
FILE: Benchmarks/c++/src/NuFast.cpp
================================================
#include <cmath>
#include "NuFast.h"
#include "Benchmark.h"

// Probability_Matter_LBL calculates all nine oscillation probabilities including
// the matter effect in an optimized, fast, and efficient way. The precision can
// be controlled with N_Newton. For many applications N_Newton=0 may be enough,
// but many years of DUNE or HK-LBL may require N_Newton=1. This code may be
// suitable for atmospheric neutrinos.
//
// Inputs:
//   mixing angles (usual parameterization)
//   phase (usual parameterization) make Dmsq31 positive/negative for the NO/IO
//   Delta msq's (eV^2)
//   L (km)
//   E (GeV) positive for neutrinos, negative for antineutrinos
//   rho (g/cc)
//   Ye: electron fraction, typically around 0.5
//   N_Newton: number of Newton's method iterations to do. should be zero, one, two (or higher)
// Outputs:
//   probs_returned is all nine oscillation probabilities: e.g. probs_returned[1][0] is mu->e
void Probability_Matter_LBL(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int N_Newton, double (*probs_returned)[3][3])
{
	double c13sq, sind, cosd, Jrr, Jmatter, Dmsqee, Amatter;
	double Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq;
	double A, B, C;
	double See, Tee, Smm, Tmm;
	double xmat, lambda2, lambda3, Dlambda21, Dlambda31, Dlambda32;
	double Xp2, Xp3, PiDlambdaInv, tmp;
	double Lover4E, D21, D32;
	double sinD21, sinD31, sinD32;
	double sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin;
	double Pme_CPC, Pme_CPV, Pmm, Pee;

	// --------------------------------------------------------------------- //
	// First calculate useful simple functions of the oscillation parameters //
	// --------------------------------------------------------------------- //
	c13sq = 1 - s13sq;

	// Ueisq's
	Ue2sq = c13sq * s12sq;
	Ue3sq = s13sq;

	// Umisq's, Utisq's and Jvac	 
	Um3sq = c13sq * s23sq;
	// Um2sq and Ut2sq are used here as temporary variables, will be properly defined later	 
	Ut2sq = s13sq * s12sq * s23sq;
	Um2sq = (1 - s12sq) * (1 - s23sq);

	Jrr = sqrt(Um2sq * Ut2sq);
	sind = sin(delta);
	cosd = cos(delta);

	Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd;
	Jmatter = 8 * Jrr * c13sq * sind;
	Amatter = Ye * rho * E * YerhoE2a;
	Dmsqee = Dmsq31 - s12sq * Dmsq21;

	// calculate A, B, C, See, Tee, and part of Tmm
	A = Dmsq21 + Dmsq31; // temporary variable
	See = A - Dmsq21 * Ue2sq - Dmsq31 * Ue3sq;
	Tmm = Dmsq21 * Dmsq31; // using Tmm as a temporary variable	  
	Tee = Tmm * (1 - Ue3sq - Ue2sq);
	C = Amatter * Tee;
	A = A + Amatter;

	// ---------------------------------- //
	// Get lambda3 from lambda+ of MP/DMP //
	// ---------------------------------- //
	xmat = Amatter / Dmsqee;
	tmp = 1 - xmat;
	lambda3 = Dmsq31 + 0.5 * Dmsqee * (xmat - 1 + sqrt(tmp * tmp + 4 * s13sq * xmat));

	// ---------------------------------------------------------------------------- //
	// Newton iterations to improve lambda3 arbitrarily, if needed, (B needed here) //
	// ---------------------------------------------------------------------------- //
	B = Tmm + Amatter * See; // B is only needed for N_Newton >= 1
	for (int i = 0; i < N_Newton; i++)
		lambda3 = (lambda3 * lambda3 * (lambda3 + lambda3 - A) + C) / (lambda3 * (2 * (lambda3 - A) + lambda3) + B); // this strange form prefers additions to multiplications

	// ------------------- //
	// Get  Delta lambda's //
	// ------------------- //
	tmp = A - lambda3;
	Dlambda21 = sqrt(tmp * tmp - 4 * C / lambda3);
	lambda2 = 0.5 * (A - lambda3 + Dlambda21);
	Dlambda32 = lambda3 - lambda2;
	Dlambda31 = Dlambda32 + Dlambda21;

	// ----------------------- //
	// Use Rosetta for Veisq's //
	// ----------------------- //
	// denominators	  
	PiDlambdaInv = 1 / (Dlambda31 * Dlambda32 * Dlambda21);
	Xp3 = PiDlambdaInv * Dlambda21;
	Xp2 = -PiDlambdaInv * Dlambda31;

	// numerators
	Ue3sq = (lambda3 * (lambda3 - See) + Tee) * Xp3;
	Ue2sq = (lambda2 * (lambda2 - See) + Tee) * Xp2;

	Smm = A - Dmsq21 * Um2sq - Dmsq31 * Um3sq;
	Tmm = Tmm * (1 - Um3sq - Um2sq) + Amatter * (See + Smm - A);

	Um3sq = (lambda3 * (lambda3 - Smm) + Tmm) * Xp3;
	Um2sq = (lambda2 * (lambda2 - Smm) + Tmm) * Xp2;

	// ------------- //
	// Use NHS for J //
	// ------------- //
	Jmatter = Jmatter * Dmsq21 * Dmsq31 * (Dmsq31 - Dmsq21) * PiDlambdaInv;

	// ----------------------- //
	// Get all elements of Usq //
	// ----------------------- //
	Ue1sq = 1 - Ue3sq - Ue2sq;
	Um1sq = 1 - Um3sq - Um2sq;

	Ut3sq = 1 - Um3sq - Ue3sq;
	Ut2sq = 1 - Um2sq - Ue2sq;
	Ut1sq = 1 - Um1sq - Ue1sq;

	// ----------------------- //
	// Get the kinematic terms //
	// ----------------------- //
	Lover4E = eVsqkm_to_GeV_over4 * L / E;

	D21 = Dlambda21 * Lover4E;
	D32 = Dlambda32 * Lover4E;
	  
	sinD21 = sin(D21);
	sinD31 = sin(D32 + D21);
	sinD32 = sin(D32);

	triple_sin = sinD21 * sinD31 * sinD32;

	sinsqD21_2 = 2 * sinD21 * sinD21;
	sinsqD31_2 = 2 * sinD31 * sinD31;
	sinsqD32_2 = 2 * sinD32 * sinD32;

	// ------------------------------------------------------------------- //
	// Calculate the three necessary probabilities, separating CPC and CPV //
	// ------------------------------------------------------------------- //
	Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2
			+ (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2
			+ (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2;
	Pme_CPV = -Jmatter * triple_sin;

	Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2
				 + Um3sq * Um1sq * sinsqD31_2
				 + Um3sq * Um2sq * sinsqD32_2);

	Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2
				 + Ue3sq * Ue1sq * sinsqD31_2
				 + Ue3sq * Ue2sq * sinsqD32_2);

	// ---------------------------- //
	// Assign all the probabilities //
	// ---------------------------- //
	(*probs_returned)[0][0] = Pee;														// Pee
	(*probs_returned)[0][1] = Pme_CPC - Pme_CPV;										// Pem
	(*probs_returned)[0][2] = 1 - Pee - (*probs_returned)[0][1];  						// Pet

	(*probs_returned)[1][0] = Pme_CPC + Pme_CPV;										// Pme
	(*probs_returned)[1][1] = Pmm;														// Pmm
	(*probs_returned)[1][2] = 1 - (*probs_returned)[1][0] - Pmm;						// Pmt

	(*probs_returned)[2][0] = 1 - Pee - (*probs_returned)[1][0];						// Pte
	(*probs_returned)[2][1] = 1 - (*probs_returned)[0][1] - Pmm;						// Ptm
	(*probs_returned)[2][2] = 1 - (*probs_returned)[0][2] - (*probs_returned)[1][2];	// Ptt
}

void Probability_Vacuum_LBL(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double empty1, double empty2, int empty3, double (*probs_returned)[3][3])
{
	double c13sq, sind, cosd, Jrr, Jvac;
	double Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq;
	double Lover4E, D21, D31;
	double sinD21, sinD31, sinD32;
	double sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin;
	double Pme_CPC, Pme_CPV, Pmm, Pee;

	// --------------------------------------------------------------------- //
	// First calculate useful simple functions of the oscillation parameters //
	// --------------------------------------------------------------------- //
	c13sq = 1 - s13sq;

	// Ueisq's
	Ue3sq = s13sq;
	Ue2sq = c13sq * s12sq;

	// Umisq's, Utisq's and Jvac	 
	Um3sq = c13sq * s23sq;
	// Um2sq and Ut2sq are used here as temporary variables, will be properly defined later	 
	Ut2sq = s13sq * s12sq * s23sq;
	Um2sq = (1 - s12sq) * (1 - s23sq);
	  
	Jrr = sqrt(Um2sq * Ut2sq);
	sind = sin(delta);
	cosd = cos(delta);
	Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd;
	Jvac = 8 * Jrr * c13sq * sind;
	
	// ----------------------- //
	// Get all elements of Usq //
	// ----------------------- //
	Ue1sq = 1 - Ue3sq - Ue2sq;
	Um1sq = 1 - Um3sq - Um2sq;

	Ut3sq = 1 - Um3sq - Ue3sq;
	Ut2sq = 1 - Um2sq - Ue2sq;
	Ut1sq = 1 - Um1sq - Ue1sq;

	// ----------------------- //
	// Get the kinematic terms //
	// ----------------------- //
	Lover4E = eVsqkm_to_GeV_over4 * L / E;

	D21 = Dmsq21 * Lover4E;
	D31 = Dmsq31 * Lover4E;
	  
	sinD21 = sin(D21);
	sinD31 = sin(D31);
	sinD32 = sin(D31-D21);

	triple_sin = sinD21 * sinD31 * sinD32;

	sinsqD21_2 = 2 * sinD21 * sinD21;
	sinsqD31_2 = 2 * sinD31 * sinD31;
	sinsqD32_2 = 2 * sinD32 * sinD32;

	// ------------------------------------------------------------------- //
	// Calculate the three necessary probabilities, separating CPC and CPV //
	// ------------------------------------------------------------------- //
	Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2
			+ (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2
			+ (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2;
	
	Pme_CPV = -Jvac * triple_sin;

	Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2
				 + Um3sq * Um1sq * sinsqD31_2
				 + Um3sq * Um2sq * sinsqD32_2);

	Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2
				 + Ue3sq * Ue1sq * sinsqD31_2
				 + Ue3sq * Ue2sq * sinsqD32_2);

	// ---------------------------- //
	// Assign all the probabilities //
	// ---------------------------- //
	(*probs_returned)[0][0] = Pee;														// Pee
	(*probs_returned)[0][1] = Pme_CPC - Pme_CPV;										// Pem
	(*probs_returned)[0][2] = 1 - Pee - (*probs_returned)[0][1];  						// Pet

	(*probs_returned)[1][0] = Pme_CPC + Pme_CPV;										// Pme
	(*probs_returned)[1][1] = Pmm;														// Pmm
	(*probs_returned)[1][2] = 1 - (*probs_returned)[1][0] - Pmm;						// Pmt

	(*probs_returned)[2][0] = 1 - Pee - (*probs_returned)[1][0];						// Pte
	(*probs_returned)[2][1] = 1 - (*probs_returned)[0][1] - Pmm;						// Ptm
	(*probs_returned)[2][2] = 1 - (*probs_returned)[0][2] - (*probs_returned)[1][2];	// Ptt
}



================================================
FILE: Benchmarks/c++/src/Page.cpp
================================================
#include <cmath>
#include "Page.h"
#include "Benchmark.h"

#define sq(x) ((x)*(x))
#define cube(x) ((x)*(x)*(x))

void Probability_Matter_LBL_Page(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int empty, double (*probs_returned)[3][3])
{
	double a = Ye * rho * E * YerhoE2a;

	// compute trig functions of mixing angles
	double c12sq, s12, c12, c13sq, s13, c13, c23sq, s23, c23, cd, sd;
	c12sq = 1 - s12sq;
	s12 = sqrt(s12sq);
	c12 = sqrt(c12sq);
	c13sq = 1 - s13sq;
	s13 = sqrt(s13sq);
	c13 = sqrt(c13sq);
	c23sq = 1 - s23sq;
	s23 = sqrt(s23sq);
	c23 = sqrt(c23sq);
	cd = cos(delta);
	sd = sin(delta);

	// Compute vacuum values first, independent of a, L or E
	double a0_vac, a1_vac, H_ee_tilde, Y_ee_tilde, R_H_em, I_H_em, R_Y_em, I_Y_em, PHASE;
	// Compute vacuum constants common to all flavours
	a0_vac = (Dmsq21*Dmsq21*Dmsq21 + Dmsq31*Dmsq31*Dmsq31) / 27.0 - (Dmsq21*Dmsq21 * Dmsq31 + Dmsq21 * Dmsq31*Dmsq31) / 18.0;
	a1_vac = (Dmsq21*Dmsq21 + Dmsq31*Dmsq31 - Dmsq21 * Dmsq31) / 9.0;
	H_ee_tilde = Dmsq21 * (s12*s12 * c13*c13 - 1.0 / 3.0) + Dmsq31 * (s13*s13 - 1.0 / 3.0);
	Y_ee_tilde = (Dmsq21*Dmsq21 * (s12*s12 * c13*c13 - 1.0 / 3.0) + Dmsq31*Dmsq31 * (s13*s13 - 1.0 / 3.0) + 2.0 * Dmsq21 * Dmsq31 * (c12*c12 * c13*c13 - 1.0 / 3.0)) / 3.0;

	// Compute extra mu->e constants
	R_H_em = Dmsq21 * s12 * c13 * (c12 * c23 - s12 * s23 * s13 * cd) + Dmsq31 * s13 * s23 * c13 * cd;
	I_H_em = Dmsq21 * s12*s12 * s13 * s23 * c13 * sd - Dmsq31 * s13 * s23 * c13 * sd;

	R_Y_em = (s12 * c13 * (c12 * c23 - s12 * s13 * s23 * cd) * Dmsq21*Dmsq21
			+ s13 * s23 * c13 * cd * Dmsq31*Dmsq31
			- 2.0 * c12 * c13 * (s12 * c23 + s13 * s23 * c12 * cd) * Dmsq21 * Dmsq31) / 3.0;

	I_Y_em = (s12*s12 * s13 * s23 * c13 * sd * Dmsq21*Dmsq21
			- s13 * s23 * c13 * sd * Dmsq31*Dmsq31
			+ 2.0 * s13 * s23 * c12*c12 * c13 * sd * Dmsq21 * Dmsq31) / 3.0;

	// Extra
	PHASE = 2.0 * M_PI / 3.0;

	// Compute all the matter-corrected quantities and then the transition probability
	double a0, a1, sqrt_a1, eigen[3], R_X[3], I_X[3], arcCos, L4E, Theta_10, Theta_20, Theta_21, denom;

	// Make  matter corrections (a0 and a1 have nothing to do with a)
	a /= 3.0;
	a0 = a0_vac + 1.5 * (Y_ee_tilde * a + H_ee_tilde * sq(a)) + cube(a); // a0
	a1 = a1_vac + H_ee_tilde * a + sq(a); // a1

	// Get eigenvalues of H, and constants X
	sqrt_a1 = sqrt(a1);
	arcCos = acos(a0 / (sqrt_a1 * a1)) / 3.0;
	sqrt_a1 *= 2.0;

	for (unsigned int i = 0; i < 3; ++i)
	{
		eigen[i] = sqrt_a1 * cos(arcCos - PHASE * i);
		denom = sq(eigen[i]) - a1;
		// pull out a 3 here, becomes a 9 later
		R_X[i] = ((eigen[i] + a) * R_H_em + R_Y_em) / denom;
		I_X[i] = ((eigen[i] + a) * I_H_em + I_Y_em) / denom;
	}

	// Compute Theta constants (not mixing angles)
	L4E = eVsqkm_to_GeV_over4 * L / E;
	Theta_10 = (eigen[1] - eigen[0]) * L4E;
	Theta_20 = (eigen[2] - eigen[0]) * L4E;
	Theta_21 = (eigen[2] - eigen[1]) * L4E;

	// Compute probabilities
	double Pme_CPC, Pme_CPV;
	// mu->e
	Pme_CPC = 2.0 * (- 2.0 * ((R_X[1]*R_X[0] + I_X[1]*I_X[0]) * sq(sin(Theta_10))
							+ (R_X[2]*R_X[0] + I_X[2]*I_X[0]) * sq(sin(Theta_20))
							+ (R_X[2]*R_X[1] + I_X[2]*I_X[1]) * sq(sin(Theta_21)))) / 9.0;
	Pme_CPV = 2.0 * (((I_X[1]*R_X[0] - R_X[1]*I_X[0]) * sin(2.0 * Theta_10)
							+ (I_X[2]*R_X[0] - R_X[2]*I_X[0]) * sin(2.0 * Theta_20)
							+ (I_X[2]*R_X[1] - R_X[2]*I_X[1]) * sin(2.0 * Theta_21))) / 9.0;

	// Compute the extra e->e constants
	// e->e
	double H_ee, Y_ee, X_ee[3];
	H_ee = H_ee_tilde + 2 * a; // note that "a" already has a 1/3 on it
	Y_ee = Y_ee_tilde + 2 * H_ee_tilde * a + 2 * sq(a);
	for (int i = 0; i < 3; i++)
		X_ee[i] = 1 + (eigen[i] * H_ee + Y_ee) / (sq(eigen[i]) - a1); // pull out a 3 here, becomes a 9 later
	(*probs_returned)[0][0] = 1. - 4 * (X_ee[1] * X_ee[0] * sq(sin(Theta_10))
									  + X_ee[2] * X_ee[0] * sq(sin(Theta_20))
									  + X_ee[2] * X_ee[1] * sq(sin(Theta_21))) / 9.;

	(*probs_returned)[1][0] = Pme_CPC + Pme_CPV;

	// mu->mu
	double H_mm_tilde, H_mm, Y_mm_tilde, Y_mm, X_mm[3];
	H_mm_tilde = Dmsq21 * (c12sq * c23sq + s12sq * s13sq * s23sq - 2 * s12 * s13 * s23 * c12 * c23 * cd - 1. / 3) + Dmsq31 * (s23sq * c13sq - 1. / 3);
	H_mm = H_mm_tilde - a;
	Y_mm_tilde = (sq(Dmsq21) * (c12sq * c23sq + s12sq * s13sq * s23sq - 2 * s12 * s13 * s23 * c12 * c23 * cd - 1. / 3) + sq(Dmsq31) * (s23sq * c13sq - 1. / 3) + 2 * Dmsq21 * Dmsq31 * (s12sq * c23sq + s13sq * s23sq * c12sq + 2 * s12 * s13 * s23 * c12 * c23 * cd - 1. / 3)) / 3;
	Y_mm = Y_mm_tilde - 2 * (H_ee_tilde + H_mm_tilde) * a - sq(a);
	for (int i = 0; i < 3; i++)
		X_mm[i] = 1 + (eigen[i] * H_mm + Y_mm) / (sq(eigen[i]) - a1); // pull out a 3 here, becomes a 9 later
	(*probs_returned)[1][1] = 1. - 4 * (X_mm[1] * X_mm[0] * sq(sin(Theta_10))
									  + X_mm[2] * X_mm[0] * sq(sin(Theta_20))
									  + X_mm[2] * X_mm[1] * sq(sin(Theta_21))) / 9.;


	(*probs_returned)[2][0] = 1. - (*probs_returned)[1][0] - (*probs_returned)[0][0]; // tau->e
	(*probs_returned)[0][1] = Pme_CPC - Pme_CPV; // e->mu
	(*probs_returned)[0][2] = 1. - (*probs_returned)[0][0] - (*probs_returned)[0][1]; // e->tau
	(*probs_returned)[1][2] = 1. - (*probs_returned)[1][0] - (*probs_returned)[1][1]; // mu->tau
	(*probs_returned)[2][1] = 1. - (*probs_returned)[0][1] - (*probs_returned)[1][1]; // tau->mu
	(*probs_returned)[2][2] = 1. - (*probs_returned)[2][0] - (*probs_returned)[2][1]; // tau->tau
}




================================================
FILE: Benchmarks/f/Makefile
================================================
MAKEFLAGS=--jobs=1

Compiler=gfortran

FFlags=-pedantic -Wall -Wno-unused-dummy-argument
FFlags+=-O5 -ffast-math # can improve speed by 10s of percent over the default of -O0
FFlags+=-fdefault-real-8 # set the precision of reals. commenting this out sets it to 4 (single precision: fastest and enough precision), 8 is double precision (best), 16 is quadruple precision (much slower, but fun to check)
Sources=src/Benchmark.f90 src/NuFast.f90 src/Exact_Cubic.f90
AllObjects=$(addprefix obj/,$(notdir $(Sources:.f90=.o)))
Executables=Benchmark
Objects=$(filter-out $(addprefix obj/,$(Executables:=.o)),$(AllObjects))

all: $(Sources) $(Executables)

$(Executables): $(AllObjects)
	$(Compiler) $(Objects) $(addprefix obj/,$@.o) -o $@

obj/%.o: src/%.f90
	@mkdir -p $(@D)
	$(Compiler) $< -c $(FFlags) -Jobj -o $@

clean:
	rm -rf obj/*.o obj/*.mod $(Executables)




================================================
FILE: Benchmarks/f/src/Benchmark.f90
================================================
module Parameters
    implicit none
    real, parameter :: PI = 3.14159265358979323846264338327950288419716939937510
    real, parameter :: oneThird = 1. / 3
    real, parameter :: YerhoE2a = 1.52588e-4
    real, parameter :: eVsqkm_to_GeV_over4 = 1e-9 / 1.97327e-7 * 1e3 / 4
end module Parameters

! Compute the speed n times and calculate the mean over those n times
! N_Newton is used for NuFast only, ignored otherwise
real function Speed_Helper(Probability_Calculator, n, N_Newton)
    use Parameters
    implicit none
    interface
        subroutine Probability_Calculator(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
            real, intent(in) :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye
            integer, intent(in) :: N_Newton
            real, intent(out) :: probs_returned(3, 3)
        end subroutine Probability_Calculator
    end interface
    integer, intent(in) :: n, N_Newton
    integer :: start_time, rate, end_time, i
    real :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, Emin, Emax, Estep, rho, Ye, probs_returned(3, 3)

    ! ------------------------------------- !
    ! Set the vacuum oscillation parameters !
    ! ------------------------------------- !
    s12sq = 0.31
    s13sq = 0.02
    s23sq = 0.55
    delta = -0.7 * PI
    Dmsq21 = 7.5e-5 ! eV^2
    Dmsq31 = 2.5e-3 ! eV^2

    ! ------------------------------- !
    ! Set the experimental parameters !
    ! ------------------------------- !
    L = 1300 ! km
    Emin = 0.5 ! GeV
    Emax = 5
    Estep = (Emax - Emin) / real(n)
    rho = 3 ! g/cc
    Ye = 0.5

    call system_clock(start_time, rate)
    do i = 1, n
        E = Emin + (i - 1) * Estep
        call Probability_Calculator(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
    end do ! i n
    call system_clock(end_time)
    Speed_Helper = real(end_time - start_time) / real(rate) / n
end function Speed_Helper

! Compute the speed many times and calculate the mean and standard deviation
! m is outer loop, n, is inner loop
! N_Newton is used for NuFast only, ignored otherwise
subroutine Speed(Probability_Calculator, m, n, N_Newton, mean, std)
    implicit none
    interface
        subroutine Probability_Calculator(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
            real, intent(in) :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, Ye, rho
            integer, intent(in) :: N_Newton
            real, intent(out) :: probs_returned(3, 3)
        end subroutine Probability_Calculator
    end interface
    integer, intent(in) :: m, n, N_Newton
    real, intent(out) :: mean, std
    real, external :: Speed_Helper
    real :: s, speed_sum, speedsq_sum
    integer :: i

    speed_sum = 0
    speedsq_sum = 0
    do i = 1, m
        s = Speed_Helper(Probability_Calculator, n, N_Newton) * 1e9 ! in ns
        speed_sum = speed_sum + s
        speedsq_sum = speedsq_sum + s * s
    end do ! i, m
    mean = speed_sum / m
    std = sqrt(speedsq_sum / m - mean * mean)
end subroutine Speed

! The main program
! Computes the 9 oscillation probabilities for some
! oscillation parameters at some level of precision
! and prints them
program Benchmark
    use Parameters
    implicit none
    external :: Probability_Matter_LBL, Probability_Matter_LBL_Exact_Cubic, Probability_Vacuum_LBL, Speed
    real :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, Ye, rho, Emin, Emax, Estep
    real :: probs_returned(3, 3), probs_returned_Exact_Cubic(3, 3)
    real :: mean, std
    integer :: N_Newton, i, alpha, beta, m, n, dataf

    ! ------------------------------------- !
    ! Set the vacuum oscillation parameters !
    ! ------------------------------------- !
    s12sq = 0.31
    s13sq = 0.02
    s23sq = 0.55
    delta = -0.7 * PI
    Dmsq21 = 7.5e-5  ! eV^2
    Dmsq31 = +2.5e-3 ! eV^2

    ! ------------------------------- !
    ! Set the experimental parameters !
    ! ------------------------------- !
    L = 1300 ! km
    E = 2.5 ! GeV
    rho = 3 ! g/cc
    Ye = 0.5

    N_Newton = 0 ! <-- Sets the precision. 0 is close to the single precision limit and is better than DUNE/HK in the high statistics regime. Increasig N_Newton improves the precision at a modest computational cost

    ! ------------------------------------------ !
    ! Calculate all 9 oscillations probabilities !
    ! ------------------------------------------ !
    call Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
    call Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &
                                            probs_returned_Exact_Cubic)

    ! ------------------------------- !
    ! Print out the fractional errors !
    ! ------------------------------- !
    write (*,"(A,F8.1,A,F5.2,A,F5.2,A,F5.2,A,I1)") "L = ", L, " E = ", E, " rho = ", rho, " Ye = ", Ye, " N_Newton = ", N_Newton
    write (*,"(A,I1,A)") "Precision (N_Newton = ", N_Newton, "):"
    write (*,"(A6,A5,A10)") "alpha", "beta", "DeltaP/P"
    do alpha = 1, 3
        do beta = 1, 3
            write (*,"(I6,I5,E10.2)") alpha, beta, &
                ABS(probs_returned(alpha, beta) - probs_returned_Exact_Cubic(alpha, beta)) / probs_returned_Exact_Cubic(alpha, beta)
        end do ! beta, 1, 3
    end do ! alpha, 1, 3

    ! ----------------------------------- !
    ! Write the fractional errors to file !
    ! ----------------------------------- !
    n = 1e3
    ! DUNE !
    Emin = 0.5
    Emax = 5
    Estep = (Emax - Emin) / n
    open (newunit = dataf, file = "data/Precision_DUNE.txt", status = "replace", action = "write")
    write (dataf, *) L, rho, Ye
    do i = 0, n
        E = Emin + i * Estep
        call Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
        call Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &
                                                probs_returned_Exact_Cubic)
        write (dataf, *) E, ABS(probs_returned(2, 2) - probs_returned_Exact_Cubic(2, 2)) / probs_returned_Exact_Cubic(2, 2), &
                 ABS(probs_returned(2, 1) - probs_returned_Exact_Cubic(2, 1)) / probs_returned_Exact_Cubic(2, 1)
    end do ! i
    close (dataf)

    ! HK !
    L = 295
    Emin = 0.1
    Emax = 2
    Estep = (Emax - Emin) / n
    open (newunit = dataf, file = "data/Precision_HK.txt", status = "replace", action = "write")
    write (dataf, *) L, rho, Ye
    do i = 0, n
        E = Emin + i * Estep
        call Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
        call Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, 0, &
                                                probs_returned_Exact_Cubic)
        write (dataf, *) E, ABS(probs_returned(2, 2) - probs_returned_Exact_Cubic(2, 2)) / probs_returned_Exact_Cubic(2, 2), &
                 ABS(probs_returned(2, 1) - probs_returned_Exact_Cubic(2, 1)) / probs_returned_Exact_Cubic(2, 1)
    end do ! i
    close (dataf)

    ! JUNO !
    L = 50
    rho = 2.6
    Emin = 1e-3
    Emax = 10e-3
    Estep = (Emax - Emin) / n
    open (newunit = dataf, file = "data/Precision_JUNO.txt", status = "replace", action = "write")
    write (dataf, *) L, rho, Ye, N_Newton
    do i = 0, n
        E = Emin + i * Estep
        call Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, -E, rho, Ye, N_Newton, probs_returned)
        call Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, -E, rho, Ye, 0, &
                                                probs_returned_Exact_Cubic)
        write (dataf, *) E, ABS(probs_returned(1, 1) - probs_returned_Exact_Cubic(1, 1)) / probs_returned_Exact_Cubic(1, 1)
    end do ! i
    close (dataf)

    ! ---------- !
    ! Speed test !
    ! ---------- !
    open (newunit = dataf, file = "data/Speed.txt", status = "replace", action = "write")
    m = int(1e3)
    n = int(1e6)

    write (*,*) ""
    write (*,*) "Speed (this takes a moment):"

    ! Vacuum probability
    write (*,"(A)") "Vacuum (1/6)"
    call Speed(Probability_Vacuum_LBL, m, n, 0, mean, std)
    write (*,"(F7.1,A,F7.1,A)") mean, " +- ", std, " ns"
    write (dataf,"(A,F7.1,A,F7.1,A)") "Vacuum", mean, " +- ", std, " ns"

    ! NuFast at various N_Newton levels
    do N_Newton = 0, 3
        write (*,"(A,I2,A,I1,A)") "N_Newton =", N_Newton, " (", N_Newton + 2, "/6)"
        call Speed(Probability_Matter_LBL, m, n, N_Newton, mean, std)
        write (*,"(F7.1,A,F7.1,A)") mean, " +- ", std, " ns"
        write (dataf,"(A,I1,F7.1,A,F7.1,A)") "N_Newton=", N_Newton, mean, " +- ", std, " ns"
    end do ! N_Newton, 0, 3

    ! Exact with cubic from Cardano/ZS
    write (*,"(A)") "Exact_Cubic (6/6)"
    call Speed(Probability_Matter_LBL_Exact_Cubic, m, n, 0, mean, std)
    write (*,"(F7.1,A,F7.1,A)") mean, " +- ", std, " ns"
    write (dataf,"(A,F7.1,A,F7.1,A)") "Exact_Cubic", mean, " +- ", std, " ns"
    close (dataf)
end program Benchmark



================================================
FILE: Benchmarks/f/src/Exact_Cubic.f90
================================================
subroutine Probability_Matter_LBL_Exact_Cubic(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, empty, probs_returned)
    use Parameters
    implicit none
    real, intent(in) :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye
    integer, intent(in) :: empty
    real, intent(out) :: probs_returned(3, 3)

    real :: Amatter, c13sq, sind, cosd

    real :: A, B, C, S
    real :: See, Smm, Tee, Tmm, rootAsqm3B
    real :: lambda2, lambda3, Dlambda21, Dlambda31, Dlambda32
    real :: Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq

    real :: sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin, PiDlambdaInv, Xp2, Xp3
    real :: D21, D32
    real :: sinD21, sinD31, sinD32
    real :: Lover4E, Jrr, Jmatter
    real :: Pee, Pme_CPC, Pme_CPV, Pmm


    ! --------------------------------------------------------------------- !
    ! First calculate useful simple functions of the oscillation parameters !
    ! --------------------------------------------------------------------- !
    c13sq = 1 - s13sq

    ! Ueisq's
    Ue2sq = c13sq * s12sq
    Ue3sq = s13sq

    ! Umisq's, Utisq's and Jvac     
    Um3sq = c13sq * s23sq
    ! Um2sq and Ut2sq are used here as temporary variables, will be properly defined later     
    Ut2sq = s13sq * s12sq * s23sq
    Um2sq = (1 - s12sq) * (1 - s23sq)
      
    Jrr = sqrt(Um2sq * Ut2sq)
    sind = sin(delta)
    cosd = cos(delta)

    Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd
    Jmatter = 8 * Jrr * c13sq * sind
    Amatter = Ye * rho * E * YerhoE2a ! assume Ye = 0.5

    ! calculate A, B, C, See, Tee, and part of Tmm
    A = Dmsq21 + Dmsq31 ! temporary variable
    See = A - Dmsq21 * Ue2sq - Dmsq31 * Ue3sq
    Tmm = Dmsq21 * Dmsq31 ! using Tmm as a temporary variable      
    Tee = Tmm * (1 - Ue3sq - Ue2sq)
    C = Amatter * Tee
    A = A + Amatter

    ! -------------------------------- !
    ! Get exact lambda3 from the cubic !
    ! -------------------------------- !
    B = Tmm + Amatter * See
    rootAsqm3B = sqrt(A * A - 3 * B)
    S = acos((A * A * A - 4.5 * A* B + 13.5 * C) / (rootAsqm3B * rootAsqm3B * rootAsqm3B))
    if (Dmsq31.LT.0) then
        S = S + 2 * PI ! adjust lambda3 for the IO
    endif
    lambda3 = (A + 2 * rootAsqm3B * cos(S * oneThird)) * oneThird

    ! ------------------- !
    ! Get  Delta lambda's !
    ! ------------------- !
    Dlambda21 = sqrt((A - lambda3) ** 2 - 4 * C / lambda3)
    lambda2 = 0.5 * (A - lambda3 + Dlambda21)
    Dlambda32 = lambda3 - lambda2
    Dlambda31 = Dlambda32 + Dlambda21

    ! ----------------------- !
    ! Use Rosetta for Ueisq's !
    ! ----------------------- !
    ! denominators      
    PiDlambdaInv = 1 / (Dlambda31 * Dlambda32 * Dlambda21)
    Xp3 = PiDlambdaInv * Dlambda21
    Xp2 = -PiDlambdaInv * Dlambda31

    ! numerators
    Ue3sq = (lambda3 * (lambda3 - See) + Tee) * Xp3
    Ue2sq = (lambda2 * (lambda2 - See) + Tee) * Xp2

    Smm = A - Dmsq21 * Um2sq - Dmsq31 * Um3sq
    Tmm = Tmm * (1 - Um3sq - Um2sq) + Amatter * (See + Smm - A)

    Um3sq = (lambda3 * (lambda3 - Smm) + Tmm) * Xp3
    Um2sq = (lambda2 * (lambda2 - Smm) + Tmm) * Xp2

    ! ------------- !
    ! Use NHS for J !
    ! ------------- !
    Jmatter = Jmatter * Dmsq21 * Dmsq31 * (Dmsq31 - Dmsq21) * PiDlambdaInv

    ! ----------------------- !
    ! Get all elements of Usq !
    ! ----------------------- !
    Ue1sq = 1 - Ue3sq - Ue2sq
    Um1sq = 1 - Um3sq - Um2sq

    Ut3sq = 1 - Um3sq - Ue3sq
    Ut2sq = 1 - Um2sq - Ue2sq
    Ut1sq = 1 - Um1sq - Ue1sq

    ! ----------------------- !
    ! Get the kinematic terms !
    ! ----------------------- !
    Lover4E = eVsqkm_to_GeV_over4 * L / E

    D21 = Dlambda21 * Lover4E
    D32 = Dlambda32 * Lover4E
      
    sinD21 = sin(D21)
    sinD31 = sin(D32 + D21)
    sinD32 = sin(D32)

    triple_sin = sinD21 * sinD31 * sinD32

    sinsqD21_2 = 2 * sinD21 * sinD21
    sinsqD31_2 = 2 * sinD31 * sinD31
    sinsqD32_2 = 2 * sinD32 * sinD32

    ! ------------------------------------------------------------------- !
    ! Calculate the three necessary probabilities, separating CPC and CPV !
    ! ------------------------------------------------------------------- !
    Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2 &
            + (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2 &
            + (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2
    Pme_CPV = -Jmatter * triple_sin

    Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2 &
                 + Um3sq * Um1sq * sinsqD31_2 &
                 + Um3sq * Um2sq * sinsqD32_2)

    Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2 &
                 + Ue3sq * Ue1sq * sinsqD31_2 &
                 + Ue3sq * Ue2sq * sinsqD32_2)

    ! ---------------------------- !
    ! Assign all the probabilities !
    ! ---------------------------- !
    probs_returned(1, 1) = Pee                              ! Pee
    probs_returned(1, 2) = Pme_CPC - Pme_CPV                ! Pem
    probs_returned(1, 3) = 1 - Pee - probs_returned(1, 2)   ! Pet

    probs_returned(2, 1) = Pme_CPC + Pme_CPV                ! Pme
    probs_returned(2, 2) = Pmm                              ! Pmm
    probs_returned(2, 3) = 1 - probs_returned(2, 1) - Pmm   ! Pmt

    probs_returned(3, 1) = 1 - Pee - probs_returned(2, 1)
    probs_returned(3, 2) = 1 - probs_returned(1, 2) - Pmm
    probs_returned(3, 3) = 1 - probs_returned(1, 3) - probs_returned(2, 3)
end subroutine Probability_Matter_LBL_Exact_Cubic



================================================
FILE: Benchmarks/f/src/NuFast.f90
================================================
! Probability_Matter_LBL calculates all nine oscillation probabilities including
! the matter effect in an optimized, fast, and efficient way. The precision can
! be controlled with N_Newton. For many applications N_Newton=0 may be enough,
! but many years of DUNE or HK-LBL may require N_Newton=1. This code may be
! suitable for atmospheric neutrinos. The code is standalone with the Parameters
! module for several constants.
!
! Inputs:
!   mixing angles (usual parameterization)
!   phase (usual parameterization) make Dmsq31 positive/negative for the NO/IO
!   Delta msq's (eV^2)
!   L (km)
!   E (GeV) positive for neutrinos, negative for antineutrinos
!   rho (g/cc)
!   Ye: electron fraction, typically around 0.5
!   N_Newton: number of Newton's method iterations to do. should be zero, one, two (or higher)
! Outputs:
!   probs_returned is all nine oscillation probabilities: e.g. probs_returned(2,1) is mu->e
subroutine Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
    use Parameters
    implicit none
    real, intent(in) :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye
    integer, intent(in) :: N_Newton
    real, intent(out) :: probs_returned(3, 3)

    real :: c13sq, sind, cosd, Jrr, Jmatter, Dmsqee, Amatter
    real :: Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq
    real :: A, B, C
    real :: See, Tee, Smm, Tmm
    real :: xmat, lambda2, lambda3, Dlambda21, Dlambda31, Dlambda32
    real :: Xp2, Xp3, PiDlambdaInv
    real :: Lover4E, D21, D32
    real :: sinD21, sinD31, sinD32
    real :: sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin
    real :: Pme_CPC, Pme_CPV, Pmm, Pee
    integer :: i

    ! --------------------------------------------------------------------- !
    ! First calculate useful simple functions of the oscillation parameters !
    ! --------------------------------------------------------------------- !
    c13sq = 1 - s13sq

    ! Ueisq's
    Ue2sq = c13sq * s12sq
    Ue3sq = s13sq

    ! Umisq's, Utisq's and Jvac     
    Um3sq = c13sq * s23sq
    ! Um2sq and Ut2sq are used here as temporary variables, will be properly defined later     
    Ut2sq = s13sq * s12sq * s23sq
    Um2sq = (1 - s12sq) * (1 - s23sq)
      
    Jrr = sqrt(Um2sq * Ut2sq)
    sind = sin(delta)
    cosd = cos(delta)

    Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd
    Jmatter = 8 * Jrr * c13sq * sind
    Amatter = Ye * rho * E * YerhoE2a
    Dmsqee = Dmsq31 - s12sq * Dmsq21

    ! calculate A, B, C, See, Tee, and part of Tmm
    A = Dmsq21 + Dmsq31 ! temporary variable
    See = A - Dmsq21 * Ue2sq - Dmsq31 * Ue3sq
    Tmm = Dmsq21 * Dmsq31 ! using Tmm as a temporary variable      
    Tee = Tmm * (1 - Ue3sq - Ue2sq)
    C = Amatter * Tee
    A = A + Amatter

    ! ---------------------------------- !
    ! Get lambda3 from lambda+ of MP/DMP !
    ! ---------------------------------- !
    xmat = Amatter / Dmsqee
    lambda3 = Dmsq31 + 0.5 * Dmsqee * (xmat - 1 + sqrt((1 - xmat) ** 2 + 4 * s13sq * xmat))

    ! ---------------------------------------------------------------------------- !
    ! Newton iterations to improve lambda3 arbitrarily, if needed, (B needed here) !
    ! ---------------------------------------------------------------------------- !
    B = Tmm + Amatter * See ! B is only needed for N_Newton >= 1
    do i = 1, N_Newton
        lambda3 = (lambda3 * lambda3 * (lambda3 + lambda3 - A) + C) / (lambda3 * (2 * (lambda3 - A) + lambda3) + B) ! this strange form prefers additions to multiplications
    enddo ! i, 1, N_Newton

    ! ------------------- !
    ! Get  Delta lambda's !
    ! ------------------- !
    Dlambda21 = sqrt((A - lambda3) ** 2 - 4 * C / lambda3)
    lambda2 = 0.5 * (A - lambda3 + Dlambda21)
    Dlambda32 = lambda3 - lambda2
    Dlambda31 = Dlambda32 + Dlambda21

    ! ----------------------- !
    ! Use Rosetta for Ueisq's !
    ! ----------------------- !
    ! denominators      
    PiDlambdaInv = 1 / (Dlambda31 * Dlambda32 * Dlambda21)
    Xp3 = PiDlambdaInv * Dlambda21
    Xp2 = -PiDlambdaInv * Dlambda31

    ! numerators
    Ue3sq = (lambda3 * (lambda3 - See) + Tee) * Xp3
    Ue2sq = (lambda2 * (lambda2 - See) + Tee) * Xp2

    Smm = A - Dmsq21 * Um2sq - Dmsq31 * Um3sq
    Tmm = Tmm * (1 - Um3sq - Um2sq) + Amatter * (See + Smm - A)

    Um3sq = (lambda3 * (lambda3 - Smm) + Tmm) * Xp3
    Um2sq = (lambda2 * (lambda2 - Smm) + Tmm) * Xp2

    ! ------------- !
    ! Use NHS for J !
    ! ------------- !
    Jmatter = Jmatter * Dmsq21 * Dmsq31 * (Dmsq31 - Dmsq21) * PiDlambdaInv

    ! ----------------------- !
    ! Get all elements of Usq !
    ! ----------------------- !
    Ue1sq = 1 - Ue3sq - Ue2sq
    Um1sq = 1 - Um3sq - Um2sq

    Ut3sq = 1 - Um3sq - Ue3sq
    Ut2sq = 1 - Um2sq - Ue2sq
    Ut1sq = 1 - Um1sq - Ue1sq

    ! ----------------------- !
    ! Get the kinematic terms !
    ! ----------------------- !
    Lover4E = eVsqkm_to_GeV_over4 * L / E

    D21 = Dlambda21 * Lover4E
    D32 = Dlambda32 * Lover4E
      
    sinD21 = sin(D21)
    sinD31 = sin(D32 + D21)
    sinD32 = sin(D32)

    triple_sin = sinD21 * sinD31 * sinD32

    sinsqD21_2 = 2 * sinD21 * sinD21
    sinsqD31_2 = 2 * sinD31 * sinD31
    sinsqD32_2 = 2 * sinD32 * sinD32

    ! ------------------------------------------------------------------- !
    ! Calculate the three necessary probabilities, separating CPC and CPV !
    ! ------------------------------------------------------------------- !
    Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2 &
            + (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2 &
            + (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2
    Pme_CPV = -Jmatter * triple_sin

    Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2 &
                 + Um3sq * Um1sq * sinsqD31_2 &
                 + Um3sq * Um2sq * sinsqD32_2)

    Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2 &
                 + Ue3sq * Ue1sq * sinsqD31_2 &
                 + Ue3sq * Ue2sq * sinsqD32_2)

    ! ---------------------------- !
    ! Assign all the probabilities !
    ! ---------------------------- !
    probs_returned(1, 1) = Pee                                             ! Pee
    probs_returned(1, 2) = Pme_CPC - Pme_CPV                               ! Pem
    probs_returned(1, 3) = 1 - Pee - probs_returned(1, 2)                  ! Pet

    probs_returned(2, 1) = Pme_CPC + Pme_CPV                               ! Pme
    probs_returned(2, 2) = Pmm                                             ! Pmm
    probs_returned(2, 3) = 1 - probs_returned(2, 1) - Pmm                  ! Pmt

    probs_returned(3, 1) = 1 - Pee - probs_returned(2, 1)                  ! Pte
    probs_returned(3, 2) = 1 - probs_returned(1, 2) - Pmm                  ! Ptm
    probs_returned(3, 3) = 1 - probs_returned(1, 3) - probs_returned(2, 3) ! Ptt
end subroutine Probability_Matter_LBL

subroutine Probability_Vacuum_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, empty1, empty2, empty3, probs_returned)
    use Parameters
    implicit none
    real, intent(in) :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, empty1, empty2
    integer, intent(in) :: empty3
    real, intent(out) :: probs_returned(3, 3)

    real :: c13sq, sind, cosd, Jrr, Jvac
    real :: Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq
    real :: Lover4E, D21, D31
    real :: sinD21, sinD31, sinD32
    real :: sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin
    real :: Pme_CPC, Pme_CPV, Pmm, Pee

    ! --------------------------------------------------------------------- !
    ! First calculate useful simple functions of the oscillation parameters !
    ! --------------------------------------------------------------------- !
    c13sq = 1 - s13sq

    ! Ueisq's
    Ue3sq = s13sq
    Ue2sq = c13sq * s12sq

    ! Umisq's, Utisq's and Jvac     
    Um3sq = c13sq * s23sq
    ! Um2sq and Ut2sq are used here as temporary variables, will be properly defined later     
    Ut2sq = s13sq * s12sq * s23sq
    Um2sq = (1 - s12sq) * (1 - s23sq)
      
    Jrr = sqrt(Um2sq * Ut2sq)
    sind = sin(delta)
    cosd = cos(delta)
    Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd
    Jvac = 8 * Jrr * c13sq * sind
    
    ! ----------------------- !
    ! Get all elements of Usq !
    ! ----------------------- !
    Ue1sq = 1 - Ue3sq - Ue2sq
    Um1sq = 1 - Um3sq - Um2sq

    Ut3sq = 1 - Um3sq - Ue3sq
    Ut2sq = 1 - Um2sq - Ue2sq
    Ut1sq = 1 - Um1sq - Ue1sq

    ! ----------------------- !
    ! Get the kinematic terms !
    ! ----------------------- !
    Lover4E = eVsqkm_to_GeV_over4 * L / E

    D21 = Dmsq21 * Lover4E
    D31 = Dmsq31 * Lover4E
      
    sinD21 = sin(D21)
    sinD31 = sin(D31)
    sinD32 = sin(D31-D21)

    triple_sin = sinD21 * sinD31 * sinD32

    sinsqD21_2 = 2 * sinD21 * sinD21
    sinsqD31_2 = 2 * sinD31 * sinD31
    sinsqD32_2 = 2 * sinD32 * sinD32

    ! ------------------------------------------------------------------- !
    ! Calculate the three necessary probabilities, separating CPC and CPV !
    ! ------------------------------------------------------------------- !
    Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2 &
            + (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2 &
            + (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2
    
    Pme_CPV = -Jvac * triple_sin

    Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2 &
                 + Um3sq * Um1sq * sinsqD31_2 &
                 + Um3sq * Um2sq * sinsqD32_2)

    Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2 &
                 + Ue3sq * Ue1sq * sinsqD31_2 &
                 + Ue3sq * Ue2sq * sinsqD32_2)

    ! ---------------------------- !
    ! Assign all the probabilities !
    ! ---------------------------- !
    probs_returned(1, 1) = Pee                              ! Pee
    probs_returned(1, 2) = Pme_CPC - Pme_CPV                ! Pem
    probs_returned(1, 3) = 1 - Pee - probs_returned(1, 2)   ! Pet

    probs_returned(2, 1) = Pme_CPC + Pme_CPV                ! Pme
    probs_returned(2, 2) = Pmm                              ! Pmm
    probs_returned(2, 3) = 1 - probs_returned(2, 1) - Pmm   ! Pmt

    probs_returned(3, 1) = 1 - Pee - probs_returned(2, 1)
    probs_returned(3, 2) = 1 - probs_returned(1, 2) - Pmm
    probs_returned(3, 3) = 1 - probs_returned(1, 3) - probs_returned(2, 3)
end subroutine Probability_Vacuum_LBL





================================================
FILE: Benchmarks/globes/Makefile
================================================
CXX=gcc

OMPFlags=-fopenmp

CFlags=-c -Wall -MMD -std=c99
CFlags+=-O5 -ffast-math # can improve speed
CFlags+=$(OMPFlags)

GSLFlags=-lgsl -lgslcblas -lm

Sources=$(wildcard src/*.c)
IncludeDir=-I./include
AllObjects=$(addprefix obj/,$(notdir $(Sources:.c=.o)))
Executables=main
Objects=$(filter-out $(addprefix obj/,$(Executables:=.o)),$(AllObjects))

all: $(Sources) $(Executables)

$(Executables): $(AllObjects)
	@mkdir -p data obj
	$(CXX) $(Objects) $(addprefix obj/,$@.o) $(GSLFlags) $(OMPFlags) -o $@

obj/%.o: src/%.c
	@mkdir -p $(@D)
	$(CXX) $(CFlags) $(IncludeDir) $< -o $@

-include $(AllObjects:.o=.d)

clean:
	rm -rf obj/*.o obj/*.d $(Executables)




================================================
FILE: Benchmarks/globes/include/glb_error.h
================================================
/* GLoBES -- General LOng Baseline Experiment Simulator
 * (C) 2002 - 2007,  The GLoBES Team
 *
 * GLoBES is mainly intended for academic purposes. Proper
 * credit must be given if you use GLoBES or parts of it. Please
 * read the section 'Credit' in the README file.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#ifndef GLB_ERROR_H
#define GLB_ERROR_H 1

#include <stdlib.h>

extern void *glb_malloc (size_t size);
extern void glb_free(void *ptr);

#endif /* !GLB_ERROR_H */



================================================
FILE: Benchmarks/globes/include/glb_probability.h
================================================
/* GLoBES -- General LOng Baseline Experiment Simulator
 * (C) 2002 - 2007,  The GLoBES Team
 *
 * GLoBES is mainly intended for academic purposes. Proper
 * credit must be given if you use GLoBES or parts of it. Please
 * read the section 'Credit' in the README file.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#ifndef GLB_OSZPROB_H
#define GLB_OSZPROB_H 1

#include <complex.h>

typedef struct osc_params_angles_type {double theta12, theta13, theta23, delta, dms, dma;} osc_params_angles;

/* User-defined glb_probability_matrix and glb_set/get_oscillation_parameters */
typedef int (*glb_probability_matrix_function)(double P[3][3], int cp_sign, double E,
                  const double *length, const double *density);
typedef int (*glb_set_oscillation_parameters_function)(osc_params_angles p);
typedef int (*glb_get_oscillation_parameters_function)(osc_params_angles p);

#define GLB_V_FACTOR 7.63247e-14   /* Conversion factor for matter potentials */

#define GLB_Ne_MANTLE       0.5        /* Effective electron numbers for calculation */
                                                      /* which vacuum algorithms are used   */
#define M_SQRT3  1.73205080756887729352744634151      /* sqrt(3) */

/* Macros */
#define SQR(x)      ((x)*(x))                        /* x^2   */
#define SQR_ABS(x)  (SQR(creal(x)) + SQR(cimag(x)))  /* |x|^2 */

/* Functions */
int glb_init_probability_engine();
int glb_free_probability_engine();
int glb_set_oscillation_parameters(osc_params_angles opa);
int glb_get_oscillation_parameters(osc_params_angles opa);
int glb_hamiltonian_cd(double E, double V, int cp_sign);
int glb_S_matrix_cd(double E, double L, double V, int cp_sign);
int glb_probability_matrix(double P[3][3], int cp_sign, double E,
    const double *length, const double *density);

#endif /* GLB_OSZPROB_H */





================================================
FILE: Benchmarks/globes/include/Parameters.h
================================================
#ifndef Parameters_H
#define Parameters_H

struct osc_params_sinsq {double s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31;};
struct osc_params_angle {double theta12, theta13, theta23, delta, Dmsq21, Dmsq31;};

#endif



================================================
FILE: Benchmarks/globes/src/glb_error.c
================================================
/* GLoBES -- General LOng Baseline Experiment Simulator
 * (C) 2002 - 2007,  The GLoBES Team
 *
 * GLoBES is mainly intended for academic purposes. Proper
 * credit must be given if you use GLoBES or parts of it. Please
 * read the section 'Credit' in the README file.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

//The principles used in this file are taken from the autotools book by
//Gary V. Vaughan.

#include "glb_error.h"

/* ----- making the system calls safe ----- */
void *glb_malloc (size_t size)
{
  register void *value = malloc (size);
  return value;
}

void glb_free(void *ptr)
{
  if (ptr != NULL)
  {
    free(ptr);
    ptr=NULL;   // FIXME This has no effect
  }
}




================================================
FILE: Benchmarks/globes/src/glb_probability.c
================================================
/* GLoBES -- General LOng Baseline Experiment Simulator
 * (C) 2002 - 2007,  The GLoBES Team
 *
 * GLoBES is mainly intended for academic purposes. Proper
 * credit must be given if you use GLoBES or parts of it. Please
 * read the section 'Credit' in the README file.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <float.h>
#include <math.h>
#include <complex.h>
#include <gsl/gsl_complex.h>
#include <gsl/gsl_complex_math.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_blas.h>
#include "glb_probability.h"

/* PH 01/11/19 */

#include <string.h>

// from globes/globes.h
#define GLB_NU_FLAVOURS  3
#define GLB_EV_TO_KM_FACTOR 1.97327e-10
#define GLB_KM_TO_EV(x)      ((x) / GLB_EV_TO_KM_FACTOR)


/* Fundamental oscillation parameters */
static double th12, th13, th23; // Mixing angles
static double delta;            // Dirac CP phase
static double mq[3];            // Squared masses

/* Internal temporary variables */
gsl_matrix_complex *U=NULL; /* The vacuum mixing matrix                           */
gsl_matrix_complex *H=NULL; /* Neutrino Hamiltonian                               */
gsl_matrix_complex *Q=NULL; /* Eigenvectors of Hamiltonian (= eff. mixing matrix) */
gsl_vector *lambda=NULL;    /* Eigenvalues of Hamiltonian                         */
gsl_matrix_complex *S=NULL; /* The neutrino S-matrix                              */

gsl_matrix_complex *H0_template=NULL;  /* Used in the construction of the vac. Hamiltonian */
gsl_matrix_complex *S1=NULL, *T0=NULL; /* Temporary matrix storage                         */


/* PH 01/10/19 
 * Here comes the stuff to name an oscillation engine and
 * to retrieve it by its name 
 */

/***************************************************************************
 *            3 x 3   E I G E N S Y S T E M   F U N C T I O N S            *
 ***************************************************************************
 * These functions are taken from physics/0610206.                         *
 ***************************************************************************/

// ----------------------------------------------------------------------------
//JK 2008-08-09 Temporary workaround for bug #22
//inline void zhetrd3(double complex A[3][3], double complex Q[3][3],
//                    double d[3], double e[2])
void zhetrd3(double complex A[3][3], double complex Q[3][3],
             double d[3], double e[2])
// ----------------------------------------------------------------------------
// Reduces a hermitian 3x3 matrix to real tridiagonal form by applying
// (unitary) Householder transformations:
//            [ d[0]  e[0]       ]
//    A = Q . [ e[0]  d[1]  e[1] ] . Q^T
//            [       e[1]  d[2] ]
// The function accesses only the diagonal and upper triangular parts of
// A. The access is read-only.
// ---------------------------------------------------------------------------
{
  const int n = 3;
  double complex u[n], q[n];
  double complex omega, f;
  double K, h, g;

  // Initialize Q to the identitity matrix
#ifndef EVALS_ONLY
  for (int i=0; i < n; i++)
  {
    Q[i][i] = 1.0;
    for (int j=0; j < i; j++)
      Q[i][j] = Q[j][i] = 0.0;
  }
#endif

  // Bring first row and column to the desired form
  h = SQR_ABS(A[0][1]) + SQR_ABS(A[0][2]);
  if (creal(A[0][1]) > 0)
    g = -sqrt(h);
  else
    g = sqrt(h);
  e[0] = g;
  f    = g * A[0][1];
  u[1] = conj(A[0][1]) - g;
  u[2] = conj(A[0][2]);

  omega = h - f;
  if (creal(omega) > 0.0)
  {
    omega = 0.5 * (1.0 + conj(omega)/omega) / creal(omega);
    K = 0.0;
    for (int i=1; i < n; i++)
    {
      f    = conj(A[1][i]) * u[1] + A[i][2] * u[2];
      q[i] = omega * f;                  // p
      K   += creal(conj(u[i]) * f);      // u* A u
    }
    K *= 0.5 * SQR_ABS(omega);

    for (int i=1; i < n; i++)
      q[i] = q[i] - K * u[i];

    d[0] = creal(A[0][0]);
    d[1] = creal(A[1][1]) - 2.0*creal(q[1]*conj(u[1]));
    d[2] = creal(A[2][2]) - 2.0*creal(q[2]*conj(u[2]));

    // Store inverse Householder transformation in Q
#ifndef EVALS_ONLY
    for (int j=1; j < n; j++)
    {
      f = omega * conj(u[j]);
      for (int i=1; i < n; i++)
        Q[i][j] = Q[i][j] - f*u[i];
    }
#endif

    // Calculate updated A[1][2] and store it in f
    f = A[1][2] - q[1]*conj(u[2]) - u[1]*conj(q[2]);
  }
  else
  {
    for (int i=0; i < n; i++)
      d[i] = creal(A[i][i]);
    f = A[1][2];
  }

  // Make (23) element real
  e[1] = cabs(f);
#ifndef EVALS_ONLY
  if (e[1] != 0.0)
  {
    f = conj(f) / e[1];
    for (int i=1; i < n; i++)
      Q[i][n-1] = Q[i][n-1] * f;
  }
#endif
}


// ----------------------------------------------------------------------------
int zheevc3(double complex A[3][3], double w[3])
// ----------------------------------------------------------------------------
// Calculates the eigenvalues of a hermitian 3x3 matrix A using Cardano's
// analytical algorithm.
// Only the diagonal and upper triangular parts of A are accessed. The access
// is read-only.
// ----------------------------------------------------------------------------
// Parameters:
//   A: The hermitian input matrix
//   w: Storage buffer for eigenvalues
// ----------------------------------------------------------------------------
// Return value:
//   0: Success
//  -1: Error
// ----------------------------------------------------------------------------
{
  double m, c1, c0;

  // Determine coefficients of characteristic poynomial. We write
  //       | a   d   f  |
  //  A =  | d*  b   e  |
  //       | f*  e*  c  |
  double complex de = A[0][1] * A[1][2];                            // d * e
  double dd = SQR_ABS(A[0][1]);                                  // d * conj(d)
  double ee = SQR_ABS(A[1][2]);                                  // e * conj(e)
  double ff = SQR_ABS(A[0][2]);                                  // f * conj(f)
  m  = creal(A[0][0]) + creal(A[1][1]) + creal(A[2][2]);
  c1 = (creal(A[0][0])*creal(A[1][1])  // a*b + a*c + b*c - d*conj(d) - e*conj(e) - f*conj(f)
          + creal(A[0][0])*creal(A[2][2])
          + creal(A[1][1])*creal(A[2][2]))
          - (dd + ee + ff);
  c0 = creal(A[2][2])*dd + creal(A[0][0])*ee + creal(A[1][1])*ff
            - creal(A[0][0])*creal(A[1][1])*creal(A[2][2])
            - 2.0 * (creal(A[0][2])*creal(de) + cimag(A[0][2])*cimag(de));
                             // c*d*conj(d) + a*e*conj(e) + b*f*conj(f) - a*b*c - 2*Re(conj(f)*d*e)

  double p, sqrt_p, q, c, s, phi;
  p = SQR(m) - 3.0*c1;
  q = m*(p - (3.0/2.0)*c1) - (27.0/2.0)*c0;
  sqrt_p = sqrt(fabs(p));

  phi = 27.0 * ( 0.25*SQR(c1)*(p - c1) + c0*(q + 27.0/4.0*c0));
  phi = (1.0/3.0) * atan2(sqrt(fabs(phi)), q);

  c = sqrt_p*cos(phi);
  s = (1.0/M_SQRT3)*sqrt_p*sin(phi);

  w[1]  = (1.0/3.0)*(m - c);
  w[2]  = w[1] + s;
  w[0]  = w[1] + c;
  w[1] -= s;

  return 0;
}


// ----------------------------------------------------------------------------
int zheevq3(double complex A[3][3], double complex Q[3][3], double w[3])
// ----------------------------------------------------------------------------
// Calculates the eigenvalues and normalized eigenvectors of a hermitian 3x3
// matrix A using the QL algorithm with implicit shifts, preceded by a
// Householder reduction to real tridiagonal form.
// The function accesses only the diagonal and upper triangular parts of A.
// The access is read-only.
// ----------------------------------------------------------------------------
// Parameters:
//   A: The hermitian input matrix
//   Q: Storage buffer for eigenvectors
//   w: Storage buffer for eigenvalues
// ----------------------------------------------------------------------------
// Return value:
//   0: Success
//  -1: Error (no convergence)
// ----------------------------------------------------------------------------
// Dependencies:
//   zhetrd3()
// ----------------------------------------------------------------------------
{
  const int n = 3;
  double e[3];                 // The third element is used only as temporary workspace
  double g, r, p, f, b, s, c;  // Intermediate storage
  double complex t;
  int nIter;
  int m;

  // Transform A to real tridiagonal form by the Householder method
  zhetrd3(A, Q, w, e);

  // Calculate eigensystem of the remaining real symmetric tridiagonal matrix
  // with the QL method
  //
  // Loop over all off-diagonal elements
  for (int l=0; l < n-1; l++)
  {
    nIter = 0;
    while (1)
    {
      // Check for convergence and exit iteration loop if off-diagonal
      // element e(l) is zero
      for (m=l; m <= n-2; m++)
      {
        g = fabs(w[m])+fabs(w[m+1]);
        if (fabs(e[m]) + g == g)
          break;
      }
      if (m == l)
        break;

      if (nIter++ >= 30)
        return -1;

      // Calculate g = d_m - k
      g = (w[l+1] - w[l]) / (e[l] + e[l]);
      r = sqrt(SQR(g) + 1.0);
      if (g > 0)
        g = w[m] - w[l] + e[l]/(g + r);
      else
        g = w[m] - w[l] + e[l]/(g - r);

      s = c = 1.0;
      p = 0.0;
      for (int i=m-1; i >= l; i--)
      {
        f = s * e[i];
        b = c * e[i];
        if (fabs(f) > fabs(g))
        {
          c      = g / f;
          r      = sqrt(SQR(c) + 1.0);
          e[i+1] = f * r;
          c     *= (s = 1.0/r);
        }
        else
        {
          s      = f / g;
          r      = sqrt(SQR(s) + 1.0);
          e[i+1] = g * r;
          s     *= (c = 1.0/r);
        }

        g = w[i+1] - p;
        r = (w[i] - g)*s + 2.0*c*b;
        p = s * r;
        w[i+1] = g + p;
        g = c*r - b;

        // Form eigenvectors
#ifndef EVALS_ONLY
        for (int k=0; k < n; k++)
        {
          t = Q[k][i+1];
          Q[k][i+1] = s*Q[k][i] + c*t;
          Q[k][i]   = c*Q[k][i] - s*t;
        }
#endif
      }
      w[l] -= p;
      e[l]  = g;
      e[m]  = 0.0;
    }
  }

  return 0;
}


// ----------------------------------------------------------------------------
int zheevh3(double complex A[3][3], double complex Q[3][3], double w[3])
// ----------------------------------------------------------------------------
// Calculates the eigenvalues and normalized eigenvectors of a hermitian 3x3
// matrix A using Cardano's method for the eigenvalues and an analytical
// method based on vector cross products for the eigenvectors. However,
// if conditions are such that a large error in the results is to be
// expected, the routine falls back to using the slower, but more
// accurate QL algorithm. Only the diagonal and upper triangular parts of A need
// to contain meaningful values. Access to A is read-only.
// ----------------------------------------------------------------------------
// Parameters:
//   A: The hermitian input matrix
//   Q: Storage buffer for eigenvectors
//   w: Storage buffer for eigenvalues
// ----------------------------------------------------------------------------
// Return value:
//   0: Success
//  -1: Error
// ----------------------------------------------------------------------------
// Dependencies:
//   zheevc3(), zhetrd3(), zheevq3()
// ----------------------------------------------------------------------------
// Version history:
//   v1.1: Simplified fallback condition --> speed-up
//   v1.0: First released version
// ----------------------------------------------------------------------------
{
#ifndef EVALS_ONLY
  double norm;          // Squared norm or inverse norm of current eigenvector
//  double n0, n1;        // Norm of first and second columns of A
  double error;         // Estimated maximum roundoff error
  double t, u;          // Intermediate storage
  int j;                // Loop counter
#endif

  // Calculate eigenvalues
  zheevc3(A, w);

#ifndef EVALS_ONLY
//  n0 = SQR(creal(A[0][0])) + SQR_ABS(A[0][1]) + SQR_ABS(A[0][2]);
//  n1 = SQR_ABS(A[0][1]) + SQR(creal(A[1][1])) + SQR_ABS(A[1][2]);

  t = fabs(w[0]);
  if ((u=fabs(w[1])) > t)
    t = u;
  if ((u=fabs(w[2])) > t)
    t = u;
  if (t < 1.0)
    u = t;
  else
    u = SQR(t);
  error = 256.0 * DBL_EPSILON * SQR(u);
//  error = 256.0 * DBL_EPSILON * (n0 + u) * (n1 + u);

  Q[0][1] = A[0][1]*A[1][2] - A[0][2]*creal(A[1][1]);
  Q[1][1] = A[0][2]*conj(A[0][1]) - A[1][2]*creal(A[0][0]);
  Q[2][1] = SQR_ABS(A[0][1]);

  // Calculate first eigenvector by the formula
  //   v[0] = conj( (A - w[0]).e1 x (A - w[0]).e2 )
  Q[0][0] = Q[0][1] + A[0][2]*w[0];
  Q[1][0] = Q[1][1] + A[1][2]*w[0];
  Q[2][0] = (creal(A[0][0]) - w[0]) * (creal(A[1][1]) - w[0]) - Q[2][1];
  norm    = SQR_ABS(Q[0][0]) + SQR_ABS(Q[1][0]) + SQR(creal(Q[2][0]));

  // If vectors are nearly linearly dependent, or if there might have
  // been large cancellations in the calculation of A(I,I) - W(1), fall
  // back to QL algorithm
  // Note that this simultaneously ensures that multiple eigenvalues do
  // not cause problems: If W(1) = W(2), then A - W(1) * I has rank 1,
  // i.e. all columns of A - W(1) * I are linearly dependent.
  if (norm <= error)
	{
    return zheevq3(A, Q, w);
	}
  else                      // This is the standard branch
  {
//printf("hi\n");
    norm = sqrt(1.0 / norm);
    for (j=0; j < 3; j++)
      Q[j][0] = Q[j][0] * norm;
  }

  // Calculate second eigenvector by the formula
  //   v[1] = conj( (A - w[1]).e1 x (A - w[1]).e2 )
  Q[0][1]  = Q[0][1] + A[0][2]*w[1];
  Q[1][1]  = Q[1][1] + A[1][2]*w[1];
  Q[2][1]  = (creal(A[0][0]) - w[1]) * (creal(A[1][1]) - w[1]) - creal(Q[2][1]);
  norm     = SQR_ABS(Q[0][1]) + SQR_ABS(Q[1][1]) + SQR(creal(Q[2][1]));
  if (norm <= error)
    return zheevq3(A, Q, w);
  else
  {
    norm = sqrt(1.0 / norm);
    for (j=0; j < 3; j++)
      Q[j][1] = Q[j][1] * norm;
  }

  // Calculate third eigenvector according to
  //   v[2] = conj(v[0] x v[1])
  Q[0][2] = conj(Q[1][0]*Q[2][1] - Q[2][0]*Q[1][1]);
  Q[1][2] = conj(Q[2][0]*Q[0][1] - Q[0][0]*Q[2][1]);
  Q[2][2] = conj(Q[0][0]*Q[1][1] - Q[1][0]*Q[0][1]);
#endif

  return 0;
}



/***************************************************************************
 *                  I N T E R N A L   F U N C T I O N S                    *
 ***************************************************************************/

/***************************************************************************
 * Function glb_init_probability_engine                                    *
 ***************************************************************************
 * Allocates internal data structures for the probability engine.          *
 ***************************************************************************/
int glb_init_probability_engine()
{
  glb_free_probability_engine();

  U = gsl_matrix_complex_calloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);
  H = gsl_matrix_complex_calloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);
  Q = gsl_matrix_complex_calloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);
  lambda = gsl_vector_alloc(GLB_NU_FLAVOURS);
  S = gsl_matrix_complex_calloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);

  H0_template = gsl_matrix_complex_calloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);
  S1 = gsl_matrix_complex_calloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);
  T0 = gsl_matrix_complex_calloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);

  return 0;
}


/***************************************************************************
 * Function glb_free_probability_engine                                    *
 ***************************************************************************
 * Destroys internal data structures of the probability engine.            *
 ***************************************************************************/
int glb_free_probability_engine()
{
  if (T0!=NULL)     { gsl_matrix_complex_free(T0);  T0 = NULL; }
  if (S1!=NULL)     { gsl_matrix_complex_free(S1);  S1 = NULL; }
  if (H0_template!=NULL) { gsl_matrix_complex_free(H0_template);  H0_template = NULL; }

  if (S!=NULL)      { gsl_matrix_complex_free(S);   S = NULL; }
  if (lambda!=NULL) { gsl_vector_free(lambda);      lambda = NULL; }
  if (Q!=NULL)      { gsl_matrix_complex_free(Q);   Q = NULL; }
  if (H!=NULL)      { gsl_matrix_complex_free(H);   H = NULL; }
  if (U!=NULL)      { gsl_matrix_complex_free(U);   U = NULL; }

  return 0;
}


/***************************************************************************
 * Function glb_set_oscillation_parameters                                 *
 ***************************************************************************
 * Sets the fundamental oscillation parameters and precomputes the mixing  *
 * matrix and part of the Hamiltonian.                                     *
 ***************************************************************************/
int glb_set_oscillation_parameters(osc_params_angles opa)
{
  double complex (*_U)[GLB_NU_FLAVOURS]
    = (double complex (*)[GLB_NU_FLAVOURS]) gsl_matrix_complex_ptr(U, 0, 0);
  int i;

  /* Copy parameters */
  th12  = opa.theta12;
  th13  = opa.theta13;
  th23  = opa.theta23;
  delta = opa.delta;
  mq[0] = 0;
  mq[1] = opa.dms;
  mq[2] = opa.dma;

  /* Compute vacuum mixing matrix */
  _U[0][0] = cos(th12)*cos(th13);
  _U[0][1] = sin(th12)*cos(th13);
  _U[0][2] = sin(th13) * cexp(-I * delta);

  _U[1][0] = -sin(th12)*cos(th23) - cos(th12)*sin(th23)*sin(th13) * cexp(I*delta);
  _U[1][1] =  cos(th12)*cos(th23) - sin(th12)*sin(th23)*sin(th13) * cexp(I*delta);
  _U[1][2] =  sin(th23)*cos(th13);

  _U[2][0] =  sin(th12)*sin(th23) - cos(th12)*cos(th23)*sin(th13) * cexp(I*delta);
  _U[2][1] = -cos(th12)*sin(th23) - sin(th12)*cos(th23)*sin(th13) * cexp(I*delta);
  _U[2][2] =  cos(th23)*cos(th13);

  /* Calculate energy independent matrix H0 * E */
  gsl_matrix_complex_set_zero(H0_template);
  gsl_matrix_complex_set_zero(H);
  for (i=0; i < GLB_NU_FLAVOURS; i++)
    gsl_matrix_complex_set(H0_template, i, i, gsl_complex_rect(0.5*mq[i], 0.0));

  gsl_matrix_complex *T = gsl_matrix_complex_alloc(GLB_NU_FLAVOURS, GLB_NU_FLAVOURS);
  gsl_blas_zgemm(CblasNoTrans, CblasConjTrans, GSL_COMPLEX_ONE, H0_template, U, /* T=H0.U^\dagger */
                 GSL_COMPLEX_ZERO, T);
  gsl_blas_zgemm(CblasNoTrans, CblasNoTrans, GSL_COMPLEX_ONE, U, T,             /* H0=U.T */
                 GSL_COMPLEX_ZERO, H0_template);
  gsl_matrix_complex_free(T);
  return 0;
}


/***************************************************************************
 * Function glb_hamiltonian_cd                                             *
 ***************************************************************************
 * Calculates the Hamiltonian for neutrinos (cp_sign=1) or antineutrinos   *
 * (cp_sign=-1) with energy E, propagating in matter of density V          *
 * (> 0 even for antineutrinos) and stores the result in H.                *
 ***************************************************************************/
int glb_hamiltonian_cd(double E, double V, int cp_sign)
{
  double inv_E = 1.0 / E;
  double complex (*_H)[GLB_NU_FLAVOURS]
    = (double complex (*)[GLB_NU_FLAVOURS]) gsl_matrix_complex_ptr(H, 0, 0);
  double complex (*_H0_template)[GLB_NU_FLAVOURS]
    = (double complex (*)[GLB_NU_FLAVOURS]) gsl_matrix_complex_ptr(H0_template, 0, 0);
  int i, j;

  if (cp_sign > 0)
  {
    for (i=0; i < GLB_NU_FLAVOURS; i++)
      for (j=0; j < GLB_NU_FLAVOURS; j++)
        _H[i][j] = _H0_template[i][j] * inv_E;
  }
  else
  {
    for (i=0; i < GLB_NU_FLAVOURS; i++)
      for (j=0; j < GLB_NU_FLAVOURS; j++)
        _H[i][j] = conj(_H0_template[i][j] * inv_E); /* delta_CP -> -delta_CP */
  }

  _H[0][0] = _H[0][0] + cp_sign*V;
  return 0;
}


/***************************************************************************
 * Function glb_S_matrix_cd                                                *
 ***************************************************************************
 * Calculates the S matrix for neutrino oscillations in matter of constant *
 * density using a fast eigenvalue solver optimized to 3x3 matrices.       *
 ***************************************************************************
 * Parameters:                                                             *
 *   E: Neutrino energy                                                    *
 *   L: Baseline                                                           *
 *   V: Matter potential (must be > 0 even for antineutrinos)              *
 *   cp_sign: +1 for neutrinos, -1 for antineutrinos                       *
 ***************************************************************************/
int glb_S_matrix_cd(double E, double L, double V, int cp_sign)
{
  /* Introduce some abbreviations */
  double complex (*_S)[3]  = (double complex (*)[3]) gsl_matrix_complex_ptr(S,0,0);
  double complex (*_Q)[3]  = (double complex (*)[3]) gsl_matrix_complex_ptr(Q,0,0);
  double complex (*_T0)[3] = (double complex (*)[3]) gsl_matrix_complex_ptr(T0,0,0);
  double *_lambda = gsl_vector_ptr(lambda,0);
  int status;
  int i, j, k;

    double complex (*_H)[3] = (double complex (*)[3]) gsl_matrix_complex_ptr(H,0,0);

  /* Calculate neutrino Hamiltonian */
  if ((status=glb_hamiltonian_cd(E, V, cp_sign)) != 0)
    return status;

  /* Calculate eigenvalues of Hamiltonian */
  if ((status=zheevh3(_H, _Q, _lambda)) != 0)
    return status;

  /* Calculate S-Matrix in mass basis in matter ... */
  double phase;
  gsl_matrix_complex_set_zero(S);
  for (i=0; i < GLB_NU_FLAVOURS; i++)
  {
    phase    = -L * _lambda[i];
    _S[i][i] = cos(phase) + I*sin(phase);
  }

  /* ... and transform it to the flavour basis */
  gsl_matrix_complex_set_zero(T0);
  double complex *p = &_T0[0][0];
  for (i=0; i < GLB_NU_FLAVOURS; i++)              /* T0 = S.Q^\dagger */
    for (j=0; j < GLB_NU_FLAVOURS; j++)
    {
      for (int k=0; k < GLB_NU_FLAVOURS; k++)
      {
        *p += ( creal(_S[i][k])*creal(_Q[j][k])+cimag(_S[i][k])*cimag(_Q[j][k]) )
                + I * ( cimag(_S[i][k])*creal(_Q[j][k])-creal(_S[i][k])*cimag(_Q[j][k]) );
      }
      p++;
    }
  gsl_matrix_complex_set_zero(S);
  p = &_S[0][0];
  for (i=0; i < GLB_NU_FLAVOURS; i++)              /* S = Q.T0 */
    for (j=0; j < GLB_NU_FLAVOURS; j++)
    {
      for (k=0; k < GLB_NU_FLAVOURS; k++)
      {
        *p += ( creal(_Q[i][k])*creal(_T0[k][j])-cimag(_Q[i][k])*cimag(_T0[k][j]) )
                + I * ( cimag(_Q[i][k])*creal(_T0[k][j])+creal(_Q[i][k])*cimag(_T0[k][j]) );
      }
      p++;
    }

  return 0;
}


/***************************************************************************
 * Function glb_probability_matrix                                         *
 ***************************************************************************
 * Calculates the neutrino oscillation probability matrix.                 *
 ***************************************************************************
 * Parameters:                                                             *
 *   P:       Buffer for the storage of the matrix                         *
 *   cp_sign: +1 for neutrinos, -1 for antineutrinos                       *
 *   E:       Neutrino energy (in GeV)                                     *
 *   length:  Lengths of the layers in the matter density profile in km    *
 *   density: The matter densities in g/cm^3                               *
 ***************************************************************************/
int glb_probability_matrix(double P[3][3], int cp_sign, double E,
    const double *length, const double *density)
{
	int status;
	int i, j;

	/* Convert energy to eV */
	E *= 1.0e9;

	status = glb_S_matrix_cd(E, GLB_KM_TO_EV(length[0]), density[0]*GLB_V_FACTOR*GLB_Ne_MANTLE, cp_sign);
	if (status != 0)
		return status;

	double complex (*_S)[3] = (double complex (*)[3]) gsl_matrix_complex_ptr(S,0,0);
	for (i=0; i < GLB_NU_FLAVOURS; i++)
	  for (j=0; j < GLB_NU_FLAVOURS; j++)
		P[j][i] = SQR_ABS(_S[i][j]);


  return 0;
}



================================================
FILE: Benchmarks/globes/src/main.c
================================================
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <math.h>

#include "glb_probability.h"

#define M_PI 3.141592653589793238462643383279

// gets the difference in time in nanoseconds
int difftimespec_ns(const struct timespec end_time, const struct timespec start_time)
{
	return 1000 * (((int)end_time.tv_sec - (int)start_time.tv_sec) * (int)1000000 + ((int)end_time.tv_nsec - (int)start_time.tv_nsec) / 1000);
}
double Speed(int n)
{
	/* Setup default probability engine */
	glb_init_probability_engine();

	osc_params_angles opa;
	opa.theta12 = 33 * M_PI / 180;
	opa.theta13 = 8.5 * M_PI / 180;
	opa.theta23 = 48 * M_PI / 180;
	opa.delta = 0.7 * M_PI;
	opa.dms = 7.5e-5;
	opa.dma = 2.5e-3;
	glb_set_oscillation_parameters(opa);

	double P[3][3];
	int cp_sign = +1;
	double rho = 3.;
	double L = 1300.;

	// initialize the grid
	double *Es = malloc(n * sizeof(double));

	double E_min, E_scale, E_max;

	E_min = 1e-1;
	E_max = 1e2;

	E_scale = pow(E_max / E_min, 1. / n);

	// fill in arrays outside of timing
	for (int i = 0; i < n; i++)
		Es[i] = E_min * pow(E_scale, i);

	struct timespec start_time, end_time;
	clock_gettime(CLOCK_MONOTONIC_RAW, &start_time);
	for (int i = 0; i < n; i++)
		glb_probability_matrix(P, cp_sign, Es[i], &L, &rho);
	clock_gettime(CLOCK_MONOTONIC_RAW, &end_time);

	glb_free_probability_engine();
	free(Es);

	return 1.0 * difftimespec_ns(end_time, start_time) / n;
}

int main()
{
	double s, speed_sum, speedsq_sum, mean, std;
	int m, n;

	m = 1e3;
	n = 1e3;

	speed_sum = 0;
	speedsq_sum = 0;
	for (int i = 0; i < m; i++)
	{
if (i % 100 == 0) printf("%g\n", 1.0 * i / m);
		s = Speed(n);
		speed_sum += s;
		speedsq_sum += s * s;
	} // i, m
	mean = speed_sum / m;
	std = sqrt(speedsq_sum / m - mean * mean);
	printf("t = %g +- %g ns\n", mean, std);

	return 0;
}



================================================
FILE: c++/compile.sh
================================================
g++ -Ofast -ffast-math NuFast.cpp -o NuFast



================================================
FILE: c++/NuFast.cpp
================================================
#include <cmath>
#include <stdio.h>

// Some constants
constexpr double const eVsqkm_to_GeV_over4 = 1e-9 / 1.97327e-7 * 1e3 / 4;
constexpr double const YerhoE2a = 1.52588e-4;

// Probability_Matter_LBL calculates all nine oscillation probabilities including
// the matter effect in an optimized, fast, and efficient way. The precision can
// be controlled with N_Newton. For many applications N_Newton=0 may be enough,
// but many years of DUNE or HK-LBL may require N_Newton=1. This code may be
// suitable for atmospheric neutrinos. The code is standalone.
//
// Inputs:
//   mixing angles (usual parameterization)
//   phase (usual parameterization) make Dmsq31 positive/negative for the NO/IO
//   Delta msq's (eV^2)
//   L (km)
//   E (GeV) positive for neutrinos, negative for antineutrinos
//   rho (g/cc)
//   Ye: electron fraction, typically around 0.5
//   N_Newton: number of Newton's method iterations to do. should be zero, one, two (or higher)
// Outputs:
//   probs_returned is all nine oscillation probabilities: e.g. probs_returned[1][0] is mu->e
void Probability_Matter_LBL(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double rho, double Ye, int N_Newton, double (*probs_returned)[3][3])
{
	double c13sq, sind, cosd, Jrr, Jmatter, Dmsqee, Amatter;
	double Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq;
	double A, B, C;
	double See, Tee, Smm, Tmm;
	double xmat, lambda2, lambda3, Dlambda21, Dlambda31, Dlambda32;
	double Xp2, Xp3, PiDlambdaInv, tmp;
	double Lover4E, D21, D32;
	double sinD21, sinD31, sinD32;
	double sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin;
	double Pme_CPC, Pme_CPV, Pmm, Pee;

	// --------------------------------------------------------------------- //
	// First calculate useful simple functions of the oscillation parameters //
	// --------------------------------------------------------------------- //
	c13sq = 1 - s13sq;

	// Ueisq's
	Ue2sq = c13sq * s12sq;
	Ue3sq = s13sq;

	// Umisq's, Utisq's and Jvac	 
	Um3sq = c13sq * s23sq;
	// Um2sq and Ut2sq are used here as temporary variables, will be properly defined later	 
	Ut2sq = s13sq * s12sq * s23sq;
	Um2sq = (1 - s12sq) * (1 - s23sq);

	Jrr = sqrt(Um2sq * Ut2sq);
	sind = sin(delta);
	cosd = cos(delta);

	Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd;
	Jmatter = 8 * Jrr * c13sq * sind;
	Amatter = Ye * rho * E * YerhoE2a;
	Dmsqee = Dmsq31 - s12sq * Dmsq21;

	// calculate A, B, C, See, Tee, and part of Tmm
	A = Dmsq21 + Dmsq31; // temporary variable
	See = A - Dmsq21 * Ue2sq - Dmsq31 * Ue3sq;
	Tmm = Dmsq21 * Dmsq31; // using Tmm as a temporary variable	  
	Tee = Tmm * (1 - Ue3sq - Ue2sq);
	C = Amatter * Tee;
	A = A + Amatter;

	// ---------------------------------- //
	// Get lambda3 from lambda+ of MP/DMP //
	// ---------------------------------- //
	xmat = Amatter / Dmsqee;
	tmp = 1 - xmat;
	lambda3 = Dmsq31 + 0.5 * Dmsqee * (xmat - 1 + sqrt(tmp * tmp + 4 * s13sq * xmat));

	// ---------------------------------------------------------------------------- //
	// Newton iterations to improve lambda3 arbitrarily, if needed, (B needed here) //
	// ---------------------------------------------------------------------------- //
	B = Tmm + Amatter * See; // B is only needed for N_Newton >= 1
	for (int i = 0; i < N_Newton; i++)
		lambda3 = (lambda3 * lambda3 * (lambda3 + lambda3 - A) + C) / (lambda3 * (2 * (lambda3 - A) + lambda3) + B); // this strange form prefers additions to multiplications

	// ------------------- //
	// Get  Delta lambda's //
	// ------------------- //
	tmp = A - lambda3;
	Dlambda21 = sqrt(tmp * tmp - 4 * C / lambda3);
	lambda2 = 0.5 * (A - lambda3 + Dlambda21);
	Dlambda32 = lambda3 - lambda2;
	Dlambda31 = Dlambda32 + Dlambda21;

	// ----------------------- //
	// Use Rosetta for Veisq's //
	// ----------------------- //
	// denominators	  
	PiDlambdaInv = 1 / (Dlambda31 * Dlambda32 * Dlambda21);
	Xp3 = PiDlambdaInv * Dlambda21;
	Xp2 = -PiDlambdaInv * Dlambda31;

	// numerators
	Ue3sq = (lambda3 * (lambda3 - See) + Tee) * Xp3;
	Ue2sq = (lambda2 * (lambda2 - See) + Tee) * Xp2;

	Smm = A - Dmsq21 * Um2sq - Dmsq31 * Um3sq;
	Tmm = Tmm * (1 - Um3sq - Um2sq) + Amatter * (See + Smm - A);

	Um3sq = (lambda3 * (lambda3 - Smm) + Tmm) * Xp3;
	Um2sq = (lambda2 * (lambda2 - Smm) + Tmm) * Xp2;

	// ------------- //
	// Use NHS for J //
	// ------------- //
	Jmatter = Jmatter * Dmsq21 * Dmsq31 * (Dmsq31 - Dmsq21) * PiDlambdaInv;

	// ----------------------- //
	// Get all elements of Usq //
	// ----------------------- //
	Ue1sq = 1 - Ue3sq - Ue2sq;
	Um1sq = 1 - Um3sq - Um2sq;

	Ut3sq = 1 - Um3sq - Ue3sq;
	Ut2sq = 1 - Um2sq - Ue2sq;
	Ut1sq = 1 - Um1sq - Ue1sq;

	// ----------------------- //
	// Get the kinematic terms //
	// ----------------------- //
	Lover4E = eVsqkm_to_GeV_over4 * L / E;

	D21 = Dlambda21 * Lover4E;
	D32 = Dlambda32 * Lover4E;
	  
	sinD21 = sin(D21);
	sinD31 = sin(D32 + D21);
	sinD32 = sin(D32);

	triple_sin = sinD21 * sinD31 * sinD32;

	sinsqD21_2 = 2 * sinD21 * sinD21;
	sinsqD31_2 = 2 * sinD31 * sinD31;
	sinsqD32_2 = 2 * sinD32 * sinD32;

	// ------------------------------------------------------------------- //
	// Calculate the three necessary probabilities, separating CPC and CPV //
	// ------------------------------------------------------------------- //
	Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2
			+ (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2
			+ (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2;
	Pme_CPV = -Jmatter * triple_sin;

	Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2
				 + Um3sq * Um1sq * sinsqD31_2
				 + Um3sq * Um2sq * sinsqD32_2);

	Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2
				 + Ue3sq * Ue1sq * sinsqD31_2
				 + Ue3sq * Ue2sq * sinsqD32_2);

	// ---------------------------- //
	// Assign all the probabilities //
	// ---------------------------- //
	(*probs_returned)[0][0] = Pee;														// Pee
	(*probs_returned)[0][1] = Pme_CPC - Pme_CPV;										// Pem
	(*probs_returned)[0][2] = 1 - Pee - (*probs_returned)[0][1];  						// Pet

	(*probs_returned)[1][0] = Pme_CPC + Pme_CPV;										// Pme
	(*probs_returned)[1][1] = Pmm;														// Pmm
	(*probs_returned)[1][2] = 1 - (*probs_returned)[1][0] - Pmm;						// Pmt

	(*probs_returned)[2][0] = 1 - Pee - (*probs_returned)[1][0];						// Pte
	(*probs_returned)[2][1] = 1 - (*probs_returned)[0][1] - Pmm;						// Ptm
	(*probs_returned)[2][2] = 1 - (*probs_returned)[0][2] - (*probs_returned)[1][2];	// Ptt
}

void Probability_Vacuum_LBL(double s12sq, double s13sq, double s23sq, double delta, double Dmsq21, double Dmsq31, double L, double E, double (*probs_returned)[3][3])
{
	double c13sq, sind, cosd, Jrr, Jvac;
	double Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq;
	double Lover4E, D21, D31;
	double sinD21, sinD31, sinD32;
	double sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin;
	double Pme_CPC, Pme_CPV, Pmm, Pee;

	// --------------------------------------------------------------------- //
	// First calculate useful simple functions of the oscillation parameters //
	// --------------------------------------------------------------------- //
	c13sq = 1 - s13sq;

	// Ueisq's
	Ue3sq = s13sq;
	Ue2sq = c13sq * s12sq;

	// Umisq's, Utisq's and Jvac	 
	Um3sq = c13sq * s23sq;
	// Um2sq and Ut2sq are used here as temporary variables, will be properly defined later	 
	Ut2sq = s13sq * s12sq * s23sq;
	Um2sq = (1 - s12sq) * (1 - s23sq);
	  
	Jrr = sqrt(Um2sq * Ut2sq);
	sind = sin(delta);
	cosd = cos(delta);
	Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd;
	Jvac = 8 * Jrr * c13sq * sind;
	
	// ----------------------- //
	// Get all elements of Usq //
	// ----------------------- //
	Ue1sq = 1 - Ue3sq - Ue2sq;
	Um1sq = 1 - Um3sq - Um2sq;

	Ut3sq = 1 - Um3sq - Ue3sq;
	Ut2sq = 1 - Um2sq - Ue2sq;
	Ut1sq = 1 - Um1sq - Ue1sq;

	// ----------------------- //
	// Get the kinematic terms //
	// ----------------------- //
	Lover4E = eVsqkm_to_GeV_over4 * L / E;

	D21 = Dmsq21 * Lover4E;
	D31 = Dmsq31 * Lover4E;
	  
	sinD21 = sin(D21);
	sinD31 = sin(D31);
	sinD32 = sin(D31-D21);

	triple_sin = sinD21 * sinD31 * sinD32;

	sinsqD21_2 = 2 * sinD21 * sinD21;
	sinsqD31_2 = 2 * sinD31 * sinD31;
	sinsqD32_2 = 2 * sinD32 * sinD32;

	// ------------------------------------------------------------------- //
	// Calculate the three necessary probabilities, separating CPC and CPV //
	// ------------------------------------------------------------------- //
	Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2
			+ (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2
			+ (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2;
	
	Pme_CPV = -Jvac * triple_sin;

	Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2
				 + Um3sq * Um1sq * sinsqD31_2
				 + Um3sq * Um2sq * sinsqD32_2);

	Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2
				 + Ue3sq * Ue1sq * sinsqD31_2
				 + Ue3sq * Ue2sq * sinsqD32_2);

	// ---------------------------- //
	// Assign all the probabilities //
	// ---------------------------- //
	(*probs_returned)[0][0] = Pee;														// Pee
	(*probs_returned)[0][1] = Pme_CPC - Pme_CPV;										// Pem
	(*probs_returned)[0][2] = 1 - Pee - (*probs_returned)[0][1];  						// Pet

	(*probs_returned)[1][0] = Pme_CPC + Pme_CPV;										// Pme
	(*probs_returned)[1][1] = Pmm;														// Pmm
	(*probs_returned)[1][2] = 1 - (*probs_returned)[1][0] - Pmm;						// Pmt

	(*probs_returned)[2][0] = 1 - Pee - (*probs_returned)[1][0];						// Pte
	(*probs_returned)[2][1] = 1 - (*probs_returned)[0][1] - Pmm;						// Ptm
	(*probs_returned)[2][2] = 1 - (*probs_returned)[0][2] - (*probs_returned)[1][2];	// Ptt
}

int main()
{
	double L, E, rho, Ye, probs_returned[3][3];
	double s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31;
	int N_Newton;

	// ------------------------------- //
	// Set the experimental parameters //
	// ------------------------------- //
	L = 1300; // km
	E = 2.5; // GeV
	rho = 3; // g/cc
	Ye = 0.5;

	// --------------------------------------------------------------------- //
	// Set the number of Newton-Raphson iterations which sets the precision. //
	// 0 is close to the single precision limit and is better than DUNE/HK   //
	// in the high statistics regime. Increasig N_Newton to 1,2,... rapidly  //
	// improves the precision at a modest computational cost                 //
	// --------------------------------------------------------------------- //
	N_Newton = 0;

	// ------------------------------------- //
	// Set the vacuum oscillation parameters //
	// ------------------------------------- //
	s12sq = 0.31;
	s13sq = 0.02;
	s23sq = 0.55;
	delta = 0.7 * M_PI;
	Dmsq21 = 7.5e-5; // eV^2
	Dmsq31 = 2.5e-3; // eV^2

	// ------------------------------------------ //
	// Calculate all 9 oscillations probabilities //
	// ------------------------------------------ //
	Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, &probs_returned);

	// --------------------------- //
	// Print out the probabilities //
	// --------------------------- //
	printf("L = %g E = %g rho = %g\n", L, E, rho);
	printf("Probabilities:\n");
	printf("alpha beta P(nu_alpha -> nu_beta)\n");
	for (int alpha = 0; alpha < 3; alpha++)
	{
		for (int beta = 0; beta < 3; beta++)
		{
			printf("%d %d %g\n", alpha, beta, probs_returned[alpha][beta]);
		} // beta, 3
	} // alpha, 3

}



================================================
FILE: f/compile.sh
================================================
gfortran -fdefault-real-8 -Ofast -ffast-math NuFast.f90 -o NuFast



================================================
FILE: f/NuFast.f90
================================================
module Parameters
    implicit none
    real, parameter :: PI = 3.14159265358979323846264338327950288419716939937510
    real, parameter :: YerhoE2a = 1.52588e-4 ! Converts electron fraction times density (g/cc) times neutrino energy (GeV) to eV^2
    real, parameter :: eVsqkm_to_GeV_over4 = 1e-9 / 1.97327e-7 * 1e3 / 4
end module Parameters

! Probability_Matter_LBL calculates all nine oscillation probabilities including
! the matter effect in an optimized, fast, and efficient way. The precision can
! be controlled with N_Newton. For many applications N_Newton=0 may be enough,
! but many years of DUNE or HK-LBL may require N_Newton=1. This code may be
! suitable for atmospheric neutrinos. The code is standalone with the Parameters
! module for several constants.
!
! Inputs:
!   mixing angles (usual parameterization)
!   phase (usual parameterization) make Dmsq31 positive/negative for the NO/IO
!   Delta msq's (eV^2)
!   L (km)
!   E (GeV) positive for neutrinos, negative for antineutrinos
!   rho (g/cc)
!   Ye: electron fraction, typically around 0.5
!   N_Newton: number of Newton's method iterations to do. should be zero, one, two (or higher)
! Outputs:
!   probs_returned is all nine oscillation probabilities: e.g. probs_returned(2,1) is mu->e
subroutine Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)
    use Parameters
    implicit none
    real, intent(in) :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye
    integer, intent(in) :: N_Newton
    real, intent(out) :: probs_returned(3, 3)

    real :: c13sq, sind, cosd, Jrr, Jmatter, Dmsqee, Amatter
    real :: Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq
    real :: A, B, C
    real :: See, Tee, Smm, Tmm
    real :: xmat, lambda2, lambda3, Dlambda21, Dlambda31, Dlambda32
    real :: Xp2, Xp3, PiDlambdaInv
    real :: Lover4E, D21, D32
    real :: sinD21, sinD31, sinD32
    real :: sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin
    real :: Pme_CPC, Pme_CPV, Pmm, Pee
    integer :: i

    ! --------------------------------------------------------------------- !
    ! First calculate useful simple functions of the oscillation parameters !
    ! --------------------------------------------------------------------- !
    c13sq = 1 - s13sq

    ! Ueisq's
    Ue2sq = c13sq * s12sq
    Ue3sq = s13sq

    ! Umisq's, Utisq's and Jvac     
    Um3sq = c13sq * s23sq
    ! Um2sq and Ut2sq are used here as temporary variables, will be properly defined later     
    Ut2sq = s13sq * s12sq * s23sq
    Um2sq = (1 - s12sq) * (1 - s23sq)
      
    Jrr = sqrt(Um2sq * Ut2sq)
    sind = sin(delta)
    cosd = cos(delta)

    Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd
    Jmatter = 8 * Jrr * c13sq * sind
    Amatter = Ye * rho * E * YerhoE2a
    Dmsqee = Dmsq31 - s12sq * Dmsq21

    ! calculate A, B, C, See, Tee, and part of Tmm
    A = Dmsq21 + Dmsq31 ! temporary variable
    See = A - Dmsq21 * Ue2sq - Dmsq31 * Ue3sq
    Tmm = Dmsq21 * Dmsq31 ! using Tmm as a temporary variable      
    Tee = Tmm * (1 - Ue3sq - Ue2sq)
    C = Amatter * Tee
    A = A + Amatter

    ! ---------------------------------- !
    ! Get lambda3 from lambda+ of MP/DMP !
    ! ---------------------------------- !
    xmat = Amatter / Dmsqee
    lambda3 = Dmsq31 + 0.5 * Dmsqee * (xmat - 1 + sqrt((1 - xmat) ** 2 + 4 * s13sq * xmat))

    ! ---------------------------------------------------------------------------- !
    ! Newton iterations to improve lambda3 arbitrarily, if needed, (B needed here) !
    ! ---------------------------------------------------------------------------- !
    B = Tmm + Amatter * See ! B is only needed for N_Newton >= 1
    do i = 1, N_Newton
        lambda3 = (lambda3 * lambda3 * (lambda3 + lambda3 - A) + C) / (lambda3 * (2 * (lambda3 - A) + lambda3) + B) ! this strange form prefers additions to multiplications
    enddo ! i, 1, N_Newton

    ! ------------------- !
    ! Get  Delta lambda's !
    ! ------------------- !
    Dlambda21 = sqrt((A - lambda3) ** 2 - 4 * C / lambda3)
    lambda2 = 0.5 * (A - lambda3 + Dlambda21)
    Dlambda32 = lambda3 - lambda2
    Dlambda31 = Dlambda32 + Dlambda21

    ! ----------------------- !
    ! Use Rosetta for Veisq's !
    ! ----------------------- !
    ! denominators      
    PiDlambdaInv = 1 / (Dlambda31 * Dlambda32 * Dlambda21)
    Xp3 = PiDlambdaInv * Dlambda21
    Xp2 = -PiDlambdaInv * Dlambda31

    ! numerators
    Ue3sq = (lambda3 * (lambda3 - See) + Tee) * Xp3
    Ue2sq = (lambda2 * (lambda2 - See) + Tee) * Xp2

    Smm = A - Dmsq21 * Um2sq - Dmsq31 * Um3sq
    Tmm = Tmm * (1 - Um3sq - Um2sq) + Amatter * (See + Smm - A)

    Um3sq = (lambda3 * (lambda3 - Smm) + Tmm) * Xp3
    Um2sq = (lambda2 * (lambda2 - Smm) + Tmm) * Xp2

    ! ------------- !
    ! Use NHS for J !
    ! ------------- !
    Jmatter = Jmatter * Dmsq21 * Dmsq31 * (Dmsq31 - Dmsq21) * PiDlambdaInv

    ! ----------------------- !
    ! Get all elements of Usq !
    ! ----------------------- !
    Ue1sq = 1 - Ue3sq - Ue2sq
    Um1sq = 1 - Um3sq - Um2sq

    Ut3sq = 1 - Um3sq - Ue3sq
    Ut2sq = 1 - Um2sq - Ue2sq
    Ut1sq = 1 - Um1sq - Ue1sq

    ! ----------------------- !
    ! Get the kinematic terms !
    ! ----------------------- !
    Lover4E = eVsqkm_to_GeV_over4 * L / E

    D21 = Dlambda21 * Lover4E
    D32 = Dlambda32 * Lover4E
      
    sinD21 = sin(D21)
    sinD31 = sin(D32 + D21)
    sinD32 = sin(D32)

    triple_sin = sinD21 * sinD31 * sinD32

    sinsqD21_2 = 2 * sinD21 * sinD21
    sinsqD31_2 = 2 * sinD31 * sinD31
    sinsqD32_2 = 2 * sinD32 * sinD32

    ! ------------------------------------------------------------------- !
    ! Calculate the three necessary probabilities, separating CPC and CPV !
    ! ------------------------------------------------------------------- !
    Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2 &
            + (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2 &
            + (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2
    Pme_CPV = -Jmatter * triple_sin

    Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2 &
                 + Um3sq * Um1sq * sinsqD31_2 &
                 + Um3sq * Um2sq * sinsqD32_2)

    Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2 &
                 + Ue3sq * Ue1sq * sinsqD31_2 &
                 + Ue3sq * Ue2sq * sinsqD32_2)

    ! ---------------------------- !
    ! Assign all the probabilities !
    ! ---------------------------- !
    probs_returned(1, 1) = Pee                              ! Pee
    probs_returned(1, 2) = Pme_CPC - Pme_CPV                ! Pem
    probs_returned(1, 3) = 1 - Pee - probs_returned(1, 2)   ! Pet

    probs_returned(2, 1) = Pme_CPC + Pme_CPV                ! Pme
    probs_returned(2, 2) = Pmm                              ! Pmm
    probs_returned(2, 3) = 1 - probs_returned(2, 1) - Pmm   ! Pmt

    probs_returned(3, 1) = 1 - Pee - probs_returned(2, 1)
    probs_returned(3, 2) = 1 - probs_returned(1, 2) - Pmm
    probs_returned(3, 3) = 1 - probs_returned(1, 3) - probs_returned(2, 3)
end subroutine Probability_Matter_LBL

subroutine Probability_Vacuum_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, probs_returned)
    use Parameters
    implicit none
    real, intent(in) :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E
    real, intent(out) :: probs_returned(3, 3)

    real :: c13sq, sind, cosd, Jrr, Jvac
    real :: Ue1sq, Ue2sq, Ue3sq, Um1sq, Um2sq, Um3sq, Ut1sq, Ut2sq, Ut3sq
    real :: Lover4E, D21, D31
    real :: sinD21, sinD31, sinD32
    real :: sinsqD21_2, sinsqD31_2, sinsqD32_2, triple_sin
    real :: Pme_CPC, Pme_CPV, Pmm, Pee

    ! --------------------------------------------------------------------- !
    ! First calculate useful simple functions of the oscillation parameters !
    ! --------------------------------------------------------------------- !
    c13sq = 1 - s13sq

    ! Ueisq's
    Ue3sq = s13sq
    Ue2sq = c13sq * s12sq

    ! Umisq's, Utisq's and Jvac     
    Um3sq = c13sq * s23sq
    ! Um2sq and Ut2sq are used here as temporary variables, will be properly defined later     
    Ut2sq = s13sq * s12sq * s23sq
    Um2sq = (1 - s12sq) * (1 - s23sq)
      
    Jrr = sqrt(Um2sq * Ut2sq)
    sind = sin(delta)
    cosd = cos(delta)
    Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd
    Jvac = 8 * Jrr * c13sq * sind
    
    ! ----------------------- !
    ! Get all elements of Usq !
    ! ----------------------- !
    Ue1sq = 1 - Ue3sq - Ue2sq
    Um1sq = 1 - Um3sq - Um2sq

    Ut3sq = 1 - Um3sq - Ue3sq
    Ut2sq = 1 - Um2sq - Ue2sq
    Ut1sq = 1 - Um1sq - Ue1sq

    ! ----------------------- !
    ! Get the kinematic terms !
    ! ----------------------- !
    Lover4E = eVsqkm_to_GeV_over4 * L / E

    D21 = dmsq21 * Lover4E
    D31 = dmsq31 * Lover4E
      
    sinD21 = sin(D21)
    sinD31 = sin(D31)
    sinD32 = sin(D31-D21)

    triple_sin = sinD21 * sinD31 * sinD32

    sinsqD21_2 = 2 * sinD21 * sinD21
    sinsqD31_2 = 2 * sinD31 * sinD31
    sinsqD32_2 = 2 * sinD32 * sinD32

    ! ------------------------------------------------------------------- !
    ! Calculate the three necessary probabilities, separating CPC and CPV !
    ! ------------------------------------------------------------------- !
    Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2 &
            + (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2 &
            + (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2
    
    Pme_CPV = -Jvac * triple_sin

    Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2 &
                 + Um3sq * Um1sq * sinsqD31_2 &
                 + Um3sq * Um2sq * sinsqD32_2)

    Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2 &
                 + Ue3sq * Ue1sq * sinsqD31_2 &
                 + Ue3sq * Ue2sq * sinsqD32_2)

    ! ---------------------------- !
    ! Assign all the probabilities !
    ! ---------------------------- !
    probs_returned(1, 1) = Pee                              ! Pee
    probs_returned(1, 2) = Pme_CPC - Pme_CPV                ! Pem
    probs_returned(1, 3) = 1 - Pee - probs_returned(1, 2)   ! Pet

    probs_returned(2, 1) = Pme_CPC + Pme_CPV                ! Pme
    probs_returned(2, 2) = Pmm                              ! Pmm
    probs_returned(2, 3) = 1 - probs_returned(2, 1) - Pmm   ! Pmt

    probs_returned(3, 1) = 1 - Pee - probs_returned(2, 1)
    probs_returned(3, 2) = 1 - probs_returned(1, 2) - Pmm
    probs_returned(3, 3) = 1 - probs_returned(1, 3) - probs_returned(2, 3)
end subroutine Probability_Vacuum_LBL

program NuFast
    use Parameters
    implicit none
    external :: Probability_Matter_LBL, Probability_Vacuum_LBL, Speed
    real :: s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye
    real :: probs_returned(3, 3)
    integer :: N_Newton, alpha, beta

    ! ------------------------------- !
    ! Set the experimental parameters !
    ! ------------------------------- !
    L = 1300 ! km
    E = 2.5 ! GeV
    rho = 3 ! g/cc
    Ye = 0.5

    ! --------------------------------------------------------------------- !
    ! Set the number of Newton-Raphson iterations which sets the precision. !
    ! 0 is close to the single precision limit and is better than DUNE/HK   !
    ! in the high statistics regime. Increasig N_Newton to 1,2,... rapidly  !
    ! improves the precision at a modest computational cost                 !
    ! --------------------------------------------------------------------- !
    N_Newton = 0

    ! ------------------------------------- !
    ! Set the vacuum oscillation parameters !
    ! ------------------------------------- !
    s12sq = 0.31
    s13sq = 0.02
    s23sq = 0.55
    delta = 0.7 * PI
    Dmsq21 = 7.5e-5 ! eV^2
    Dmsq31 = 2.5e-3 ! eV^2

    ! ------------------------------------------ !
    ! Calculate all 9 oscillations probabilities !
    ! ------------------------------------------ !
    call Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton, probs_returned)

    ! --------------------------- !
    ! Print out the probabilities !
    ! --------------------------- !
    write (*,"(3(A,F10.2))") "L = ", L, " E = ", E, " rho = ", rho
    write (*,*) "Probabilities:"
    write (*,*) "alpha beta P(nu_alpha -> nu_beta)"
    do alpha = 1, 3
        do beta = 1, 3
            write (*,"(2I3,F10.6)") alpha, beta, probs_returned(alpha, beta)
        end do ! beta, 1, 3
    end do ! alpha, 1, 3

end program NuFast



================================================
FILE: py/NuFast.py
================================================
import numpy as np

# Some constants
eVsqkm_to_GeV_over4 = 1e-9 / 1.97327e-7 * 1e3 / 4
YerhoE2a = 1.52588e-4

# Probability_Matter_LBL calculates all nine oscillation probabilities including
# the matter effect in an optimized, fast, and efficient way. The precision can
# be controlled with N_Newton. For many applications N_Newton=0 may be enough,
# but many years of DUNE or HK-LBL may require N_Newton=1. This code may be
# suitable for atmospheric neutrinos. The code is standalone with the Parameters
# module for several constants.
#
# Inputs:
#   mixing angles (usual parameterization)
#   phase (usual parameterization) make Dmsq31 positive/negative for the NO/IO
#   Delta msq's (eV^2)
#   L (km)
#   E (GeV) positive for neutrinos, negative for antineutrinos
#   rho (g/cc)
#   Ye: electron fraction, typically around 0.5
#   N_Newton: number of Newton's method iterations to do. should be zero, one, two (or higher)
# Outputs:
#   probs_returned is all nine oscillation probabilities: e.g. probs_returned[1][0] is mu->e
def Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton):
	# --------------------------------------------------------------------- #
	# First calculate useful simple functions of the oscillation parameters #
	# --------------------------------------------------------------------- #
	c13sq = 1 - s13sq

	# Ueisq's
	Ue2sq = c13sq * s12sq
	Ue3sq = s13sq

	# Umisq's, Utisq's and Jvac	 
	Um3sq = c13sq * s23sq
	# Um2sq and Ut2sq are used here as temporary variables, will be properly defined later	 
	Ut2sq = s13sq * s12sq * s23sq
	Um2sq = (1 - s12sq) * (1 - s23sq)

	Jrr = np.sqrt(Um2sq * Ut2sq)
	sind = np.sin(delta)
	cosd = np.cos(delta)

	Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd
	Jmatter = 8 * Jrr * c13sq * sind
	Amatter = Ye * rho * E * YerhoE2a
	Dmsqee = Dmsq31 - s12sq * Dmsq21

	# calculate A, B, C, See, Tee, and part of Tmm
	A = Dmsq21 + Dmsq31 # temporary variable
	See = A - Dmsq21 * Ue2sq - Dmsq31 * Ue3sq
	Tmm = Dmsq21 * Dmsq31 # using Tmm as a temporary variable	  
	Tee = Tmm * (1 - Ue3sq - Ue2sq)
	C = Amatter * Tee
	A = A + Amatter

	# ---------------------------------- #
	# Get lambda3 from lambda+ of MP/DMP #
	# ---------------------------------- #
	xmat = Amatter / Dmsqee
	tmp = 1 - xmat
	lambda3 = Dmsq31 + 0.5 * Dmsqee * (xmat - 1 + np.sqrt(tmp * tmp + 4 * s13sq * xmat))

	# ---------------------------------------------------------------------------- #
	# Newton iterations to improve lambda3 arbitrarily, if needed, (B needed here) #
	# ---------------------------------------------------------------------------- #
	B = Tmm + Amatter * See # B is only needed for N_Newton >= 1
	for i in range(N_Newton):
		lambda3 = (lambda3 * lambda3 * (lambda3 + lambda3 - A) + C) / (lambda3 * (2 * (lambda3 - A) + lambda3) + B) # this strange form prefers additions to multiplications

	# ------------------- #
	# Get  Delta lambda's #
	# ------------------- #
	tmp = A - lambda3
	Dlambda21 = np.sqrt(tmp * tmp - 4 * C / lambda3)
	lambda2 = 0.5 * (A - lambda3 + Dlambda21)
	Dlambda32 = lambda3 - lambda2
	Dlambda31 = Dlambda32 + Dlambda21

	# ----------------------- #
	# Use Rosetta for Veisq's #
	# ----------------------- #
	# denominators	  
	PiDlambdaInv = 1 / (Dlambda31 * Dlambda32 * Dlambda21)
	Xp3 = PiDlambdaInv * Dlambda21
	Xp2 = -PiDlambdaInv * Dlambda31

	# numerators
	Ue3sq = (lambda3 * (lambda3 - See) + Tee) * Xp3
	Ue2sq = (lambda2 * (lambda2 - See) + Tee) * Xp2

	Smm = A - Dmsq21 * Um2sq - Dmsq31 * Um3sq
	Tmm = Tmm * (1 - Um3sq - Um2sq) + Amatter * (See + Smm - A)

	Um3sq = (lambda3 * (lambda3 - Smm) + Tmm) * Xp3
	Um2sq = (lambda2 * (lambda2 - Smm) + Tmm) * Xp2

	# ------------- #
	# Use NHS for J #
	# ------------- #
	Jmatter = Jmatter * Dmsq21 * Dmsq31 * (Dmsq31 - Dmsq21) * PiDlambdaInv

	# ----------------------- #
	# Get all elements of Usq #
	# ----------------------- #
	Ue1sq = 1 - Ue3sq - Ue2sq
	Um1sq = 1 - Um3sq - Um2sq

	Ut3sq = 1 - Um3sq - Ue3sq
	Ut2sq = 1 - Um2sq - Ue2sq
	Ut1sq = 1 - Um1sq - Ue1sq

	# ----------------------- #
	# Get the kinematic terms #
	# ----------------------- #
	Lover4E = eVsqkm_to_GeV_over4 * L / E

	D21 = Dlambda21 * Lover4E
	D32 = Dlambda32 * Lover4E
	  
	sinD21 = np.sin(D21)
	sinD31 = np.sin(D32 + D21)
	sinD32 = np.sin(D32)

	triple_sin = sinD21 * sinD31 * sinD32

	sinsqD21_2 = 2 * sinD21 * sinD21
	sinsqD31_2 = 2 * sinD31 * sinD31
	sinsqD32_2 = 2 * sinD32 * sinD32

	# ------------------------------------------------------------------- #
	# Calculate the three necessary probabilities, separating CPC and CPV #
	# ------------------------------------------------------------------- #
	Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2 \
				+ (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2 \
				+ (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2
	Pme_CPV = -Jmatter * triple_sin

	Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2 \
				 + Um3sq * Um1sq * sinsqD31_2 \
				 + Um3sq * Um2sq * sinsqD32_2)

	Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2 \
				 + Ue3sq * Ue1sq * sinsqD31_2 \
				 + Ue3sq * Ue2sq * sinsqD32_2)

	# ---------------------------- #
	# Assign all the probabilities #
	# ---------------------------- #
	probs_returned = np.empty((3, 3))
	probs_returned[0][0] = Pee												# Pee
	probs_returned[0][1] = Pme_CPC - Pme_CPV								# Pem
	probs_returned[0][2] = 1 - Pee - probs_returned[0][1]  					# Pet

	probs_returned[1][0] = Pme_CPC + Pme_CPV								# Pme
	probs_returned[1][1] = Pmm												# Pmm
	probs_returned[1][2] = 1 - probs_returned[1][0] - Pmm					# Pmt

	probs_returned[2][0] = 1 - Pee - probs_returned[1][0]					# Pte
	probs_returned[2][1] = 1 - probs_returned[0][1] - Pmm					# Ptm
	probs_returned[2][2] = 1 - probs_returned[0][2] - probs_returned[1][2]	# Ptt

	return probs_returned

def Probability_Vacuum_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E):
	# --------------------------------------------------------------------- #
	# First calculate useful simple functions of the oscillation parameters #
	# --------------------------------------------------------------------- #
	c13sq = 1 - s13sq

	# Ueisq's
	Ue3sq = s13sq
	Ue2sq = c13sq * s12sq

	# Umisq's, Utisq's and Jvac	 
	Um3sq = c13sq * s23sq
	# Um2sq and Ut2sq are used here as temporary variables, will be properly defined later	 
	Ut2sq = s13sq * s12sq * s23sq
	Um2sq = (1 - s12sq) * (1 - s23sq)
	  
	Jrr = np.sqrt(Um2sq * Ut2sq)
	sind = np.sin(delta)
	cosd = np.cos(delta)
	Um2sq = Um2sq + Ut2sq - 2 * Jrr * cosd
	Jvac = 8 * Jrr * c13sq * sind
	
	# ----------------------- #
	# Get all elements of Usq #
	# ----------------------- #
	Ue1sq = 1 - Ue3sq - Ue2sq
	Um1sq = 1 - Um3sq - Um2sq

	Ut3sq = 1 - Um3sq - Ue3sq
	Ut2sq = 1 - Um2sq - Ue2sq
	Ut1sq = 1 - Um1sq - Ue1sq

	# ----------------------- #
	# Get the kinematic terms #
	# ----------------------- #
	Lover4E = eVsqkm_to_GeV_over4 * L / E

	D21 = Dmsq21 * Lover4E
	D31 = Dmsq31 * Lover4E
	  
	sinD21 = np.sin(D21)
	sinD31 = np.sin(D31)
	sinD32 = np.sin(D31-D21)

	triple_sin = sinD21 * sinD31 * sinD32

	sinsqD21_2 = 2 * sinD21 * sinD21
	sinsqD31_2 = 2 * sinD31 * sinD31
	sinsqD32_2 = 2 * sinD32 * sinD32

	# ------------------------------------------------------------------- #
	# Calculate the three necessary probabilities, separating CPC and CPV #
	# ------------------------------------------------------------------- #
	Pme_CPC = (Ut3sq - Um2sq * Ue1sq - Um1sq * Ue2sq) * sinsqD21_2 \
			+ (Ut2sq - Um3sq * Ue1sq - Um1sq * Ue3sq) * sinsqD31_2 \
			+ (Ut1sq - Um3sq * Ue2sq - Um2sq * Ue3sq) * sinsqD32_2
	
	Pme_CPV = -Jvac * triple_sin

	Pmm = 1 - 2 * (Um2sq * Um1sq * sinsqD21_2 \
				 + Um3sq * Um1sq * sinsqD31_2 \
				 + Um3sq * Um2sq * sinsqD32_2)

	Pee = 1 - 2 * (Ue2sq * Ue1sq * sinsqD21_2 \
				 + Ue3sq * Ue1sq * sinsqD31_2 \
				 + Ue3sq * Ue2sq * sinsqD32_2)

	# ---------------------------- #
	# Assign all the probabilities #
	# ---------------------------- #
	probs_returned = np.empty((3, 3))
	probs_returned[0][0] = Pee												# Pee
	probs_returned[0][1] = Pme_CPC - Pme_CPV								# Pem
	probs_returned[0][2] = 1 - Pee - probs_returned[0][1]  					# Pet

	probs_returned[1][0] = Pme_CPC + Pme_CPV								# Pme
	probs_returned[1][1] = Pmm												# Pmm
	probs_returned[1][2] = 1 - probs_returned[1][0] - Pmm					# Pmt

	probs_returned[2][0] = 1 - Pee - probs_returned[1][0]					# Pte
	probs_returned[2][1] = 1 - probs_returned[0][1] - Pmm					# Ptm
	probs_returned[2][2] = 1 - probs_returned[0][2] - probs_returned[1][2]	# Ptt

	return probs_returned

if __name__ == "__main__":
	# ------------------------------- #
	# Set the experimental parameters #
	# ------------------------------- #
	L = 1300 # km
	E = 2.5 # GeV
	rho = 3 # g/cc
	Ye = 0.5

	# --------------------------------------------------------------------- #
	# Set the number of Newton-Raphson iterations which sets the precision. #
	# 0 is close to the single precision limit and is better than DUNE/HK   #
	# in the high statistics regime. Increasig N_Newton to 1,2,... rapidly  #
	# improves the precision at a modest computational cost                 #
	# --------------------------------------------------------------------- #
	N_Newton = 0

	# ------------------------------------- #
	# Set the vacuum oscillation parameters #
	# ------------------------------------- #
	s12sq = 0.31
	s13sq = 0.02
	s23sq = 0.55
	delta = 0.7 * np.pi
	Dmsq21 = 7.5e-5 # eV^2
	Dmsq31 = 2.5e-3 # eV^2

	# ------------------------------------------ #
	# Calculate all 9 oscillations probabilities #
	# ------------------------------------------ #
	probs_returned = Probability_Matter_LBL(s12sq, s13sq, s23sq, delta, Dmsq21, Dmsq31, L, E, rho, Ye, N_Newton)

	# --------------------------- #
	# Print out the probabilities #
	# --------------------------- #
	print("L =", L, "E =", E, "rho =", rho)
	print("Probabilities:")
	print("alpha beta P(nu_alpha -> nu_beta)")
	for alpha in range(3):
		for beta in range(3):
			print(alpha, beta, probs_returned[alpha][beta])


